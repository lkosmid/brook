
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Dec 19 2003 17:47:33
////////////////////////////////////////////

#include <brook.hpp>
#include <stdio.h>


static const char __foo_ps20[] = {
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s0\n"
"    dcl_2d s1\n"
"    dcl_2d s2\n"
"    mov r1.xy, c2\n"
"    mul r0.xy, c1, r1\n"
"    add r7.x, r0.x, c2.z\n"
"    add r7.y, r0.y, c2.w\n"
"    texld r2, t0, s0\n"
"    texld r9, t1, s1\n"
"    texld r4, r7, s2\n"
"    add r4.w, r2.x, r9.x\n"
"    add r11, r4.x, r4.w\n"
"    mov oC0, r11\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:6\n"
"//s:1:a\n"
"//s:1:b\n"
"//c:4:c\n"
"//c:1:d\n"
"//o:1:__e_stream\n"
"//c:1:__vout_counter\n"
"//workspace:1024\n"
""};


static const char __foo_fp30[] = {
"!!FP1.0\n"
"# NV_fragment_program generated by NVIDIA Cg compiler\n"
"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
"# command line args: -profile fp30 -DUSERECT -quiet\n"
"#vendor NVIDIA Corporation\n"
"#version 1.0.02\n"
"#profile fp30\n"
"#program main\n"
"#semantic main._workspace : C0\n"
"#semantic main._tex_a : TEXUNIT0\n"
"#semantic main._tex_b : TEXUNIT1\n"
"#semantic main.c : C1\n"
"#semantic main.d : TEXUNIT2\n"
"#semantic main._const_d_scalebias : C2\n"
"#semantic main.__vout_counter : C3\n"
"#var float4 _workspace : C0 :  : 0 : 1\n"
"#var samplerRECT _tex_a : TEXUNIT0 : texunit 0 : 1 : 1\n"
"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 2 : 1\n"
"#var samplerRECT _tex_b : TEXUNIT1 : texunit 1 : 3 : 1\n"
"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 4 : 1\n"
"#var float4 c : C1 :  : 5 : 1\n"
"#var samplerRECT d : TEXUNIT2 : texunit 2 : 6 : 1\n"
"#var float4 _const_d_scalebias : C2 :  : 7 : 1\n"
"#var float __vout_counter : C3 :  : 8 : 1\n"
"#var float4 main : $vout.COLOR0 : COLOR0 : -1 : 1\n"
"DECLARE _workspace;\n"
"DECLARE c;\n"
"DECLARE _const_d_scalebias;\n"
"DECLARE __vout_counter;\n"
"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
"TEX R1.x, f[TEX1].xyxx, TEX1, RECT;\n"
"ADDR R0.x, R0.x, R1.x;\n"
"TEX R1.x, c.xyxx, TEX2, RECT;\n"
"ADDR R0.x, R0.x, R1.x;\n"
"MOVR o[COLR].x, R0.x;\n"
"MOVR o[COLR].y, R0.x;\n"
"MOVR o[COLR].z, R0.x;\n"
"MOVR o[COLR].w, R0.x;\n"
"END \n"
"##!!BRCC\n"
"##narg:6\n"
"##s:1:a\n"
"##s:1:b\n"
"##c:4:c\n"
"##c:1:d\n"
"##o:1:__e_stream\n"
"##c:1:__vout_counter\n"
"##workspace:1024\n"
""};

void  __foo_cpu_inner (const __BrtFloat1  &a,
                       const __BrtFloat1  &b,
                       const __BrtFloat4  &c,
                       const __BrtArray<__BrtFloat1  , 2  , false> &d,
                       __BrtFloat1  &__e_stream,
                       __BrtFloat1  __vout_counter){
  __BrtFloat1  e;

  e = a + b + d[c.swizzle2(maskX, maskY)];
  if (__BrtFloat1(-1.000000f) == --__vout_counter)
  {
    __e_stream = e;
  }

}
void  __foo_cpu (const std::vector<void *>&args,
                 const std::vector<const unsigned int *>&extents,
                 const std::vector<unsigned int>&dims,
                 unsigned int mapbegin, 
                 unsigned int mapextent) {
  __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
  __BrtArray<__BrtFloat1  , 2  , false> arg3(
      (__BrtFloat1  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  unsigned int dim=dims[4];
  unsigned int newline=extents[4][dim-1];
  unsigned int ratio0 = extents[4][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[4][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[4]);
  unsigned int ratio1 = extents[4][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[4][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[4]);
  arg4+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __foo_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *arg2,
      arg3,
      *arg4,
      *arg5);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg4;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[4]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[4]);
    }
  }
}
extern float shiftValues(struct __BRTStream *a, 
                         struct __BRTStream *b, int,int,int);
extern unsigned int voutCombine(struct __BRTStream *outleft_stream,
                                float maxshiftleft,
                                unsigned int LEFTWIDTH,
                                struct __BRTStream *outright_stream,
                                float maxshiftright,
                                unsigned int RIGHTWIDTH,
                                unsigned int LENGTH,
                                struct __BRTStream * output);
void  foo (const __BRTStream& a,
		const __BRTStream& b,
		const float4  c,
		const __BRTStream& d,
		__BRTStream& __e_stream) {
  unsigned int __vout_counter=0;
  static const void *__foo_fp[] = {
     "fp30", __foo_fp30,
     "ps20", __foo_ps20,
     "cpu", (void *) __foo_cpu,
     NULL, NULL };
  static __BRTKernel k(__foo_fp);
  int dims = a->getDimension();
  assert(dims<=2);//don't handle other
  int outextents[2]={0,0};
  
  maxDimension(outextents,a->getExtents(),dims);
  maxDimension(outextents,b->getExtents(),dims);
  __BRTStream last_output (outextents,dims,__e_stream->getStreamType());
  __BRTStream temp (outextents,dims,__e_stream->getStreamType());
  __BRTStream temp2 (outextents,dims,__e_stream->getStreamType());

  unsigned int last_count=0;
  unsigned int last_size[2];
  for(;;++__vout_counter) {
     __BRTStream output(outextents,dims,__e_stream->getStreamType());
     k->PushStream(a);
     k->PushStream(b);
     k->PushConstant(c);
     k->PushGatherStream(d);
     k->PushOutput(output);
     k->PushConstant(__vout_counter);
     k->Map();
     
     if (last_count==0) {
        last_count=shiftValues(&output,
                               &last_output,
                               outextents[0],
                               outextents[1],
                               -1);
        last_size[1] = outextents[1];
        last_size[0] = outextents[0];
        if (last_count==0) {
           //FIXME truncate/swap
           break;
        }           
     }else{
        float count=shiftValues(&output,
                                &temp,
                                outextents[0],
                                outextents[1],
                                -1);
        if (count) {
           unsigned int totalsize=voutCombine(&last_output,
                                              last_count,
                                              last_size[0],
                                              &temp,
                                              count,
                                              outextents[0],
                                              last_size[1],
                                              &temp2);
           streamSwap(temp2,last_output);
           last_size[0] = totalsize/last_size[1]
              + ((totalsize%last_size[1]!=0)?1:0);
           last_count = last_size[0]*last_size[1]-totalsize;           
        }else {
           break;
        }
     }
  }
}


int  main()
{
  __BRTStream a(__BRTFLOAT,10 , 10,-1);
  __BRTStream b(__BRTFLOAT,10 , 10,-1);
  __BRTStream d(__BRTFLOAT,10 , 10,-1);
  __BRTStream e(__BRTFLOAT,10 , 10,-1);
  float  data_a[10][10];
  float  data_b[10][10];
  float4  c = float4 (1.000000f,0.000000f,3.200000f,5.000000f);
  float  data_d[10][10];
  float  data_e[10][10];
  float  d_broken = 0.000000f;
  int  i;
  int  j;

  for (i = 0; i < 10; i++)
    for (j = 0; j < 10; j++)
    {
      data_a[i][j] = (float ) (i) + (float ) (j) / 10.000000f;
      data_b[i][j] = (float ) (j) + (float ) (i) / 10.000000f;
      data_d[i][j] = (float ) (i) / 100.000000f;
    }

  streamRead(a,data_a);
  streamRead(b,data_b);
  streamRead(d,data_d);
  foo(a,b,c,d,e);
  streamWrite(e,data_e);
  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
    {
      printf("%3.2f ",data_e[i][j]);
    }

    printf("\n");
  }

  return 0;
}


