


// NOTE:
// Please generate the dataset and the twiddle factors by running the data.cc program in this directory
// and then run this program. This program currently works for power of 2 lengths. 


// References:
// [1] Alan V. Oppenheim and Ronald W. Schafer, ``Discrete-Time Signal Processing'', Prentice-Hall, 1989
// [2] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein,
//     ``Introduction to Algorithms'', MIT Press, 2001.
// NOTE:
// We implement the Decimation in Frequency Algorithm of the FFT described in [1]


#include <stdio.h>
#include <stdlib.h>
#include <math.h>


///Complex utilities/////////////
typedef struct complex {
  double r;
  double i;
}complex;


void init(complex *a)
{
  a->r = 0.0;
  a->i = 0.0;
}


void copy(complex *a, complex *b)
{
  a->r = b->r;
  a->i = b->i;
}


complex add(complex a, complex b)
{
  complex c;
  c.r = a.r + b.r;
  c.i = a.i + b.i;
  return c;
}


complex sub(complex a, complex b)
{
  complex c;
  c.r = a.r - b.r;
  c.i = a.i - b.i;
  return c;
}


complex mult(complex a, complex b)
{
  complex c;
  c.r = a.r*b.r - a.i*b.i;
  c.i = a.r*b.i + a.i*b.r;
  return c;
}


//////////////////////////////////////////////////


// typedef for our own convenience
typedef stream complex streamcmplx;
typedef stream complex *streamcmplx2;


// streamFileLoad()
kernel void
streamFileLoad(FileStream f, out streamcmplx p) {
  float fReal, fImag;
  brfscanf (f, "%f %f", &fReal, &fImag);
  p.r = fReal;
  p.i = fImag;
}


// streamFileStore() 
kernel void
streamFileStore(out FileStream f, streamcmplx p) {
  brfprintf(f, "%f  %f\n", p.r, p.i);
}


// streamPrint()
kernel void
streamPrint(streamcmplx s){
  printf(" %f  j%f\n", s.r, s.i);
}


kernel void
streamPrint2(streamcmplx2 s) {
  printf("%f  j%f\n", s[0].r, s[0].i);
  printf("%f  j%f\n", s[1].r, s[1].i);
}


// DFT()
// Implements the Perfect Shuffle algorithm
kernel void
DoDFT (streamcmplx  r, streamcmplx t, streamcmplx twiddle,
       out streamcmplx2 s_prime) {
  s_prime[0] = add(r, t);
  s_prime[1] = mult(sub(r,t), twiddle);
}


// Utilities and the BitReverse() procedure
// To compute 2**x
int TwoPowerX(int nNumber) {
  // Achieve the multiplication by left-shifting 
  return (1<<nNumber);
}


// Procedure to reverse the bits. 
// Example: 
// INPUTS:  nNumberToReverse = 110; nNumberOfBits = 3;
// OUTPUT:  nReversedNumber  = 011
// CAUTION: Make sure that you pass atleast the minimum number of bits to represent the 
//          number. For reversing 6 you need atleast 3 bits, if only 2 bits is passed then
//          we get junk results.


int BitReverse(int nNumberToReverse, int nNumberOfBits) {
  int nBitIndex;
  int nReversedNumber = 0;
  for (nBitIndex = nNumberOfBits-1; nBitIndex >= 0; --nBitIndex) {
    if ((1 == nNumberToReverse >> nBitIndex)) {         
      nReversedNumber  += TwoPowerX(nNumberOfBits-1-nBitIndex);    
      nNumberToReverse -= TwoPowerX(nBitIndex);                      
    }
  }
  return(nReversedNumber);
}


// BitReverseStream()
// INPUT: s, nDataLength. 
// OUTPUT: r. `r' contains the bit-reversed stream
void
BitReverseStream(streamcmplx r, streamcmplx s, int nDataLength) {
  int nIndex, B = 1;  
  complex *s_array = (complex *) calloc(nDataLength, sizeof(complex));


  // This assumes that nDataLength is a power of 2
  // Number of Bits
  while ((nDataLength >> B) > 0)              
    B++;


  B--; // Now 2**B gives the nDataLength
  
  // copy the stream to the array
  streamStore(s, s_array , nDataLength);
  
  for(nIndex = 1; nIndex < nDataLength-1; ++nIndex) 
    {
      int nReversedIndex = BitReverse(nIndex, B);
      complex temp;
      // Need to swap only half of the index 
      // and no need to swap the first and last
      if (nReversedIndex < nIndex) 
        continue; 
      // Swap by references 
      init(&temp);
      copy(&temp, s_array+nIndex);
      copy(s_array+nIndex, s_array+nReversedIndex);
      copy(s_array+nReversedIndex, &temp);
    } 
  
  // copy the bit-reversed stream into r
  streamLoad(r, s_array, nDataLength);
  // do the painful deallocation
  free(s_array); 
}



int main(int argc, char **argv)
{
  streamcmplx s, s_out;
  streamcmplx r;
  streamcmplx t;
  streamcmplx twiddle;
  
  streamcmplx W;
  streamcmplx stridedW;
  // passed as the out variable in the DFT
  streamcmplx2 s_prime "2";
  
  // variables to get around the strange ways of Brook
  // to get around the references in `flattening' the stream
  streamcmplx temp; 


  // Read the data
  FileStream fp = brfopen("data.txt", "rt");


  // NOTE: Twiddle factors
  // Reference: Pg 601 OS (1/e) Fig 9.18
  // Imagine Beginners Guide pg 23
  FileStream fpTwiddle = brfopen("twiddle.txt", "rt");
  // Outputs to a file
  FileStream fpOut     = brfopen("fftOutput.txt", "wt");


  // Please note that nPass and nBits denote the same but there
  // are two different variables for cleaner coding and easier
  // maintenance.
  int nPass, nBits;
  int nPassCounter;
  int nDataLength;


  // Read in the data
  streamFileLoad (fp, s);
  // Read in Twiddle factors
  streamFileLoad(fpTwiddle, twiddle);
  // get the length of data stream
  nDataLength = streamGetLength(s);
  
  // Just print the data for reference
  printf("The stream length is %d\n", nDataLength);
  printf("The given data is\n");
  streamPrint(s); 
  printf("\n");
  
  // handle the base case
  if(1 == nDataLength)
    s_out = s; // do nothing
  
  else {  
    // Number of passes = log2(nDataLength)
    // Implementation Notes:
    // There is an adjustment for nDataLength due to the fact that
    // ceil(10.0) will give 11 not 10. Thus if are dealing with 
    // nDataLength of powers of 2 then we have to subtract one 
    // to get the correct number of passes
    nPass        = (int) ceil(log(nDataLength-1)/M_LN2);
    nBits        = nPass;
    nPassCounter = 0;   
    
    while(nPassCounter < nPass)
      {
        if(0 == nPassCounter)
          {
            W = twiddle; //BAD_OLD_REF: streamCopy(W, twiddle);
          }
        else
          {
            int nIndex;
            int nStride = (int) pow(2.0, nPassCounter);
            streamStride(stridedW, twiddle, 1, 1, nStride-1);
            streamReplicate(W, stridedW, 1, nStride);
          }
        // Please remember that t = s[nDataLength/2 .. nDataLength) 
        // Do a `Perfect Shuffle'
        streamDomain(r, s, 1, 0, nDataLength/2); 
        streamDomain(t, s, 1, nDataLength/2, nDataLength);


        // DFT merge call. The heart of this program!
        DoDFT(r, t, W, s_prime);


        // To support the `in-place' perfect-shuffle algorithm 
        streamFlatten(s, s_prime);
        // update the PassCounter
        ++nPassCounter;
      } // while()
    
    // Note that 's' now has a bitreversed version of the FFT.
    // Since FFT is an in-place computation 's' contains the
    // the FFT(s) itself.
    // NOTE: streamBitReverse() isn't yet implemented. Just an emulation 
    BitReverseStream(s_out, s, nDataLength);
    streamFileStore(fpOut, s_out);  


    printf("The FFT of the given data is\n");
    streamPrint(s_out); 
    printf("\n");
    
  } // end of else construct
  
  return 0;
}
