


// NOTE:
// Please generate the dataset and the twiddle factors by running the data.cc program in this directory
// and then run this program. This program currently works for power of 2 lengths. 


// References:
// [1] Alan V. Oppenheim and Ronald W. Schafer, ``Discrete-Time Signal Processing'', Prentice-Hall, 1989
// [2] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein,
//     ``Introduction to Algorithms'', MIT Press, 2001.
// NOTE:
// We implement the Decimation in Frequency Algorithm of the FFT described in [1]


#include <stdio.h>
#include <stdlib.h>
#include <math.h>




kernel void init(out float2 a<>)
{
  a.x = 0.0;
  a.y = 0.0;
}


kernel void copy(out float2 a<>, float2 b<>)
{
  a.x = b.x;
  a.y = b.y;
}


kernel void add(float2 a <>, float2 b <>, out float2 c<>)
{
  c.x = a.x + b.x;
  c.y = a.y + b.y;
}


kernel void sub(float2 a <>, float2 b <>, out float2 c <>)
{
  c.x = a.x - b.x;
  c.y = a.y - b.y;
}


kernel void mult(float2 a <>, float2 b <>, out float2 c <>)
{
  c.x = a.x*b.x - a.y*b.y;
  c.y = a.x*b.y + a.y*b.x;
}


//////////////////////////////////////////////////
//FIXME

// streamFileLoad()
kernel void
streamFileLoad(FileStream f, out streamcmplx p) {
  float fReal, fImag;
  brfscanf (f, "%f %f", &fReal, &fImag);
  p.x = fReal;
  p.y = fImag;
}


// DFT()
// Implements the Perfect Shuffle algorithm
kernel void
DoDFT (float2  r<>, float2  t<>, float2 twiddle<>,
       out float4 s_prime<>) {
  s_prime.xy = add(r, t);
  s_prime.zw = (r-t)* twiddle;
}
kernel void flattenS (out float2 s<>, 
                      float4 s_prime<>, 
                      iter float address<>)
{
   if (round (fmod(address,2))==1.0f)
      s = s_prime.zw;
   else
      s = s_prime.xy;
}

// Utilities and the BitReverse() procedure
// To compute 2**x
int TwoPowerX(int nNumber) {
  // Achieve the multiplication by left-shifting 
  return (1<<nNumber);
}


// Procedure to reverse the bits. 
// Example: 
// INPUTS:  nNumberToReverse = 110; nNumberOfBits = 3;
// OUTPUT:  nReversedNumber  = 011
// CAUTION: Make sure that you pass atleast the minimum number of bits to represent the 
//          number. For reversing 6 you need atleast 3 bits, if only 2 bits is passed then
//          we get junk results.


int BitReverse(int nNumberToReverse, int nNumberOfBits) {
  int nBitIndex;
  int nReversedNumber = 0;
  for (nBitIndex = nNumberOfBits-1; nBitIndex >= 0; --nBitIndex) {
    if ((1 == nNumberToReverse >> nBitIndex)) {         
      nReversedNumber  += TwoPowerX(nNumberOfBits-1-nBitIndex);    
      nNumberToReverse -= TwoPowerX(nBitIndex);                      
    }
  }
  return(nReversedNumber);
}


// BitReverseStream()
// INPUT: s, nDataLength. 
// OUTPUT: r. `r' contains the bit-reversed stream
void
BitReverseStream(streamcmplx r, streamcmplx s, int nDataLength) {
  int nIndex, B = 1;  
  float2 *s_array = (float2 *) calloc(nDataLength, sizeof(float2));


  // This assumes that nDataLength is a power of 2
  // Number of Bits
  while ((nDataLength >> B) > 0)              
    B++;


  B--; // Now 2**B gives the nDataLength
  
  // copy the stream to the array
  streamStore(s, s_array , nDataLength);
  
  for(nIndex = 1; nIndex < nDataLength-1; ++nIndex) 
    {
      int nReversedIndex = BitReverse(nIndex, B);
      float2 temp;
      // Need to swap only half of the index 
      // and no need to swap the first and last
      if (nReversedIndex < nIndex) 
        continue; 
      // Swap by references 
      init(&temp);
      copy(&temp, s_array+nIndex);
      copy(s_array+nIndex, s_array+nReversedIndex);
      copy(s_array+nReversedIndex, &temp);
    } 
  
  // copy the bit-reversed stream into r
  streamLoad(r, s_array, nDataLength);
  // do the painful deallocation
  free(s_array); 
}



int main(int argc, char **argv)
{
  streamcmplx s, s_out;
  streamcmplx r;
  streamcmplx t;
  streamcmplx twiddle;
  
  streamcmplx W;
  streamcmplx stridedW;
  // passed as the out variable in the DFT
  streamcmplx2 s_prime "2";
  
  // variables to get around the strange ways of Brook
  // to get around the references in `flattening' the stream
  streamcmplx temp; 


  // Read the data
  FileStream fp = brfopen("data.txt", "rt");


  // NOTE: Twiddle factors
  // Reference: Pg 601 OS (1/e) Fig 9.18
  // Imagine Beginners Guide pg 23
  FileStream fpTwiddle = brfopen("twiddle.txt", "rt");
  // Outputs to a file
  FileStream fpOut     = brfopen("fftOutput.txt", "wt");


  // Please note that nPass and nBits denote the same but there
  // are two different variables for cleaner coding and easier
  // maintenance.
  int nPass, nBits;
  int nPassCounter;
  int nDataLength;


  // Read in the data
  streamFileLoad (fp, s);
  // Read in Twiddle factors
  streamFileLoad(fpTwiddle, twiddle);
  // get the length of data stream
  nDataLength = streamGetLength(s);
  
  // Just print the data for reference
  printf("The stream length is %d\n", nDataLength);
  printf("The given data is\n");
  streamPrint(s); 
  printf("\n");
  
  // handle the base case
  if(1 == nDataLength)
    s_out = s; // do nothing
  
  else {  
    // Number of passes = log2(nDataLength)
    // Implementation Notes:
    // There is an adjustment for nDataLength due to the fact that
    // ceil(10.0) will give 11 not 10. Thus if are dealing with 
    // nDataLength of powers of 2 then we have to subtract one 
    // to get the correct number of passes
    nPass        = (int) ceil(log(nDataLength-1)/M_LN2);
    nBits        = nPass;
    nPassCounter = 0;   
    
    while(nPassCounter < nPass)
      {
        if(0 == nPassCounter)
          {
            copy (W,twiddle); //BAD_OLD_REF: streamCopy(W, twiddle);
          }
        else
          {
            int nIndex;
            int nStride = (int) pow(2.0, nPassCounter);
            streamStride(stridedW, twiddle, 1, 1, nStride-1);
            streamReplicate(W, stridedW, 1, nStride);
          }
        // Please remember that t = s[nDataLength/2 .. nDataLength) 
        // Do a `Perfect Shuffle'
        streamDomain(r, s, 1, 0, nDataLength/2); 
        streamDomain(t, s, 1, nDataLength/2, nDataLength);


        // DFT merge call. The heart of this program!
        DoDFT(r, t, W, s_prime);


        // To support the `in-place' perfect-shuffle algorithm
        if (1) {
           
           flattenS(s, s_prime,iter);
        }
        // update the PassCounter
        ++nPassCounter;
      } // while()
    
    // Note that 's' now has a bitreversed version of the FFT.
    // Since FFT is an in-place computation 's' contains the
    // the FFT(s) itself.
    // NOTE: streamBitReverse() isn't yet implemented. Just an emulation 
    BitReverseStream(s_out, s, nDataLength);

    printf("The FFT of the given data is\n");
    streamPrint(s_out); 
    printf("\n");
    
  } // end of else construct
  
  return 0;
}
