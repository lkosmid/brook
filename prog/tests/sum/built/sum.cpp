
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Jul  4 2018 23:46:29
////////////////////////////////////////////

#include <brook/brook.hpp>
#include <stdio.h>
#include <built/sum_gles_bin.h>

static const char *__sum_ps20= NULL;
static const char *__sum_ps2b= NULL;
static const char *__sum_ps2a= NULL;
static const char *__sum_ps30= NULL;
static const char *__sum_ctm= NULL;
static const char *__sum_fp30= NULL;
static const char *__sum_fp40= NULL;
static const char *__sum_arb= NULL;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __sum_glsl_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"// glslf output by Cg compiler\n"
				"// cgc version 3.1.0013, build date Apr 18 2012\n"
				"// command line args: -quiet -DCGC=1 -profile glslf -DUSERECT=1\n"
				"// source file: /tmp/brookuCYdKD\n"
				"//vendor NVIDIA Corporation\n"
				"//version 3.1.0.13\n"
				"//profile glslf\n"
				"//program main\n"
				"//semantic main._tex_a : TEXUNIT0\n"
				"//semantic main._tex_b : TEXUNIT1\n"
				"//semantic main.__workspace : C0\n"
				"//var samplerRECT _tex_a : TEXUNIT0 : _tex_a1 0 : 0 : 1\n"
				"//var samplerRECT _tex_b : TEXUNIT1 : _tex_b1 1 : 2 : 1\n"
				"//var float2 _tex_a_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"//var float2 _tex_b_pos : $vin.TEXCOORD1 : TEX1 : 3 : 1\n"
				"//var float __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"\n"
				"#version 110\n"
				"\n"
				"#ifdef GL_ARB_texture_rectangle\n"
				"#extension GL_ARB_texture_rectangle : enable\n"
				"#endif\n"
				"\n"
				"struct double_struct {\n"
				"    vec2 _x;\n"
				"};\n"
				"\n"
				"struct double2_struct {\n"
				"    vec4 _xy;\n"
				"};\n"
				"\n"
				"float _output_01;\n"
				"vec4 _TMP0;\n"
				"uniform sampler2DRect _tex_a1;\n"
				"uniform sampler2DRect _tex_b1;\n"
				"float _c0012;\n"
				"\n"
				" // main procedure, the original name was main\n"
				"void main()\n"
				"{\n"
				"\n"
				"    float _a1;\n"
				"\n"
				"    _TMP0 = texture2DRect(_tex_a1, gl_TexCoord[0].xy);\n"
				"    _a1 = _TMP0.x;\n"
				"    _TMP0 = texture2DRect(_tex_b1, gl_TexCoord[1].xy);\n"
				"    _c0012 = _a1 + _TMP0.x;\n"
				"    _output_01 = _c0012;\n"
				"    gl_FragColor.x = _c0012;\n"
				"} //  \n"
				"//!!function:sum\n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:1:a\n"
				"//s:1:b\n"
				"//o:1:c\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __sum_glsl = &__sum_glsl_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __sum_gles_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"// glesf output by Cg compiler\n"
				"// cgc version 3.1.0013, build date Apr 18 2012\n"
				"// command line args: -quiet -DCGC=1 -profile glesf -DGL_ES\n"
				"// source file: /tmp/brookJlMbMG\n"
				"//vendor NVIDIA Corporation\n"
				"//version 3.1.0.13\n"
				"//profile glesf\n"
				"//program main\n"
				"//semantic main._tex_a : TEXUNIT0\n"
				"//semantic main._tex_b : TEXUNIT1\n"
				"//semantic main.__workspace : C0\n"
				"//var sampler2D _tex_a : TEXUNIT0 : _tex_a1 0 : 0 : 1\n"
				"//var sampler2D _tex_b : TEXUNIT1 : _tex_b1 1 : 2 : 1\n"
				"//var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 1 : 1\n"
				"//var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 3 : 1\n"
				"//var float __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"\n"
				"precision highp float;\n"
				"\n"
				"struct double_struct {\n"
				"    vec2 _x;\n"
				"};\n"
				"\n"
				"struct double2_struct {\n"
				"    vec4 _xy;\n"
				"};\n"
				"\n"
				"float _output_01;\n"
				"vec4 _TMP0;\n"
				"uniform sampler2D _tex_a1;\n"
				"uniform sampler2D _tex_b1;\n"
				"float _c0012;\n"
				"varying vec4 TEX0;\n"
				"varying vec4 TEX1;\n"
				"\n"
				" // main procedure, the original name was main\n"
				"void main()\n"
				"{\n"
				"\n"
				"    float _a1;\n"
				"\n"
				"    reconstruct_float(_TMP0.x, _tex_a1, TEX0.xy);\n"
				"    _a1 = _TMP0.x;\n"
				"    reconstruct_float(_TMP0.x, _tex_b1, TEX1.xy);\n"
				"    _c0012 = _a1 + _TMP0.x;\n"
				"    _output_01 = _c0012;\n"
				"    encode_output_float( _c0012);\n"
				"} //  \n"
				"//!!function:sum\n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:1:a\n"
				"//s:1:b\n"
				"//o:1:c\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __sum_gles = &__sum_gles_desc;
}

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __sum_gles_bin_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(sum_bin
				)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __sum_gles_bin = &__sum_gles_bin_desc;
}

static void  __sum_cpu_inner(const __BrtFloat1  &a,
                            const __BrtFloat1  &b,
                            __BrtFloat1  &c)
{
  c = a + b;
}
void  __sum_cpu(::brook::Kernel *__k, const std::vector<void *>&args, int __brt_idxstart, int __brt_idxend, bool __brt_isreduce)
{
  ::brook::StreamInterface *arg_a = (::brook::StreamInterface *) args[0];
  ::brook::StreamInterface *arg_b = (::brook::StreamInterface *) args[1];
  ::brook::StreamInterface *arg_c = (::brook::StreamInterface *) args[2];
  
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic, 16) if(!__brt_isreduce)
#endif
  for(int __brt_idx=__brt_idxstart; __brt_idx<__brt_idxend; __brt_idx++) {
    Addressable <__BrtFloat1  > __out_arg_c((__BrtFloat1 *) __k->FetchElem(arg_c, __brt_idx));
    __sum_cpu_inner (Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_a, __brt_idx)),
                     Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_b, __brt_idx)),
                     __out_arg_c);
    *reinterpret_cast<__BrtFloat1 *>(__out_arg_c.address) = __out_arg_c.castToArg(*reinterpret_cast<__BrtFloat1 *>(__out_arg_c.address));
  }
}

extern void  sum (::brook::stream a,
		::brook::stream b,
		::brook::stream c) {
  static const void *__sum_fp[] = {
     "fp30", __sum_fp30,
     "fp40", __sum_fp40,
     "arb", __sum_arb,
     "glsl", __sum_glsl,
     "gles", __sum_gles,
     "ps20", __sum_ps20,
     "ps2b", __sum_ps2b,
     "ps2a", __sum_ps2a,
     "ps30", __sum_ps30,
     "ctm", __sum_ctm,
     "cpu", (void *) __sum_cpu,
     "gles_bin", __sum_gles_bin,
     NULL, NULL };
  static BRTTLS ::brook::kernel* __pk;
  if(!__pk) __pk = new ::brook::kernel;
  __pk->initialize(__sum_fp);
  ::brook::kernel& __k = *__pk;

  __k->PushStream(a);
  __k->PushStream(b);
  __k->PushOutput(c);
  __k->Map();

}


int  main()
{
  int  i;
  int  j;
  ::brook::stream a1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream b1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream c1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream a2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  ::brook::stream b2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  ::brook::stream c2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  BRTALIGNED float  input_a1[100];
  BRTALIGNED float  input_b1[100];
  BRTALIGNED float  output_c1[100];
  BRTALIGNED float  input_a2[10][10];
  BRTALIGNED float  input_b2[10][10];
  BRTALIGNED float  output_c2[10][10];

  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
    {
      input_a1[10 * i + j] = (float ) (i);
      input_b1[10 * i + j] = (float ) (10) * j;
      input_a2[i][j] = (float ) (i);
      input_b2[i][j] = (float ) (10) * j;
    }

  }

  streamRead(a1,input_a1);
  streamRead(b1,input_b1);
  streamRead(a2,input_a1);
  streamRead(b2,input_b2);
  sum(a1,b1,c1);
  sum(a2,b2,c2);
  streamWrite(c1,output_c1);
  streamWrite(c2,output_c2);
  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
      printf("%3.2f ",output_c1[10 * i + j]);
    printf("\n");
  }

  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
      printf("%3.2f ",output_c2[i][j]);
    printf("\n");
  }

  return 0;
}


