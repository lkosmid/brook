#define FP_32_TEXTURE 1
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Dec 21 2015 17:49:16
////////////////////////////////////////////

#include <brook/brook.hpp>
#include <stdio.h>

static const char *__sum_ps20= NULL;
static const char *__sum_ps2b= NULL;
static const char *__sum_ps2a= NULL;
static const char *__sum_ps30= NULL;
static const char *__sum_ctm= NULL;
static const char *__sum_fp30= NULL;
static const char *__sum_fp40= NULL;
static const char *__sum_arb= NULL;
static const char *__sum_glsl= NULL;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __sum_gles_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"// glesf output by Cg compiler\n"
				"// cgc version 3.1.0013, build date Apr 18 2012\n"
				"// command line args: -quiet -DCGC=1 -profile glesf\n"
				"// source file: /tmp/brookGkshZp\n"
				"//vendor NVIDIA Corporation\n"
				"//version 3.1.0.13\n"
				"//profile glesf\n"
				"//program main\n"
				"//semantic main._tex_a : TEXUNIT0\n"
				"//semantic main._tex_b : TEXUNIT1\n"
				"//semantic main.__workspace : C0\n"
				"//var sampler2D _tex_a : TEXUNIT0 : _tex_a1 0 : 0 : 1\n"
				"//var sampler2D _tex_b : TEXUNIT1 : _tex_b1 1 : 2 : 1\n"
				"//var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 1 : 1\n"
				"//var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 3 : 1\n"
				"//var float __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"\n"
				"precision mediump float;\n"
				"\n"
				"struct double_struct {\n"
				"    vec2 _x;\n"
				"};\n"
				"\n"
				"struct double2_struct {\n"
				"    vec4 _xy;\n"
				"};\n"
				"\n"
				"float _output_01;\n"
				"vec4 _TMP0;\n"
				"uniform sampler2D _tex_a1;\n"
				"uniform sampler2D _tex_b1;\n"
				"float _c0012;\n"
				"varying vec4 TEX0;\n"
				"varying vec4 TEX1;\n"
				"\n"
      "#define reconstruct_input(reconstructed, textureUnit0, vTexCoord0)"
      "{"
      "  highp vec4 u_split;"
      //the returned value is in the range [0,1]
      "  u_split= texture2D(textureUnit0, vTexCoord0);"
//      "  reconstructed=floor(dot(u_split, vec4(255.0, 65535.0, 16777215.0, 0.0)));\n"
      "  highp float tmp;"
#if UINT_TEXTURE
      "  tmp = floor(256.0*u_split.x - (u_split.x/255.0));"
      "  reconstructed = tmp;"
      "  tmp = floor(256.0*u_split.y - (u_split.y/255.0))*256.0;"
      "  reconstructed += tmp;"
      "  tmp = floor(256.0*u_split.z - (u_split.z/255.0))*256.0*256.0;"
      "  reconstructed += tmp;"
//      "  tmp = floor(floor(floor(floor(256.0*u_split.w - (u_split.w/255.0))*256.0)*256.0)*256.0);\n"
//the last floor in that high order byte, causes an overflow, so that the number becomes negative!!!
//fortunately only the first floor is required the rest are redundant
      "  tmp = floor(256.0*u_split.w - (u_split.w/255.0))*256.0*256.0*256.0;"
      "  reconstructed += tmp;"
#elif BYTE_TEXTURE 
      "  tmp = floor(256.0*u_split.x - (u_split.x/255.0));"
      "  reconstructed = tmp;"
#elif SINT_TEXTURE
      "  tmp = floor(256.0*u_split.x - (u_split.x/255.0));"
      "  reconstructed = tmp;"
      "  tmp = floor(256.0*u_split.y - (u_split.y/255.0))*256.0;"
      "  reconstructed += tmp;"
      "  tmp = floor(256.0*u_split.z - (u_split.z/255.0))*256.0*256.0;"
      "  reconstructed += tmp;"
      "  tmp = floor(256.0*u_split.w - (u_split.w/255.0))*256.0*256.0*256.0;"
      "  reconstructed += tmp;"
      "  if(u_split.w > 0.5) reconstructed -= 4294967296.0;"
#elif FP_32_TEXTURE
//      "  highp float sign_value=1.0;"
	//reconstruct the exponent as a value from 0-255 
      "  tmp = floor(256.0*u_split.x - (u_split.x/255.0));"
      "  float exponent = tmp - 127.0;"
	//now let's get the 7 most significant bits of the mantissa and the sign bit (ignore it for the moment)
	//and convert it to 0-255
      "  tmp = floor(256.0*u_split.y - (u_split.y/255.0));"
	//divide it by 128 to scale it appropriately and add 1.0 because it is normalised (assume CPU guarantees it)
//      "  reconstructed = (tmp*0.0078125 + sign(128.0-tmp)*step(-126.0, exponent));\n" 
      "  reconstructed = (tmp*0.0078125) ;" 
      "  if(exponent >= -126.0) if(reconstructed < 1.0) reconstructed += 1.0 ;" 
//      "  if(tmp > 127.0) sign_value = -1.0 ;" 
//Note the .1: tmp is integer, so we ensure that sign==1 when tmp==127, since sign returns 0 when equal
      "  highp float sign_value = -sign(127.1 - tmp) ;" 
	//now let's get the next 8 most significant bits of the mantissa 
      "  tmp = floor(256.0*u_split.z - (u_split.z/255.0));"
	//we shift them by 7+8 positions (divide by 128*256) and add it to the number
      "  reconstructed += (tmp*0.000030517578125);" 
	#ifndef PRECISION_24_BIT
	//finally let's get the last 8 bits of the mantissa 
      "  tmp = floor(256.0*u_split.w - (u_split.w/255.0));"
	//we shift them by 7+8+8 positions (divide by 128*256*256) and add it to the number
      "  reconstructed += (tmp*0.00000011920928955078);" 
	#endif
	//Now just multiply with the exponent and we are ready 
//      "  reconstructed = reconstructed*exp2(exponent)*step(-126.0, exponent);\n" 
//      "  if(exponent > -127.0 ) reconstructed = sign_value*reconstructed*exp2(exponent);\n" 
//      "  else reconstructed = zero_literal;\n" 
      "  reconstructed = sign_value*reconstructed*exp2(exponent);" 
//      "  reconstructed =step(0.0, reconstructed);" 
#endif
      "}\n" 
      "#define encode_output(reconstructed)"
      "{" 
      "  highp vec4 u_split;"
#if UINT_TEXTURE
//      "  u_split.x = ((reconstructed - 256.0*floor(reconstructed/256.0))/255.0) ;"
      "  u_split.x = ((reconstructed - 256.0*floor(reconstructed*0.00390625))*0.00392156862745098) ;"
//      "  u_split.y = fract(floor(reconstructed*255.0/(255.0*256.0-1.0))/256.0) ;\n"
//      "  u_split.y = fract(floor(reconstructed/256.0+ reconstructed/(255.0*256.0))/256.0) ;\n"
//      "  u_split.y = fract((reconstructed - 256.0*256.0*floor(reconstructed/(256.0*256.0)))/255.0) ;\n"
      "  u_split.y = (floor((reconstructed - 256.0*256.0*floor(reconstructed*1.52587890625e-05))*0.00390625)*0.00392156862745098) ;"
      "  u_split.z = (floor((reconstructed - 256.0*256.0*256.0*floor(reconstructed*0.00000005960464477539))*1.52587890625e-05)*0.00392156862745098) ;"
      "  u_split.w = (floor((reconstructed - 256.0*256.0*256.0*256.0*floor(reconstructed*2.328306436538696289e-10))*0.00000005960464477539)*0.00392156862745098) ;"
#elif BYTE_TEXTURE 
      "  u_split.x = fract((reconstructed - 256.0*floor(reconstructed*0.00390625))/255.0) ;"
      "  u_split.yzw = vec3(0.0) ;"
#elif SINT_TEXTURE
      //let's use a temporary in the case that the passed value is a constant
      "  highp float _reconstructed=reconstructed;"
      "  if(_reconstructed < 0.0) _reconstructed += 4294967296.0;"
      "  u_split.x = ((_reconstructed - 256.0*floor(_reconstructed*0.00390625))*0.00392156862745098) ;"
      "  u_split.y = ( floor( ( _reconstructed - 256.0*256.0*floor(_reconstructed*1.52587890625e-05)) *0.00390625)*0.00392156862745098) ;"
      "  u_split.z = ( floor( ( _reconstructed - 256.0*256.0*256.0*floor(_reconstructed*0.00000005960464477539)) *1.52587890625e-05)*0.00392156862745098) ;"
	//floor is not needed, otherwise the result is wrong
      "  u_split.w = ((reconstructed/exp2(24.0))*0.00392156862745098) ;"
#elif FP_32_TEXTURE
      "  highp float exponent;"
      "  highp float tmp;"
	//compute the exponent
//use this to avoid -0.0
//      "  exponent = (floor(log2(abs(reconstructed))) + 127.0)*step(exp2(-125.0),abs(reconstructed)) ;"
      "  exponent = (floor(log2(abs(reconstructed))) + 127.0) ;"
	//save exponent as a byte
      "  u_split.x = ((exponent - 256.0*floor(exponent*0.00390625))*0.00392156862745098) ;"
	//get the mantissa (simply divide by the 2^exponent and -1.0 to store it in normalised form)
      "  tmp = clamp(abs(reconstructed*exp2(-floor(log2(abs(reconstructed))))) -1.0, 0.0, 1.0);"
      "  tmp = tmp*exp2(23.0);"
//      "  if(reconstructed < 0.0 ) sign_value = 128.0;"
//for some reason the above check is always true on my Imagination GPU, therefore use the expression below
//use this to avoid -0.0
//      "  highp float sign_value = step(exp2(-20.0), reconstructed)*128.0;"
      "  highp float sign_value = step(0.0, reconstructed)*128.0;"
      "  u_split.y = (floor((tmp - 256.0*256.0*256.0*floor(tmp*0.00000005960464477539))*1.52587890625e-05)+sign_value)*0.00392156862745098 ;"
      "  u_split.z = (floor((tmp - 256.0*256.0*floor(tmp*1.52587890625e-05))*0.00390625)*0.00392156862745098) ;"
//	#ifndef PRECISION_24_BIT
//      "  u_split.w = ((tmp- 256.0*floor(tmp*0.00390625))*0.00392156862745098) ;"
//	#else
      "  u_split.w = 0.0 ;"
//	#endif
#else
	"u_split.x=1.0;"
	"u_split.y=0.5/reconstructed;"
	"u_split.z=0.25;"
	"u_split.w=0.125;"
#endif
      "  gl_FragColor = u_split;"
      "}\n" 
				" // main procedure, the original name was main\n"
				"void main()\n"
				"{\n"
				"\n"
				"    float _a1;\n"
				"\n"
				"    reconstruct_input(_TMP0.x,_tex_a1, TEX0.xy);\n"
				"    _a1 = _TMP0.x;\n"
				"    reconstruct_input(_TMP0.x,_tex_b1, TEX1.xy);\n"
				"    _c0012 = _a1 + _TMP0.x;\n"
				"    _output_01 = _c0012;\n"
//      "  gl_FragColor = vec4(0.5,1.0,0.0,0.0);\n"
//      "  encode_output(9.0)\n"
      "  encode_output(_output_01)\n"
				"} //  \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:1:a\n"
				"//s:1:b\n"
				"//o:1:c\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __sum_gles = &__sum_gles_desc;
}

static void  __sum_cpu_inner(const __BrtFloat1  &a,
                            const __BrtFloat1  &b,
                            __BrtFloat1  &c)
{
  c = a + b;
}
void  __sum_cpu(::brook::Kernel *__k, const std::vector<void *>&args, int __brt_idxstart, int __brt_idxend, bool __brt_isreduce)
{
  ::brook::StreamInterface *arg_a = (::brook::StreamInterface *) args[0];
  ::brook::StreamInterface *arg_b = (::brook::StreamInterface *) args[1];
  ::brook::StreamInterface *arg_c = (::brook::StreamInterface *) args[2];
  
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic, 16) if(!__brt_isreduce)
#endif
  for(int __brt_idx=__brt_idxstart; __brt_idx<__brt_idxend; __brt_idx++) {
    Addressable <__BrtFloat1  > __out_arg_c((__BrtFloat1 *) __k->FetchElem(arg_c, __brt_idx));
    __sum_cpu_inner (Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_a, __brt_idx)),
                     Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_b, __brt_idx)),
                     __out_arg_c);
    *reinterpret_cast<__BrtFloat1 *>(__out_arg_c.address) = __out_arg_c.castToArg(*reinterpret_cast<__BrtFloat1 *>(__out_arg_c.address));
  }
}

extern void  sum (::brook::stream a,
		::brook::stream b,
		::brook::stream c) {
  static const void *__sum_fp[] = {
     "fp30", __sum_fp30,
     "fp40", __sum_fp40,
     "arb", __sum_arb,
     "glsl", __sum_glsl,
     "gles", __sum_gles,
     "ps20", __sum_ps20,
     "ps2b", __sum_ps2b,
     "ps2a", __sum_ps2a,
     "ps30", __sum_ps30,
     "ctm", __sum_ctm,
     "cpu", (void *) __sum_cpu,
     NULL, NULL };
  static BRTTLS ::brook::kernel* __pk;
  if(!__pk) __pk = new ::brook::kernel;
  __pk->initialize(__sum_fp);
  ::brook::kernel& __k = *__pk;

  __k->PushStream(a);
  __k->PushStream(b);
  __k->PushOutput(c);
  __k->Map();

}


int  main()
{
  int  i;
  int  j;
  int  k;
  ::brook::stream a1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream b1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream c1(::brook::getStreamType(( float  *)0), 100,-1);
  ::brook::stream a2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  ::brook::stream b2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  ::brook::stream c2(::brook::getStreamType(( float  *)0), 10 , 10,-1);
  BRTALIGNED float input_a1[100];
  BRTALIGNED float input_b1[100];
  BRTALIGNED float output_c1[100];
//  BRTALIGNED float  input_a2[10][10];
//  BRTALIGNED float  input_b2[10][10];
//  BRTALIGNED float  output_c2[10][10];

  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
    {
      input_a1[10 * i + j] = (float) (i);
      input_b1[10 * i + j] = (float) (10) * j;
//      input_a2[i][j] = (float ) (i);
//      input_b2[i][j] = (float ) (10) * j;
    }

  }

  streamRead(a1,input_a1);
  streamRead(b1,input_b1);
  sum(a1,b1,c1);
  streamWrite(c1,output_c1);
  for (i = 0; i < 10; i++)
  {
    for (j = 0; j < 10; j++)
//      for (k = 0; k < 4; k++)
//        printf("%d ",((unsigned char *) output_c1)[4 * 10 * i + 4*j + k]);
        printf("%f ",output_c1[10 * i + j]);
//        printf("%u ",((float*) output_c1)[10 * i + j]);
    printf("\n");
  }

  return 0;
}


