/** The triangle struct has 3 float4's  the float3 of each point is that points position
 *  The last value of the float4 indicates where 
 */
typedef struct Triangle_t{
  float4 A;
  float4 B;
  float4 C;
} Triangle;
//produces exactly four triangles for each input triangle. These triangles use the neighbor list to find the correct place
//neighbors:
//   [x . y . z . w ][x . y . z . w ][x . y . z . w][x . y . z . w][x . y . z . w][ x . y . z . w]
//      AB       AC      BC              A0      A1     A2     A3      B0     B1       B2    B3    
//...[x . y . z . w ][x . y . z . w ]
//      C0      C1      C2     C3
//
//   [x . y . z . w ][x . y . z . w ][x . y . z . w][x . y . z . w][x . y . z . w][ x . y . z . w]
//      AB       AC      BC    A0      A1      A2     B0     B1      B2     C0       C1       C2    
//
//        A0A1A2A3
//      ____a_____
//      \AC /\ AB/
//       \ /  \ /
//        /____\
//       c \BC/ b
// C0C1C2C3 \/  B1B2B3B4
//

kernel void UniformSubdivide (Triangle input<>, float4 neighbors[][], out Triangle outputA<>, out Triangle outputB<>, out Triangle outputC<>, out Triangle outputD<>, float round) {
  outputA=outputB=outputC=outputD=input;
  
}


kernel float4 calculatePlane (Triangle input) {
  float4 inputPlane;
  inputPlane.xyz = normalize(cross(input.C.xyz-input.A.xyz,
                                   input.B.xyz-input.A.xyz));
  inputPlane.w = -dot(input.A.xyz,inputPlane.xyz);
  return inputPlane;
}
kernel float signedDistancePlane (float4 plane, float3 point) {
  return dot(plane.xyz,point)-plane.w;
}
kernel float distancePlane (float4 plane, float3 point) {
  return abs(signedDistancePlane(plane,point));
}

// this kernel decides whether or not the four triangles are significant enough to subdivide.
// each edge is considered individually: if the triangle should not be subdivided, then it is
// not added into the bitmask.  Likewise 
kernel void shouldSubdivide (Triangle input<>,
                             Triangle A<>,
                             Triangle B<>,
                             Triangle C<>,
                             Triangle D<>,
                             out float whichEdges <>) {
  
  float threshold=.025;
  float4 inputPlane = calculatePlane(input);

  whichEdges=0;
  if (distancePlane(inputPlane,A.B.xyz)>threshold)
    //||distancePlane(inputPlane,B.A.xyz)>threshold
    whichEdges+=1;
  if (distancePlane(inputPlane,B.C.xyz)>threshold)
    //      ||distancePlane(inputPlane,C.B.xyz)>threshold
    whichEdges+=2;
  if (distancePlane(inputPlane,C.A.xyz)>threshold)
    //||distancePlane(inputPlane,A.C.xyz)>threshold      
    whichEdges+=4;
}

// spits out the indices of the parent into a list the size of which is the number of triangles
kernel void subdivisionIndices(float whichEdges<>,
                               vout[4] float2 indices<>) {
  float first=0;
  indices=(indexof whichEdges).xy;
  if (whichEdges<8) {
    push(indices);
  }
  indices=-(indices.xy+.25);
  indices.x=-1;
  indices.y=-1;
  if (whichEdges>0.25) {
    push(indices);
    indices.y=-2;
    push(indices);
    indices.y=-3;
    push(indices);      
  }
}
kernel void buildTriangleAndNeighborList (float whichEdges[][],
                                          float2 outputToInputIndices[][],
                                          float2 inputToOutputIndices[][],
                                          float4 oldNeighborList[][],
                                          out float4 neighborList<>) {
  neighborList=0;
}
                                          
extern int mainurbs(int argc, char ** argv);

int main (int argc, char **  argv) {
  int i;
   char nurbs=1;
   for (i=0;i<argc;++i) {
     char match=0;
     int j;
     if (strcmp(argv[i],"-nurbs")==0) {
       match=1;
       nurbs=1;
       
     }
     if (match) {
       for (j=i+1;j<argc;++j) argv[j-1]=argv[j];
       argc--;
       i--;
     }
   }
   if (nurbs)
     return mainurbs(argc,argv);

  return 0;
}
