typedef struct Tri_t{
   float4 A; // the last value of A indicates whether the edge AB is small
   float4 B; // enough to stop subdividing.  B.w also indicates if BC is small
   float4 C; // enough. C.w indicates if AC is small enough to stop subdividing
} Tri;

//When a triangle is split, the new triangle really only has six unique new
//values.  These are copied into the final 12 new triangle slots.
typedef struct SplitTri_t {
  float4 A;
  float4 AB;
  float4 B;
  float4 BC;
  float4 C;
  float4 AC;
}SplitTri;
//Stores the neighbors of a given triangle
// the unused 'w' components act as holders
// for the recomputed neighbor list when a triangle is split
typedef struct Neighbor_t {
  float4 AB;// w = AB->B.x
  float4 BBC;// w = AB->B.y
  float4 ABB;// w = AB->B.z
  float4 BC;// w = BC->C.x
  float4 ACC;// w = BC->C.y
  float4 BCC;// w = BC->C.z
  float4 AC;// w = AC->A.x
  float4 AAB;// w = AC->A.y
  float4 AAC;// w = AC->A.z
}Neighbor;


int counterMax = 3;
int low_texture_ram=0;
kernel float triCombine(float b1<>, float b2<>) {
   return (b1&&b2)?8:(b1?2:(b2?4:0));
}
// from a triangle and its neighbors, determines whether that edge is small
// enough
kernel float isNeighbor(float4 neigh) {
   return neigh.z!=0;
}
kernel float isNotNeighbor(float4 neigh) {
  return neigh.z==0;
}
kernel void smallEnough(Tri t<>, Neighbor u<>, 
                        out Tri v<>, 
                        out Neighbor n<>, 
                        float epsilon) {
  v.A.xyz = t.A.xyz;
  v.A.w = (//t.A.w!=0 &&
                  dot(t.A.xyz-t.B.xyz,t.A.xyz-t.B.xyz)>epsilon)?1.0:0.0;
  v.B.xyz = t.B.xyz;
  v.B.w = (float)(//t.B.w!=0 &&
                  (dot(t.B.xyz-t.C.xyz,t.B.xyz-t.C.xyz)>epsilon))?1.0:0.0;
  v.C.xyz = t.C.xyz;
  v.C.w = (//t.C.w!=0 &&
                  (dot(t.A.xyz-t.C.xyz,t.A.xyz-t.C.xyz)>epsilon))?1.0:0.0;
  n.AB.xyz = u.AB.xyz;
  n.AB.w = triCombine(//u.AB.w,
                      (dot(t.A.xyz-u.AB.xyz,t.A.xyz-u.AB.xyz)>epsilon)?1.0:0.0,
                      (dot(t.B.xyz-u.AB.xyz,t.B.xyz-u.AB.xyz)>epsilon)?1.0:0.0);
  n.BC.xyz=u.BC.xyz;
  n.BC.w = triCombine(//u.BC.w,
                      (dot(t.B.xyz-u.BC.xyz,t.B.xyz-u.BC.xyz)>epsilon)?1.0:0.0,
                      (dot(t.C.xyz-u.BC.xyz,t.C.xyz-u.BC.xyz)>epsilon)?1.0:0.0);
  n.AC.xyz=u.AC.xyz;
  n.AC.w = triCombine(//u.AC.w,
                      (dot(t.C.xyz-u.AC.xyz,t.C.xyz-u.AC.xyz)>epsilon)?1.0:0.0,
                      (dot(t.A.xyz-u.AC.xyz,t.A.xyz-u.AC.xyz)>epsilon)?1.0:0.0);
  n.AAC.xyz=u.AAC.xyz;
  n.AAC.w = (isNotNeighbor(u.AAC)||
             dot(t.A.xyz-u.AAC.xyz,t.A.xyz-u.AAC.xyz)>epsilon)?1.0:0;
  n.AAB.xyz=u.AAB.xyz;
  n.AAB.w = (isNotNeighbor(u.AAB)||
             dot(t.A.xyz-u.AAB.xyz,t.A.xyz-u.AAB.xyz)>epsilon)?1.0:0;
  n.ABB.xyz=u.ABB.xyz;
  n.ABB.w = (isNotNeighbor(u.ABB)||
             dot(t.B.xyz-u.ABB.xyz,t.B.xyz-u.ABB.xyz)>epsilon)?1.0:0;
  n.BBC.xyz=u.BBC.xyz;
  n.BBC.w = (isNotNeighbor(u.BBC)||
             dot(t.B.xyz-u.BBC.xyz,t.B.xyz-u.BBC.xyz)>epsilon)?1.0:0;
  n.BCC.xyz=u.BCC.xyz;
  n.BCC.w = (isNotNeighbor(u.BCC)||
             dot(t.C.xyz-u.BCC.xyz,t.C.xyz-u.BCC.xyz)>epsilon)?1.0:0;
  n.ACC.xyz=u.ACC.xyz;
  n.ACC.w = (isNotNeighbor(u.ACC)||
             dot(t.C.xyz-u.ACC.xyz,t.C.xyz-u.ACC.xyz)>epsilon)?1.0:0;
}
kernel void produceTriP(Tri t<>, vout [1]float2 shouldProduce<>, vout[1] float2 shouldNotProduce<>){
   if (t.A.w!=0.0f
       ||t.B.w!=0.0f
       ||t.C.w!=0.0f) {
     shouldProduce = (indexof t).xy;
     push(shouldProduce);
   }else {
     shouldNotProduce = (indexof t).xy;
     push(shouldNotProduce);
   }
}

kernel void computeNeighbors(Tri tgather[][], Neighbor ugather[][], float2 i<>, out Neighbor v<>) {
  Neighbor u = ugather[i];
  float eAAB=isNeighbor(u.AAB);
  float eAAC=isNeighbor(u.AAC);
  float eABB=isNeighbor(u.ABB);
  float eBBC=isNeighbor(u.BBC);
  float eBCC=isNeighbor(u.BCC);
  float eACC=isNeighbor(u.ACC);
  Tri t = tgather[i];
  float3 AB_B, AC_A, BC_C;
  float3 zero3=0;
  AB_B=lerp(t.B.xyz,u.AB.xyz,.5);
  if (u.AB.w==4||u.AB.w==8)
     AB_B=lerp(AB_B,
               lerp(t.A.xyz,eABB?u.ABB.xyz:eBBC?u.BBC.xyz:u.BC.xyz,.5),
               .25);
  AC_A=lerp(t.A.xyz,u.AC.xyz,.5);
  if (u.AC.w==4||u.AC.w==8)
     AC_A=lerp(AC_A,
               lerp(t.C.xyz,eAAC?u.AAC.xyz:eAAB?u.AAB.xyz:u.AB.xyz,.5),
               .25);
  BC_C=lerp(t.C.xyz,u.BC.xyz,.5);
  if (u.BC.w==4||u.AC.w==8)
     BC_C=lerp(BC_C,
               lerp(t.B.xyz,eBCC?u.BCC.xyz:eACC?u.ACC.xyz:u.AC.xyz,.5),
               .25);
  v.AB.xyz = lerp(t.A.xyz,u.AB.xyz,.5);
  if (u.AB.w==2||u.AB.w==8)
     v.AB.xyz = lerp(v.AB.xyz,
                     lerp(t.B.xyz,eAAB?u.AAB.xyz:eAAC?u.AAC.xyz:u.AC.xyz,.5),
                     .25);
  v.AB.w = AB_B.x;
  v.BBC.xyz = eBBC?lerp(t.B.xyz,u.BBC.xyz,.5):zero3;
  if (u.BBC.w)
     v.BBC.xyz = lerp(v.BBC.xyz,
                      lerp(eABB?u.ABB.xyz:u.AB.xyz,u.BC.xyz,.5),
                      .25);
  v.BBC.w = AB_B.y;
  v.ABB.xyz = eABB?lerp(t.B.xyz,u.ABB.xyz,.5):zero3;
  if (u.ABB.w)
     v.ABB.xyz = lerp(v.ABB.xyz,
                      lerp(u.AB.xyz,eBBC?u.BBC.xyz:u.BC.xyz,.5),
                      .25);
  v.ABB.w = AB_B.z;
  v.AC.xyz = lerp(t.C.xyz,u.AC.xyz,.5);
  if (u.AC.w==2||u.AC.w==8)
     v.AC.xyz = lerp(v.AC.xyz,
                     lerp(t.A.xyz,eACC?u.ACC.xyz:eBCC?u.BCC.xyz:u.BC.xyz,.5),
                     .25);
  v.AC.w = AC_A.x;
  v.AAB.xyz = eABB?lerp(t.A.xyz,u.AAB.xyz,.5):zero3;
  if (u.AAB.w)
     v.AAB.xyz = lerp(v.AAB.xyz,
                      lerp(eACC?u.AAC.xyz:u.AC.xyz,u.AB.xyz,.5),
                      .25);
  v.AAB.w = AC_A.y;
  v.AAC.xyz = eACC?lerp(t.A.xyz,u.AAC.xyz,.5):zero3;
  if (u.AAC.w)
     v.AAC.xyz = lerp(v.AAC.xyz,
                      lerp(eAAB?u.AAB.xyz:u.AB.xyz,u.AC.xyz,.5),
                      .25);
  v.AAC.w = AC_A.z;
  v.BC.xyz = lerp(t.B.xyz,u.BC.xyz,.5);
  if (u.BC.w==2||u.BC.w==8)
     v.BC.xyz = lerp(v.BC.xyz,
                     lerp(t.C.xyz,eBBC?u.BBC.xyz:eACC?u.ACC.xyz:u.AC.xyz,.5),
                     .25);
  v.BC.w = BC_C.x;
  v.ACC.xyz = eACC?lerp(t.C.xyz,u.ACC.xyz,.5):zero3;
  if (u.ACC.w)
     v.ACC.xyz = lerp(v.ACC.xyz,
                      lerp(u.AC.xyz,eBCC?u.BCC.xyz:u.AB.xyz,.5),
                      .25);
  v.ACC.w = BC_C.y;
  v.BCC.xyz = eBCC?lerp(t.C.xyz,u.BCC.xyz,.5):zero3;
  if (u.BCC.w)
     v.BCC.xyz = lerp(v.BCC.xyz,
                      lerp(u.BC.xyz,eACC?u.ACC.xyz:u.AC.xyz,.5),
                      .25);
  v.BCC.w = BC_C.z;  
}
kernel void copyFinalTriangles (Tri tri<>,
                                 out float3 triList<>) {
  float whichVertex=round(fmod((indexof triList).x,3));
  triList = tri.A.xyz;
  if (whichVertex>.5&&whichVertex<1.5)
    triList=tri.B.xyz;
  else if (whichVertex>=1.5&&whichVertex<2.5)
    triList=tri.C.xyz;
}
kernel void writeFinalTriangles (Tri triangles[][],
                                 float2 indices<>,
                                 out float3 triList<>) {
  copyFinalTriangles(triangles[indices],triList);
}
kernel float4 addN(float3 inxyz, float inw) {
   float4 x = float4(inxyz.x,
                     inxyz.y,
                     inxyz.z,
                     inw);
   return x;
} 
kernel float4 identity(float4 a, float b){return a;}
kernel float3 ident3(float3 a, float b) {return a;}
kernel void splitTriangles (Tri triangles[][], 
                            Neighbor neighbors[][],
                            float2 i<>,
                            out SplitTri splittri<>) {
  Tri tri=triangles[i];
  Neighbor oldneighbors=neighbors[i];
  float eAAB=isNeighbor(oldneighbors.AAB);
  float eAAC=isNeighbor(oldneighbors.AAC);
  float eABB=isNeighbor(oldneighbors.ABB);
  float eBBC=isNeighbor(oldneighbors.BBC);
  float eBCC=isNeighbor(oldneighbors.BCC);
  float eACC=isNeighbor(oldneighbors.ACC);
  float Aneighbors = 4.0f+eAAC+eAAB;
  float Bneighbors = 4.0f+eBBC+eABB;
  float Cneighbors = 4.0f+eBCC+eACC;
  float an = .375+(.375+.25*cos(2*3.1415926536/Aneighbors));
  float bn = .375+(.375+.25*cos(2*3.1415926536/Bneighbors));
  float cn = .375+(.375+.25*cos(2*3.1415926536/Cneighbors));
  float anon = (1-an)/Aneighbors;
  float bnon = (1-bn)/Bneighbors;
  float cnon = (1-cn)/Cneighbors;
  splittri.AC = lerp (tri.A,tri.C,.5);
  if (tri.C.w)
    splittri.AC = addN(lerp(splittri.AC.xyz,
                            lerp (tri.B.xyz,oldneighbors.AC.xyz,.5),
                            .25),
                       1);
  splittri.AB = lerp (tri.A,tri.B,.5);
  if (tri.A.w)
    splittri.AB = addN(lerp(splittri.AB.xyz,
                                lerp(tri.C.xyz,oldneighbors.AB.xyz,.5),
                                .25),
                           1);
  splittri.BC = lerp (tri.B,tri.C,.5);
  if (tri.B.w)
    splittri.BC = addN(lerp(splittri.BC.xyz,
                                lerp(tri.A.xyz,oldneighbors.BC.xyz,.5),
                                .25),
                           1);
  splittri.A = tri.A;
  if (tri.A.w&&
      tri.C.w&&
      (oldneighbors.AC.w==4||oldneighbors.AC.w==8)&&
      (oldneighbors.AB.w==2||oldneighbors.AB.w==8)&&
      oldneighbors.AAB.w&&
      oldneighbors.AAC.w)       
     splittri.A.xyz = tri.A.xyz*an
        +oldneighbors.AB.xyz*anon
        +oldneighbors.AC.xyz*anon
        +oldneighbors.AAB.xyz*anon
        +oldneighbors.AAC.xyz*anon
        +tri.B.xyz*anon
        +tri.C.xyz*anon;

  splittri.B = tri.B;
  if (tri.A.w&&
      tri.B.w&&
      (oldneighbors.BC.w==2||oldneighbors.BC.w==8)&&
      (oldneighbors.AB.w==4||oldneighbors.AB.w==8)&&
      oldneighbors.ABB.w&&
      oldneighbors.BBC.w)        
    splittri.B.xyz= tri.B.xyz*bn
       +oldneighbors.AB.xyz*bnon
       +oldneighbors.BC.xyz*bnon
       +oldneighbors.ABB.xyz*bnon
       +oldneighbors.BBC.xyz*bnon
       +tri.A.xyz*bnon
       +tri.C.xyz*bnon;

  splittri.C = tri.C;
  if (tri.C.w&&
      tri.B.w&&
      (oldneighbors.BC.w==4||oldneighbors.BC.w==8)&&
      (oldneighbors.AC.w==2||oldneighbors.AC.w==8)&&
      oldneighbors.ACC.w&&
      oldneighbors.BCC.w)       
     splittri.C.xyz = tri.C.xyz*cn
        +oldneighbors.AC.xyz*cnon
        +oldneighbors.BC.xyz*cnon
        +oldneighbors.ACC.xyz*cnon
        +oldneighbors.BCC.xyz*cnon
        +tri.A.xyz*cnon
        +tri.B.xyz*cnon;
}


kernel void linearReorgSplitTriangles (SplitTri splittri<>,
                                       Neighbor newnei<>,
                                       out Tri tri<>,
                                       out Neighbor neighbor<>,
                                       float epsilon,
                                       float stretchX) {
  float sindex = stretchX?(indexof tri).x:(indexof tri).y;
  float unclampedwhich = round(fmod(sindex,4));
  float which = unclampedwhich>3.5?0:unclampedwhich;
  float4 ac = splittri.AC;
  float4 ab = splittri.AB;
  float4 bc = splittri.BC;
  float4 a = splittri.A;
  float4 b = splittri.B;
  float4 c = splittri.C;
  float4 BC_C= {newnei.BC.w,
                newnei.ACC.w,
                newnei.BCC.w,1};
  float4 AC_A = {newnei.AC.w,
                 newnei.AAB.w,
                 newnei.AAC.w,1};
  float4 AB_B = {newnei.AB.w,
                 newnei.BBC.w,
                 newnei.ABB.w,1};
  if (which<.5) {
    tri.A=identity(a,1);
    tri.B=identity(ab,1);
    tri.C=identity(ac,1);

    neighbor.BCC = c;
    neighbor.BC = bc;
    neighbor.BBC= b;
    neighbor.ABB= AB_B;
    neighbor.AB = newnei.AB;
    neighbor.AAB =  newnei.AAB;
    neighbor.AAC =  newnei.AAC;
    neighbor.AC = AC_A;
    neighbor.ACC = newnei.AC;
  }else if (which <1.5) {
    tri.A= identity(ab,1);
    tri.B=identity(b,1);
    tri.C=identity(bc,1);

    neighbor.BCC = BC_C;
    neighbor.BC = newnei.BC;
    neighbor.BBC=newnei.BBC;
    neighbor.ABB=newnei.ABB;
    neighbor.AB = AB_B;
    neighbor.AAB = newnei.AB;
    neighbor.AAC = a;
    neighbor.AC = ac;
    neighbor.ACC = c;
  }else if (which<2.5) {
    
    tri.A=identity(ac,1);
    tri.B=identity(ab,1);
    tri.C=identity(c,1);

    neighbor.BCC=newnei.BCC;
    neighbor.BC=BC_C;
    neighbor.BBC = newnei.BC;
    neighbor.ABB = b;
    neighbor.AB = ab;
    neighbor.AAB = a;
    neighbor.AAC = AC_A;
    neighbor.AC = newnei.AC;
    neighbor.ACC = newnei.ACC;
  }else {
    tri.A=identity(bc,1);
    tri.B=identity(ac,1);
    tri.C=identity(ab,1);

    neighbor.BCC = newnei.AB;
    neighbor.BC = a;
    neighbor.BBC= AC_A;
    neighbor.ABB= newnei.AC;
    neighbor.AB = c;
    neighbor.AAB = BC_C;
    neighbor.AAC = newnei.BC;
    neighbor.AC = b;
    neighbor.ACC = AB_B;
  }
  smallEnough(tri,neighbor,tri,neighbor,epsilon);
}

struct VertexArray{
  float3 * v;
  unsigned int size;
  unsigned int alloc;
};
void initVertexArray(struct VertexArray *v) {
  v->v=0;v->size=0;v->alloc=0;
}
void destroyVertexArray(struct VertexArray *v) {
  if (v->v) free(v->v);
}
void expandVertexArray(struct VertexArray * v,
                       unsigned int more) {
  v->size+=more;
  while(v->size>v->alloc) {
    if (v->alloc==0)
      v->alloc=16;
    v->alloc*=2;
    v->v = (float3*)realloc(v->v,v->alloc*sizeof(float3));
  }
}                   
void pushBackVertexArray(struct VertexArray * v,
                         float3 f) {
  if (++v->size>v->alloc) {
    if (v->alloc==0)
      v->alloc=16;
    v->alloc*=2;
    v->v = (float3*)realloc(v->v,v->alloc*sizeof(float3));
  }
  v->v[v->size-1]=f;
}                   
static int toi(float f) {return (int)f;}
void subdivide (Neighbor (*neighbors)<>,
                Tri (*triangles)<>,
                struct VertexArray *output,
                float epsilon,
                int counter) {
  unsigned int streamY=toi(streamSize(*triangles).y);
  unsigned int streamX=toi(streamSize(*triangles).x);
  {
    float2 shouldProduce<0,streamX>;
    float2 shouldNotProduce<0,streamX>;
    produceTriP(*triangles,shouldProduce,shouldNotProduce);
    assert((int)streamX==toi(streamSize(shouldProduce).x));
    streamY=toi(streamSize(shouldProduce).y);
    if (streamY&&streamX) {
      float stretchX = streamY*4>2048?1:0;      
      
      Neighbor sharedNeighbors<streamY,streamX>;
      SplitTri sharedTriangles <streamY,streamX>;
      Neighbor newNeighbors<(stretchX?streamY:streamY*4),
                            (stretchX?streamX*4:streamX)>;
      Tri newTriangles<(stretchX?streamY:streamY*4),
                       (stretchX?streamX*4:streamX)>;
      computeNeighbors(*triangles,*neighbors,shouldProduce,sharedNeighbors);
      splitTriangles(*triangles,*neighbors,shouldProduce,sharedTriangles);
      linearReorgSplitTriangles(sharedTriangles,
                                sharedNeighbors,
                                newTriangles,
                                newNeighbors,
                                epsilon,
                                stretchX);
      streamSwap(*triangles,newTriangles);
      streamSwap(*neighbors,newNeighbors);
    }
    if (streamSize(shouldNotProduce).y){
      int sizex=3*toi(streamSize(shouldNotProduce).x);
      int sizey=toi(streamSize(shouldNotProduce).y);
      float3 outputTri<sizey,sizex>;

      writeFinalTriangles(*triangles,shouldNotProduce,outputTri);      
        if ((!low_texture_ram)&&
            streamSize(shouldProduce).y&&
            streamSize(shouldProduce).x&&
            counter<counterMax) {
          subdivide(neighbors,triangles,output,epsilon,counter+1);
        } 
        
        sizey = output->size;
        expandVertexArray(output,(unsigned int)(streamSize(outputTri).x*
                                                streamSize(outputTri).y));
        streamWrite(outputTri,output->v+sizey);   
    }       
    if (counter>=counterMax) {
      float3 outputTri<toi(streamSize(*triangles).x),
        toi(streamSize(*triangles).x*3)>;
      int sizey = output->size;
      copyFinalTriangles(*triangles,outputTri);
      expandVertexArray(output,
                        3*toi(streamSize(*triangles).y*streamSize(*triangles).x));
      streamWrite(outputTri,output->v+sizey);
    }
    
  }
  if (low_texture_ram&&streamY&&streamX&&counter<counterMax) {
     subdivide(neighbors,triangles,output,epsilon,counter+1);
  } 
  // prevents all writing at the end
}

extern unsigned int  loadModelData(const char * filename, 
                                   Tri **tris, 
                                   Neighbor **nei);

Tri *  createTriangles (unsigned int howMany) {
  Tri * ret;  
  ret=(Tri*)malloc(sizeof(Tri)*howMany);
  memset(ret,0,sizeof(Tri)*howMany);
  return ret;
}
Neighbor *  createNeighbors (Tri * tri, unsigned int howMany) {
  Neighbor * ret;  
  ret=(Neighbor*)malloc(sizeof(Neighbor)*howMany);
  memset(ret,0,sizeof(Neighbor)*howMany);
  return ret;
}
void bestHeiWid(unsigned int totalSize,
                unsigned int *hei,
                unsigned int *wid) {
   int slop=totalSize*2;
   int maxy = 0;
   int best = 11;
   unsigned int i;
   for (i=0;i<12;++i) {
      int x= (1<<i);
      int y = totalSize/x+(totalSize%x==0?0:1);
      int tslop;
      if (x>2048||y>2048)
         continue;
      tslop = x*y - totalSize;
      if (tslop<0)
         continue;
      if ((tslop<slop&&y>maxy)||
          (y>maxy&&tslop<2*y/3)) {
         *hei=y;
         *wid=x;
         maxy = y;
         slop = tslop;
         best = i;
      }
   }
}
unsigned int bestHeight(unsigned int totalSize){
   unsigned int hei=0,wid=0;
   bestHeiWid(totalSize,&hei,&wid);
   return hei;
}
unsigned int bestWidth(unsigned int totalSize){
   unsigned int hei=0,wid=0;
   bestHeiWid(totalSize,&hei,&wid);
   return wid;
}
unsigned int loadModelData(char* file,Tri **triangles,Neighbor **neighbors);
int main (int argc, char**argv) {
  float epsilon=.0001;
  Tri *triangledata = 0;
  Neighbor *neighbordata = 0;
  unsigned int numTriangles = 
     loadModelData(argc>1?argv[1]:"dragon.ply",&triangledata,&neighbordata);
  Neighbor neighbors<bestHeight(numTriangles),bestWidth(numTriangles)>;
  Tri triangles<bestHeight(numTriangles),bestWidth(numTriangles)>;
  struct VertexArray v;
  streamRead(triangles,triangledata);
  streamRead(neighbors,neighbordata);
  initVertexArray(&v);
  
  // initialize neighbors and triangles
  smallEnough(triangles,neighbors,triangles,neighbors,epsilon);
  subdivide(&neighbors,&triangles,&v,epsilon,0);
  return 0;
}



