typedef struct Tri_t{
   float4 A;
   float4 B;
   float4 C;
} Tri;
//Stores the neighbors of a given triangle
// the unused 'w' components act as holders
// for the recomputed neighbor list when a triangle is split
typedef struct Neighbor_t {
  float4 AB;// w = AB->B.x
  float4 BBC;// w = AB->B.y
  float4 ABB;// w = AB->B.z
  float4 BC;// w = BC->C.x
  float4 ACC;// w = BC->C.y
  float4 BCC;// w = BC->C.z
  float4 AC;// w = AC->A.x
  float4 AAB;// w = AC->A.y
  float4 AAC;// w = AC->A.z
}Neighbor;


kernel void smallEnough(Tri t<>, Neighbor u<>, out Tri v<>, float epsilon) {
  v.A.xyz = t.A.xyz;
  v.A.w = (float)(t.A.w!=0 &&
                  (dot(t.A.xyz-t.B.xyz,t.A.xyz-t.B.xyz)>epsilon
                   || dot(t.A.xyz-t.C.xyz,t.A.xyz-t.C.xyz)>epsilon
                   || dot(t.A.xyz-u.AB.xyz,t.A.xyz-u.AB.xyz)>epsilon
                   || dot(t.A.xyz-u.AC.xyz,t.A.xyz-u.AC.xyz)>epsilon
                   || dot(t.A.xyz-u.AAC.xyz,t.A.xyz-u.AAC.xyz)>epsilon
                   || dot(t.A.xyz-u.AAB.xyz,t.A.xyz-u.AAB.xyz)>epsilon));
  v.B.xyz = t.B.xyz;
  v.B.w = (float)(t.B.w!=0 &&
                  (dot(t.A.xyz-t.B.xyz,t.A.xyz-t.B.xyz)>epsilon
                   || dot(t.B.xyz-t.C.xyz,t.B.xyz-t.C.xyz)>epsilon
                   || dot(t.B.xyz-u.AB.xyz,t.B.xyz-u.AB.xyz)>epsilon
                   || dot(t.B.xyz-u.BC.xyz,t.B.xyz-u.BC.xyz)>epsilon
                   || dot(t.B.xyz-u.BBC.xyz,t.B.xyz-u.BBC.xyz)>epsilon
                   || dot(t.B.xyz-u.ABB.xyz,t.B.xyz-u.ABB.xyz)>epsilon));
  v.C.xyz= t.C.xyz;
  v.C.w = (float)(t.C.w!=0 &&
                  (dot(t.A.xyz-t.C.xyz,t.A.xyz-t.C.xyz.xyz)>epsilon
                   || dot(t.B.xyz-t.C.xyz,t.B.xyz-t.C.xyz)>epsilon
                   || dot(t.C.xyz-u.AC.xyz,t.C.xyz-u.AC.xyz)>epsilon
                   || dot(t.C.xyz-u.BC.xyz,t.C.xyz-u.BC.xyz)>epsilon
                   || dot(t.C.xyz-u.BCC.xyz,t.C.xyz-u.BCC.xyz)>epsilon
                   || dot(t.C.xyz-u.ACC.xyz,t.C.xyz-u.ACC.xyz)>epsilon));

}
kernel void produceTriP(Tri t<>, vout [1]float2 shouldProduce<>, vout[1] float2 shouldNotProduce<>){
   if (t.A.w!=0.0f
       ||t.B.w!=0.0f
       ||t.C.w!=0.0f) {
     shouldProduce = (indexof t).xy;
     push(shouldProduce);
   }else {
     shouldNotProduce = (indexof t).xy;
     push(shouldNotProduce);
   }
}


kernel void computeNeighbors(Tri tgather[][], Neighbor ugather[][], float2 i<>, out Neighbor v<>) {
  Neighbor u = ugather[i];
  Tri t = tgather[i];
  float3 AB_B=lerp(lerp(t.B.xyz,u.AB.xyz,.5),
                   lerp(t.A.xyz,u.ABB.xyz,.5),
                   .25);
  float3 AC_A=lerp(lerp(t.A.xyz,u.AC.xyz,.5),
                   lerp(t.C.xyz,u.AAC.xyz,.5),
                   .25);
  float3 BC_C=lerp(lerp(t.C.xyz,u.BC.xyz,.5),
                   lerp(t.B.xyz,u.BCC.xyz,.5),
                   .25);
  v.AB.xyz = lerp(lerp(t.A.xyz,u.AB.xyz,.5),
                  lerp(t.B.xyz,u.AAB.xyz,.5),
                  .25);
  v.AB.w = AB_B.x;
  v.BBC.xyz = lerp(lerp(t.B.xyz,u.BBC.xyz,.5),
                   lerp(u.ABB.xyz,u.BC.xyz,.5),
                   .25);
  v.BBC.w = AB_B.y;
  v.ABB.xyz = lerp(lerp(t.B.xyz,u.ABB.xyz,.5),
                   lerp(u.AB.xyz,u.BBC.xyz,.5),
                   .25);
  v.ABB.w = AB_B.z;

  v.AC.xyz = lerp(lerp(t.C.xyz,u.AC.xyz,.5),
                  lerp(t.A.xyz,u.ACC.xyz,.5),
                  .25);
  v.AC.w = AC_A.x;
  v.AAB.xyz = lerp(lerp(t.A.xyz,u.AAB.xyz,.5),
                   lerp(u.AAC.xyz,u.AB.xyz,.5),
                   .25);
  v.AAB.w = AC_A.y;
  v.AAC.xyz = lerp(lerp(t.A.xyz,u.AAC.xyz,.5),
                   lerp(u.AAB.xyz,u.AC.xyz,.5),
                   .25);
  v.AAC.w = AC_A.z;

  v.BC.xyz = lerp(lerp(t.B.xyz,u.BC.xyz,.5),
                  lerp(t.C.xyz,u.BBC.xyz,.5),
                  .25);
  v.BC.w = BC_C.x;
  v.ACC.xyz = lerp(lerp(t.C.xyz,u.ACC.xyz,.5),
                   lerp(u.AC.xyz,u.BCC.xyz,.5),
                   .25);
  v.ACC.w = BC_C.y;
  v.BCC.xyz = lerp(lerp(t.C.xyz,u.BCC.xyz,.5),
                   lerp(u.BC.xyz,u.ACC.xyz,.5),
                   .25);
  v.BCC.w = BC_C.z;  
}
kernel void writeFinalTriangles (Tri triangles[][],
                                 float2 indices<>,
                                 out float3 triList<>) {
  float whichVertex=round(fmod((indexof triList).x,3));
  Tri tri = triangles[indices];
  triList = tri.A.xyz;
  if (whichVertex>.5&&whichVertex<1.5)
    triList=tri.B.xyz;
  else if (whichVertex>=1.5&&whichVertex<2.5)
    triList=tri.C.xyz;
}
kernel float4 addN(float3 inxyz, float inw) {
   float4 x = float4(inxyz.x,
                     inxyz.y,
                     inxyz.z,
                     inw);
   return x;
} 
kernel float4 identity(float4 a, float b){return a;}
kernel void splitTriangles (Tri triangles[][], 
                            Neighbor neighbors[][],
                            float2 i<>,
                            Neighbor newnei<>,
                            out Tri triA<>,
                            out Tri triB<>,
                            out Tri triC<>,
                            out Tri triD<>,
                            out Neighbor neighborA<>,
                            out Neighbor neighborB<>,
                            out Neighbor neighborC<>,
                            out Neighbor neighborD<>) {
  Tri tri=triangles[i];
  Neighbor oldneighbors=neighbors[i];
  float4 ac = addN(lerp(lerp (tri.A.xyz,tri.C.xyz,.5),
                        lerp (tri.B.xyz,oldneighbors.AC.xyz,.5),
                        .25),
                   1);
  float4 ab = addN(lerp(lerp (tri.A.xyz,tri.B.xyz,.5),
                        lerp(tri.C.xyz,oldneighbors.AB.xyz,.5),
                        .25),
                   1);
  float4 bc = addN(lerp(lerp (tri.B.xyz,tri.C.xyz,.5),
                        lerp(tri.A.xyz,oldneighbors.BC.xyz,.5),
                        .25),
                   1);
  float4 a = addN(lerp(lerp(lerp(lerp(oldneighbors.AB.xyz,oldneighbors.AC.xyz,.5),
                                 lerp(tri.B.xyz,tri.C.xyz,.5),
                                 .5),
                            lerp(oldneighbors.AAB.xyz,oldneighbors.AAC.xyz,.5),
                            .33),
                       tri.A.xyz,
                       .625),
                  1);
  float4 b = addN(lerp(lerp(lerp(lerp(oldneighbors.AB.xyz,oldneighbors.BC.xyz,.5),
                                 lerp(tri.A.xyz,tri.C.xyz,.5),
                                 .5),
                            lerp(oldneighbors.ABB.xyz,oldneighbors.BBC.xyz,.5),
                            .33),
                       tri.B.xyz,
                       .625),
                  1);
  float4 c = addN(lerp(lerp(lerp(lerp(oldneighbors.AC.xyz,
                                      oldneighbors.BC.xyz,
                                      .5),
                                 lerp(tri.A.xyz,
                                      tri.B.xyz,
                                      .5),
                                 .5),
                            lerp(oldneighbors.ACC.xyz,oldneighbors.BCC.xyz,.5),
                            .33),
                       tri.C.xyz,
                       .625),
                  1);
  float4 BC_C= {newnei.BC.w,
                newnei.ACC.w,
                newnei.BCC.w,1};
  float4 AC_A = {newnei.AC.w,
                 newnei.AAB.w,
                 newnei.AAC.w,1};
  float4 AB_B = {newnei.AB.w,
                 newnei.BBC.w,
                 newnei.ABB.w,1};
  triA.A=identity(a,1);
  triA.B=identity(ab,1);
  triA.C=identity(ac,1);
  triB.A= identity(ab,1);
  triB.B=identity(b,1);
  triB.C=identity(bc,1);
  triC.A=identity(ac,1);
  triC.B=identity(ab,1);
  triC.C=identity(c,1);
  triD.A=identity(bc,1);
  triD.B=identity(ac,1);
  triD.C=identity(ab,1);

  neighborC.BCC=newnei.BCC;
  neighborC.BC=BC_C;
  neighborC.BBC = newnei.BC;
  neighborC.ABB = b;
  neighborC.AB = ab;
  neighborC.AAB = a;
  neighborC.AAC = AC_A;
  neighborC.AC = newnei.AC;
  neighborC.ACC = newnei.ACC;
  
  neighborB.BCC = BC_C;
  neighborB.BC = newnei.BC;
  neighborB.BBC=newnei.BBC;
  neighborB.ABB=newnei.ABB;
  neighborB.AB = AB_B;
  neighborB.AAB = newnei.AB;
  neighborB.AAC = a;
  neighborB.AC = ac;
  neighborB.ACC = c;

  neighborA.BCC = c;
  neighborA.BC = bc;
  neighborA.BBC= b;
  neighborA.ABB= AB_B;
  neighborA.AB = newnei.AB;
  neighborA.AAB =  newnei.AAB;
  neighborA.AAC =  newnei.AAC;
  neighborA.AC = AC_A;
  neighborA.ACC = newnei.AC;

  neighborD.BCC = newnei.AB;
  neighborD.BC = a;
  neighborD.BBC= AC_A;
  neighborD.ABB= newnei.AC;
  neighborD.AB = c;
  neighborD.AAB = BC_C;
  neighborD.AAC = newnei.BC;
  neighborD.AC = b;
  neighborD.ACC = AB_B;

}
int main () {
   return 0;
}



