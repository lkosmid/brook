typedef struct Tri_t{
   float4 A;
   float4 B;
   float4 C;
} Tri;
typedef struct SplitTri_t {
  float4 A;
  float4 AB;
  float4 B;
  float4 BC;
  float4 C;
  float4 AC;
}SplitTri;
//Stores the neighbors of a given triangle
// the unused 'w' components act as holders
// for the recomputed neighbor list when a triangle is split
typedef struct Neighbor_t {
  float4 AB;// w = AB->B.x
  float4 BBC;// w = AB->B.y
  float4 ABB;// w = AB->B.z
  float4 BC;// w = BC->C.x
  float4 ACC;// w = BC->C.y
  float4 BCC;// w = BC->C.z
  float4 AC;// w = AC->A.x
  float4 AAB;// w = AC->A.y
  float4 AAC;// w = AC->A.z
}Neighbor;

/** OBSOLETE
kernel float triCombine (float myin<>, 
                         float b1<>, 
                         float b2<>) {
   float ret=0;
   if (myin == 2.0f) ret= (b1?2.0f:0);
   if (myin == 4.0f) ret= (b2?4.0f:0);
   if (myin == 8.0f) ret= ((b1&&b2)?8.0f:(b1?2.0f:(b2?4.0f:0)));
   return ret;
}
*/
kernel float triCombine(float b1<>, float b2<>) {
   return (b1&&b2)?8:(b1?2:(b2?4:0));
}
// from a triangle and its neighbors, determines 
kernel void smallEnough(Tri t<>, Neighbor u<>, 
                        out Tri v<>, 
                        out Neighbor n<>, 
                        float epsilon) {
  v.A.xyz = t.A.xyz;
  v.A.w = (float)(//t.A.w!=0 &&
                  dot(t.A.xyz-t.B.xyz,t.A.xyz-t.B.xyz)>epsilon);
  v.B.xyz = t.B.xyz;
  v.B.w = (float)(//t.B.w!=0 &&
                  (dot(t.B.xyz-t.C.xyz,t.B.xyz-t.C.xyz)>epsilon));
  v.C.xyz = t.C.xyz;
  v.C.w = (float)(//t.C.w!=0 &&
                  (dot(t.A.xyz-t.C.xyz,t.A.xyz-t.C.xyz)>epsilon));
  n.AB.xyz = u.AB.xyz;
  n.AB.w = triCombine(//u.AB.w,
                      (float)(dot(t.A.xyz-u.AB.xyz,t.A.xyz-u.AB.xyz)>epsilon),
                      (float)(dot(t.B.xyz-u.AB.xyz,t.B.xyz-u.AB.xyz)>epsilon));
  n.BC.xyz=u.BC.xyz;
  n.BC.w = triCombine(//u.BC.w,
                      (float)(dot(t.B.xyz-u.BC.xyz,t.B.xyz-u.BC.xyz)>epsilon),
                      (float)(dot(t.C.xyz-u.BC.xyz,t.C.xyz-u.BC.xyz)>epsilon));
  n.AC.xyz=u.AC.xyz;
  n.AC.w = triCombine(//u.AC.w,
                      (float)(dot(t.C.xyz-u.AC.xyz,t.C.xyz-u.AC.xyz)>epsilon),
                      (float)(dot(t.A.xyz-u.AC.xyz,t.A.xyz-u.AC.xyz)>epsilon));
  n.AAC.xyz=u.AAC.xyz;
  n.AAC.w = (float)(//u.AAC.w!=0&&
                    dot(t.A.xyz-u.AAC.xyz,t.A.xyz-u.AAC.xyz)>epsilon);
  n.AAB.xyz=u.AAB.xyz;
  n.AAB.w = (float)(//u.AAB.w!=0&&
                    dot(t.A.xyz-u.AAB.xyz,t.A.xyz-u.AAB.xyz)>epsilon);
  n.ABB.xyz=u.ABB.xyz;
  n.ABB.w = (float)(//u.ABB.w!=0&&
                    dot(t.B.xyz-u.ABB.xyz,t.B.xyz-u.ABB.xyz)>epsilon);
  n.BBC.xyz=u.BBC.xyz;
  n.BBC.w = (float)(//u.BBC.w!=0&&
                    dot(t.B.xyz-u.BBC.xyz,t.B.xyz-u.BBC.xyz)>epsilon);
  n.BCC.xyz=u.BCC.xyz;
  n.BCC.w = (float)(//u.BCC.w!=0&&
                    dot(t.C.xyz-u.BCC.xyz,t.C.xyz-u.BCC.xyz)>epsilon);
  n.ACC.xyz=u.ACC.xyz;
  n.ACC.w = (float)(//u.ACC.w!=0&&
                    dot(t.C.xyz-u.ACC.xyz,t.C.xyz-u.ACC.xyz)>epsilon);
}
kernel void produceTriP(Tri t<>, vout [1]float2 shouldProduce<>, vout[1] float2 shouldNotProduce<>){
   if (t.A.w!=0.0f
       ||t.B.w!=0.0f
       ||t.C.w!=0.0f) {
     shouldProduce = (indexof t).xy;
     push(shouldProduce);
   }else {
     shouldNotProduce = (indexof t).xy;
     push(shouldNotProduce);
   }
}


kernel void computeNeighbors(Tri tgather[][], Neighbor ugather[][], float2 i<>, out Neighbor v<>) {
  Neighbor u = ugather[i];
  Tri t = tgather[i];
  float3 AB_B, AC_A, BC_C;
  AB_B=lerp(t.B.xyz,u.AB.xyz,.5);
  if (u.AB.w==4||u.AB.w==8)
     AB_B=lerp(AB_B,
               lerp(t.A.xyz,u.ABB.xyz,.5),
               .25);
  AC_A=lerp(t.A.xyz,u.AC.xyz,.5);
  if (u.AC.w==4||u.AC.w==8)
     AC_A=lerp(AC_A,
               lerp(t.C.xyz,u.AAC.xyz,.5),
               .25);
  BC_C=lerp(t.C.xyz,u.BC.xyz,.5);
  if (u.BC.w==4||u.AC.w==8)
     BC_C=lerp(BC_C,
               lerp(t.B.xyz,u.BCC.xyz,.5),
               .25);
  v.AB.xyz = lerp(t.A.xyz,u.AB.xyz,.5);
  if (u.AB.w==2||u.AB.w==8)
     v.AB.xyz = lerp(v.AB.xyz,
                     lerp(t.B.xyz,u.AAB.xyz,.5),
                     .25);
  v.AB.w = AB_B.x;
  v.BBC.xyz = lerp(t.B.xyz,u.BBC.xyz,.5);
  if (u.BBC.w)
     v.BBC.xyz = lerp(v.BBC.xyz,
                      lerp(u.ABB.xyz,u.BC.xyz,.5),
                      .25);
  v.BBC.w = AB_B.y;
  v.ABB.xyz = lerp(t.B.xyz,u.ABB.xyz,.5);
  if (u.ABB.w)
     v.ABB.xyz = lerp(v.ABB.xyz,
                      lerp(u.AB.xyz,u.BBC.xyz,.5),
                      .25);
  v.ABB.w = AB_B.z;
  v.AC.xyz = lerp(t.C.xyz,u.AC.xyz,.5);
  if (u.AC.w==2||u.AC.w==8)
     v.AC.xyz = lerp(v.AC.xyz,
                     lerp(t.A.xyz,u.ACC.xyz,.5),
                     .25);
  v.AC.w = AC_A.x;
  v.AAB.xyz = lerp(t.A.xyz,u.AAB.xyz,.5);
  if (u.AAB.w)
     v.AAB.xyz = lerp(v.AAB.xyz,
                      lerp(u.AAC.xyz,u.AB.xyz,.5),
                      .25);
  v.AAB.w = AC_A.y;
  v.AAC.xyz = lerp(t.A.xyz,u.AAC.xyz,.5);
  if (u.AAC.w)
     v.AAC.xyz = lerp(v.AAC.xyz,
                      lerp(u.AAB.xyz,u.AC.xyz,.5),
                      .25);
  v.AAC.w = AC_A.z;
  v.BC.xyz = lerp(t.B.xyz,u.BC.xyz,.5);
  if (u.BC.w==2||u.BC.w==8)
     v.BC.xyz = lerp(v.BC.xyz,
                     lerp(t.C.xyz,u.BBC.xyz,.5),
                     .25);
  v.BC.w = BC_C.x;
  v.ACC.xyz = lerp(t.C.xyz,u.ACC.xyz,.5);
  if (u.ACC.w)
     v.ACC.xyz = lerp(v.ACC.xyz,
                      lerp(u.AC.xyz,u.BCC.xyz,.5),
                      .25);
  v.ACC.w = BC_C.y;
  v.BCC.xyz = lerp(t.C.xyz,u.BCC.xyz,.5);
  if (u.BCC.w)
     v.BCC.xyz = lerp(v.BCC.xyz,
                      lerp(u.BC.xyz,u.ACC.xyz,.5),
                      .25);
  v.BCC.w = BC_C.z;  
}
kernel void writeFinalTriangles (Tri triangles[][],
                                 float2 indices<>,
                                 out float3 triList<>) {
  float whichVertex=round(fmod((indexof triList).x,3));
  Tri tri = triangles[indices];
  triList = tri.A.xyz;
  if (whichVertex>.5&&whichVertex<1.5)
    triList=tri.B.xyz;
  else if (whichVertex>=1.5&&whichVertex<2.5)
    triList=tri.C.xyz;
}
kernel float4 addN(float3 inxyz, float inw) {
   float4 x = float4(inxyz.x,
                     inxyz.y,
                     inxyz.z,
                     inw);
   return x;
} 
kernel float4 identity(float4 a, float b){return a;}
kernel float3 ident3(float3 a, float b) {return a;}
kernel void splitTriangles (Tri triangles[][], 
                            Neighbor neighbors[][],
                            float2 i<>,
                            out SplitTri splittri<>) {
  Tri tri=triangles[i];
  Neighbor oldneighbors=neighbors[i];
  splittri.AC = lerp (tri.A,tri.C,.5);
  if (tri.C.w)
    splittri.AC = addN(lerp(splittri.AC.xyz,
                            lerp (tri.B.xyz,oldneighbors.AC.xyz,.5),
                            .25),
                       1);
  splittri.AB = lerp (tri.A,tri.B,.5);
  if (tri.A.w)
    splittri.AB = addN(lerp(splittri.AB.xyz,
                                lerp(tri.C.xyz,oldneighbors.AB.xyz,.5),
                                .25),
                           1);
  splittri.BC = lerp (tri.B,tri.C,.5);
  if (tri.B.w)
    splittri.BC = addN(lerp(splittri.BC.xyz,
                                lerp(tri.A.xyz,oldneighbors.BC.xyz,.5),
                                .25),
                           1);
  splittri.A = tri.A;
  if (tri.A.w&&
      tri.C.w&&
      (oldneighbors.AC.w==4||oldneighbors.AC.w==8)&&
      (oldneighbors.AB.w==2||oldneighbors.AB.w==8)&&
      oldneighbors.AAB.w&&
      oldneighbors.AAC.w)       
    splittri.A.xyz = ident3(lerp(lerp(lerp(lerp(oldneighbors.AB.xyz,
                                              oldneighbors.AC.xyz,
                                              .5),
                                         lerp(tri.B.xyz,tri.C.xyz,.5),
                                         .5),
                                    lerp(oldneighbors.AAB.xyz,
                                         oldneighbors.AAC.xyz,
                                         .5),
                                    .33),
                               tri.A.xyz,
                               .625),
                          1);
  splittri.B = tri.B;
  if (tri.A.w&&
      tri.B.w&&
      (oldneighbors.BC.w==2||oldneighbors.BC.w==8)&&
      (oldneighbors.AB.w==4||oldneighbors.AB.w==8)&&
      oldneighbors.ABB.w&&
      oldneighbors.BBC.w)        
    splittri.B.xyz=ident3(lerp(lerp(lerp(lerp(oldneighbors.AB.xyz,
                                          oldneighbors.BC.xyz,
                                          .5),
                                     lerp(tri.A.xyz,tri.C.xyz,.5),
                                     .5),
                                lerp(oldneighbors.ABB.xyz,
                                     oldneighbors.BBC.xyz,
                                     .5),
                                .33),
                           tri.B.xyz,
                           .625),
                      1);
  splittri.C = tri.C;
  if (tri.C.w&&
      tri.B.w&&
      (oldneighbors.BC.w==4||oldneighbors.BC.w==8)&&
      (oldneighbors.AC.w==2||oldneighbors.AC.w==8)&&
      oldneighbors.ACC.w&&
      oldneighbors.BCC.w)       
    splittri.C.xyz=ident3(lerp(lerp(lerp(lerp(oldneighbors.AC.xyz,
                                           oldneighbors.BC.xyz,
                                           .5),
                                      lerp(tri.A.xyz,
                                           tri.B.xyz,
                                           .5),
                                      .5),
                                 lerp(oldneighbors.ACC.xyz,
                                      oldneighbors.BCC.xyz,
                                      .5),
                                 .33),
                            tri.C.xyz,
                            .625),
                       1);
}


/* obsolete

kernel void reorgSplitTriangles (SplitTri splittri<>,
                                 Neighbor newnei<>,
                                 out Tri triA<>,
                                 out Tri triB<>,
                                 out Tri triC<>,
                                 out Tri triD<>,
                                 out Neighbor neighborA<>,
                                 out Neighbor neighborB<>,
                                 out Neighbor neighborC<>,
                                 out Neighbor neighborD<>,
                                 float epsilon) {
  float4 ac = splittri.AC;
  float4 ab = splittri.AB;
  float4 bc = splittri.BC;
  float4 a = splittri.A;
  float4 b = splittri.B;
  float4 c = splittri.C;
  float4 BC_C= {newnei.BC.w,
                newnei.ACC.w,
                newnei.BCC.w,1};
  float4 AC_A = {newnei.AC.w,
                 newnei.AAB.w,
                 newnei.AAC.w,1};
  float4 AB_B = {newnei.AB.w,
                 newnei.BBC.w,
                 newnei.ABB.w,1};
  triA.A=identity(a,1);
  triA.B=identity(ab,1);
  triA.C=identity(ac,1);
  triB.A= identity(ab,1);
  triB.B=identity(b,1);
  triB.C=identity(bc,1);
  triC.A=identity(ac,1);
  triC.B=identity(ab,1);
  triC.C=identity(c,1);
  triD.A=identity(bc,1);
  triD.B=identity(ac,1);
  triD.C=identity(ab,1);

  neighborC.BCC=newnei.BCC;
  neighborC.BC=BC_C;
  neighborC.BBC = newnei.BC;
  neighborC.ABB = b;
  neighborC.AB = ab;
  neighborC.AAB = a;
  neighborC.AAC = AC_A;
  neighborC.AC = newnei.AC;
  neighborC.ACC = newnei.ACC;
  
  neighborB.BCC = BC_C;
  neighborB.BC = newnei.BC;
  neighborB.BBC=newnei.BBC;
  neighborB.ABB=newnei.ABB;
  neighborB.AB = AB_B;
  neighborB.AAB = newnei.AB;
  neighborB.AAC = a;
  neighborB.AC = ac;
  neighborB.ACC = c;

  neighborA.BCC = c;
  neighborA.BC = bc;
  neighborA.BBC= b;
  neighborA.ABB= AB_B;
  neighborA.AB = newnei.AB;
  neighborA.AAB =  newnei.AAB;
  neighborA.AAC =  newnei.AAC;
  neighborA.AC = AC_A;
  neighborA.ACC = newnei.AC;

  neighborD.BCC = newnei.AB;
  neighborD.BC = a;
  neighborD.BBC= AC_A;
  neighborD.ABB= newnei.AC;
  neighborD.AB = c;
  neighborD.AAB = BC_C;
  neighborD.AAC = newnei.BC;
  neighborD.AC = b;
  neighborD.ACC = AB_B;
  smallEnough(triA,neighborA,triA,neighborA,epsilon);
  smallEnough(triB,neighborB,triB,neighborB,epsilon);
  smallEnough(triC,neighborC,triC,neighborC,epsilon);
  smallEnough(triD,neighborD,triD,neighborD,epsilon);
}
*/

kernel void linearReorgSplitTriangles (SplitTri splittri<>,
                                       Neighbor newnei<>,
                                       out Tri tri<>,
                                       out Neighbor neighbor<>,
                                       float epsilon) {
  float unclampedwhich = round(fmod((indexof tri).x,4));
  float which = unclampedwhich>3.5?0:unclampedwhich;
  float4 ac = splittri.AC;
  float4 ab = splittri.AB;
  float4 bc = splittri.BC;
  float4 a = splittri.A;
  float4 b = splittri.B;
  float4 c = splittri.C;
  float4 BC_C= {newnei.BC.w,
                newnei.ACC.w,
                newnei.BCC.w,1};
  float4 AC_A = {newnei.AC.w,
                 newnei.AAB.w,
                 newnei.AAC.w,1};
  float4 AB_B = {newnei.AB.w,
                 newnei.BBC.w,
                 newnei.ABB.w,1};
  if (which<.5) {
    tri.A=identity(a,1);
    tri.B=identity(ab,1);
    tri.C=identity(ac,1);

    neighbor.BCC = c;
    neighbor.BC = bc;
    neighbor.BBC= b;
    neighbor.ABB= AB_B;
    neighbor.AB = newnei.AB;
    neighbor.AAB =  newnei.AAB;
    neighbor.AAC =  newnei.AAC;
    neighbor.AC = AC_A;
    neighbor.ACC = newnei.AC;
  }else if (which <1.5) {
    tri.A= identity(ab,1);
    tri.B=identity(b,1);
    tri.C=identity(bc,1);

    neighbor.BCC = BC_C;
    neighbor.BC = newnei.BC;
    neighbor.BBC=newnei.BBC;
    neighbor.ABB=newnei.ABB;
    neighbor.AB = AB_B;
    neighbor.AAB = newnei.AB;
    neighbor.AAC = a;
    neighbor.AC = ac;
    neighbor.ACC = c;
  }else if (which<2.5) {
    
    tri.A=identity(ac,1);
    tri.B=identity(ab,1);
    tri.C=identity(c,1);

    neighbor.BCC=newnei.BCC;
    neighbor.BC=BC_C;
    neighbor.BBC = newnei.BC;
    neighbor.ABB = b;
    neighbor.AB = ab;
    neighbor.AAB = a;
    neighbor.AAC = AC_A;
    neighbor.AC = newnei.AC;
    neighbor.ACC = newnei.ACC;
  }else {
    tri.A=identity(bc,1);
    tri.B=identity(ac,1);
    tri.C=identity(ab,1);

    neighbor.BCC = newnei.AB;
    neighbor.BC = a;
    neighbor.BBC= AC_A;
    neighbor.ABB= newnei.AC;
    neighbor.AB = c;
    neighbor.AAB = BC_C;
    neighbor.AAC = newnei.BC;
    neighbor.AC = b;
    neighbor.ACC = AB_B;
  }
  smallEnough(tri,neighbor,tri,neighbor,epsilon);
}

struct VertexArray{
  float3 * v;
  unsigned int size;
  unsigned int alloc;
};
void initVertexArray(struct VertexArray *v) {
  v->v=0;v->size=0;v->alloc=0;
}
void destroyVertexArray(struct VertexArray *v) {
  if (v->v) free(v->v);
}
void expandVertexArray(struct VertexArray * v,
                       unsigned int more) {
  v->size+=more;
  while(v->size>v->alloc) {
    v->alloc*=2;
    v->v = (float3*)realloc(v->v,v->alloc*sizeof(float3));
  }
}                   
void pushBackVertexArray(struct VertexArray * v,
                         float3 f) {
  if (++v->size>v->alloc) {
    v->alloc*=2;
    v->v = (float3*)realloc(v->v,v->alloc*sizeof(float3));
  }
  v->v[v->size-1]=f;
}                   
int toi(float f) {return (int)f;}
void subdivide (Neighbor (*neighbors)<>,
                Tri (*triangles)<>,
                struct VertexArray *output,
                float epsilon) {
  {
    float2 shouldProduce<2048,0>;
    float2 shouldNotProduce<2048,0>;
    produceTriP(*triangles,shouldProduce,shouldNotProduce);
    {
      int sizeDivide=toi(streamSize(shouldProduce).x);
      {
        Neighbor sharedNeighbors<2048,sizeDivide>;
        Neighbor newNeighbors<2048,(sizeDivide*4)>;
        SplitTri sharedTriangles <2048,sizeDivide>;
        Tri newTriangles<2048,(sizeDivide*4)>;
        computeNeighbors(*neighbors,*triangles,shouldProduce,sharedNeighbors);
        splitTriangles(*triangles,*neighbors,shouldProduce,sharedTriangles);
        linearReorgSplitTriangles(sharedTriangles,
                                  sharedNeighbors,
                                  newTriangles,
                                  newNeighbors,
                                  epsilon);
        streamSwap(*triangles,newTriangles);
        streamSwap(*neighbors,newNeighbors);
      }
      {
        int sizey=3*toi(streamSize(shouldNotProduce).x);
        float3 outputTri<2048,sizey>;

        writeFinalTriangles(*triangles,shouldNotProduce,outputTri);      
        if (streamSize(shouldProduce).x) {
          subdivide(neighbors,triangles,output,epsilon);
        } 
        sizey = output->size;
        expandVertexArray(output,(unsigned int)(streamSize(outputTri).x*
                                                streamSize(outputTri).y));
        streamWrite(outputTri,output->v+sizey);   
      }       
    }
  }
  /*
    if (streamSize(triangles).y)
      subdivide(neighbors,triangles,output,epsilon); // subdivide here if your card runs out of ram
  */
  // prevents all writing at the end
}
               
int main () {
  float epsilon=.01;
  Neighbor neighbors<2048,1>;
  Tri triangles<2048,1>;
  struct VertexArray v;
  initVertexArray(&v);
  // initialize neighbors and triangles
  smallEnough(triangles,neighbors,triangles,neighbors,epsilon);
  subdivide(&neighbors,&triangles,&v,epsilon);
  

   return 0;
}



