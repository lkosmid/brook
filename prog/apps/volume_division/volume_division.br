#include <stdio.h>
#include <stdlib.h>
#include "ppm3d.h"
kernel float test(float vol<>,float index<>){
  return (vol>0)?index:0;
}

float __printf_cpu_inner (float a, float b, float c, float d) {
  printf ("%f %f -> %f %f\n",a,b,c,d);
  return 1;
}
kernel float eval (float3 loc<>) {  
  float  power;
  const float3 offset=20;
  const float length=20;
  float3 center =loc-offset;
  power = dot(center,center);
  /*
  center.x +=length;
  power += dot(center,center);
  center.y+=length;
  power += dot(center,center);
  center.x-= length;
  power +=  dot(center,center);
  center.z+= length;
  power += dot(center,center);
  
  center.y-=length;
  power += dot(center,center);
  
  center.x+=length;                  
  power += dot(center,center);
  center.y+=length;
  power += dot(center,center);
  */
  {

    const float  density = 64;
    //printf (power,loc.z,density,power-density);
    return density-power;
  }
}
kernel float3 combineIndex (float a,float b, float c) {
  float3 ret={a,b,c};
  return ret;
}

kernel float evaluateNeighbors (float2 center<>,
                                float2 opposing<>,
                                float2 slice) {

   float a=test(eval(float3(center.x,center.y,slice.x)),2.0f) +
      test(eval(float3(center.x,opposing.y,slice.x)),4.0f) +
      test(eval(float3(opposing.x,opposing.y,slice.x)),8.0f) +
      test(eval(float3(opposing.x,center.y,slice.x)),16.0f) +
      test(eval(float3(center.x,center.y,slice.y)),32.0f) +
      test(eval(float3(center.x,opposing.y,slice.y)),64.0f) +
      test(eval(float3(opposing.x,opposing.y,slice.y)),128.0f) +
      test(eval(float3(opposing.x,center.y,slice.y)),256.0f);
   return a>1&&a<(1.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+256.0f)?a:0;
    
}
kernel void processSlice (float curgather[][],
                          float nextslice[][],
                          vout [1]float4 vertex<>,
                          iter float2 center<>,
                          iter float2 up<>,
                          iter float2 forward<>,
                          iter float2 upforward<>,
                          float2 slice) {
  float a=
    test(curgather[center],2.0f)+
    test(curgather[up],4.0f)+
    test(curgather[upforward],8.0f)+
    test(curgather[forward],16.0f)+
    test(nextslice[center],32.0f)+
    test(nextslice[up],64.0f)+
    test(nextslice[upforward],128.0f)+
    test(nextslice[forward],256.0);
  if (a>1&&a<(1.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+256.0f)) {
    vertex=float4(center.x,center.y,slice.x,a);
    push(vertex);
  }
}
kernel void processSliceNoCompact (float curgather[][],
                                   float nextslice[][],
                                   out float4 vertex<>,
                                   iter float2 center<>,
                                   iter float2 up<>,
                                   iter float2 forward<>,
                                   iter float2 upforward<>,
                                   float2 slice) {
  float a=
    test(curgather[center],2.0f)+
    test(curgather[up],4.0f)+
    test(curgather[upforward],8.0f)+
    test(curgather[forward],16.0f)+
    test(nextslice[center],32.0f)+
    test(nextslice[up],64.0f)+
    test(nextslice[upforward],128.0f)+
    test(nextslice[forward],256.0);
  if (a>1&&a<(1.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+256.0f)) {
    vertex=float4(center.x,center.y,slice.x,a);
  }else {
    vertex=float4(-1,-1,-1,-1);
  }
  
}
                           
kernel void processVirtualSlice(vout[1] float4 vertex<>,
                                iter float2 center<>,
                                iter float2 opposing<>,
                                float2 slice/*first value is cur then next*/) {
  float pattern;
  if((pattern=evaluateNeighbors(center,opposing,slice))) {
    vertex=float4(center.x,center.y,slice.x,pattern);
    push(vertex);
  }
}
kernel void processVirtualSliceNoCompact(out float4 vertex<>,
                                         iter float2 center<>,
                                         iter float2 opposing<>,
                                         float2 slice/*first value is cur then next*/) {
  float pattern;
  if((pattern=evaluateNeighbors(center,opposing,slice))) {
    vertex=float4(center.x,center.y,slice.x,pattern);
  }else {
    vertex=float4(-1.0,-1.0f,-1.0f,-1.0f);
  }
}
float tof (int a) {
  return (float)a;
}
 int main (int argc, char ** argv) {
   if (argc<2) {
      printf ("Usage: volume_division <FILE.pnm>\n      volume_divison <width>\n");
      exit (1);
   }
   if (argc==2)
   {
     
      struct ppm dat;
      float * slice;
      
      if (atoi(argv[1])==0) {
         dat = openPPM (argv[1]);
         if (!dat.fp)
            exit(1);
      }else {
         dat = randomPPM(atoi(argv[1]),atoi(argv[1]),atoi(argv[1]));
      }
      slice = mallocSlice(dat);
      {
         unsigned int i;
         float2 sliceZ;
         float cur<(dat.height),(dat.width)>;
         float next<(dat.height),(dat.width)>;
         float4 v<1,(dat.width)>;
         iter float2 center <(dat.height),(dat.width)> 
           = iter (float2(0.0f,0.0f),
                   float2(tof(dat.width),
                          tof(dat.height)));
         iter float2 up <(dat.height),(dat.width)> 
           = iter (float2(0.0f,1.0f),
                   float2(0.0f+tof(dat.width),
                          1.0f+tof(dat.height)));
         iter float2 upforward <(dat.height),(dat.width)> 
           = iter (float2(1.0f,1.0f),
                   float2(1.0f+tof(dat.width),
                          1.0f+tof(dat.height)));
         iter float2 forward <(dat.height),(dat.width)> 
           = iter (float2(1.0f,0.0f),
                   float2(1.0f+tof(dat.width),
                          tof(dat.height)));
                                                         
         readPPM3dSlice(dat,0,slice);
         streamRead(cur,slice);

         sliceZ.x=sliceZ.y=0.0f;
         for (i=0;i<dat.depth-1;++i) {
            readPPM3dSlice(dat,i+1,slice);
            streamSwap(cur,next);
            streamRead(next,slice);
            processSlice(cur,next,v,center,up,upforward,forward,sliceZ);
            streamWrite(v,consolidateVertices(dat,streamSize(v)));
            sliceZ.x++;sliceZ.y++;
         }
         processSlice(next,next,v,center,up,upforward,forward,sliceZ);
         streamWrite(v,consolidateVertices(dat,streamSize(v)));         
      }
      free(slice);
      printVolume(dat);
   }else {
     int width=atoi (argv[1]);
     int depth=atoi (argv[2]);
     int i,height;
     if (argc>3)
       height=atoi (argv[3]);
     else
       height=width;
     {
       float4 v<height,width>;
       struct ppm dat = randomPPM(width,height,depth);

       iter float2 current<height,width> = iter(float2(0.0f,0.0f),
                                                float2(tof(width),
                                                       tof(height)));
       iter float2 corner<height,width> = iter(float2(1.0f,1.0f),
                                               float2(tof(1+width),
                                                      tof(1+height)));
       for (i=0;i<depth;++i) {
         processVirtualSlice(v,current,corner,float2(tof(i),tof(i+1)));
         streamWrite(v,consolidateVertices(dat,streamSize(v)));
       }
       printVolume(dat);
     }

   }
   return 0;
 }
