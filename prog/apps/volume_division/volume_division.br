#include <stdio.h>
#include <stdlib.h>
#include "ppm3d.h"
#include "volume_division.h"
char use_vout_filter=1;
char use_vout_amplify=1;
kernel float test(float vol<>,float index<>){
  return (vol>0)?index:0;
}

float __printf_cpu_inner (float a, float b, float c, float d) {
  printf ("%f %f -> %f %f\n",a,b,c,d);
  return 1;
}
kernel float eval (float3 loc<>) {
   return (float) (loc.x==loc.y&&loc.y==loc.z&&loc.z==1);
}
kernel float eval2 (float3 loc<>) {
  float  power;
  const float3 offset=8;
  float3 center =loc-offset;
  power = dot(center,center);
  /*
  {
  const float length=20;
  center.x +=length;
  power += dot(center,center);
  center.y+=length;
  power += dot(center,center);
  center.x-= length;
  power +=  dot(center,center);
  center.z+= length;
  power += dot(center,center);
  
  center.y-=length;
  power += dot(center,center);
  
  center.x+=length;                  
  power += dot(center,center);
  center.y+=length;
  power += dot(center,center);
  }
  */
  {

     const float  density =8*8;
    //printf (power,loc.z,density,power-density);
    return density-power;
  }
}
kernel float evaluateNeighbors (float2 center<>,
                                float2 opposing<>,
                                float2 slice) {

   float a=test(eval(float3(center.x,center.y,slice.x)),1.0f) +
      test(eval(float3(center.x,opposing.y,slice.x)),2.0f) +
      test(eval(float3(opposing.x,opposing.y,slice.x)),4.0f) +
      test(eval(float3(opposing.x,center.y,slice.x)),8.0f) +
      test(eval(float3(center.x,center.y,slice.y)),16.0f) +
      test(eval(float3(center.x,opposing.y,slice.y)),32.0f) +
      test(eval(float3(opposing.x,opposing.y,slice.y)),64.0f) +
      test(eval(float3(opposing.x,center.y,slice.y)),128.0f);
   return a>0.5f&&a<(2.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+0.5f)?a:0;
    
}
kernel void processSlice (float curgather[][],
                          float nextslice[][],
                          vout [1]float4 vertex<>,
                          iter float2 center<>,
                          iter float2 up<>,
                          iter float2 forward<>,
                          iter float2 upforward<>,
                          float2 slice) {
  float a=
    test(curgather[center],1.0f)+
    test(curgather[up],2.0f)+
    test(curgather[upforward],4.0f)+
    test(curgather[forward],8.0f)+
    test(nextslice[center],16.0f)+
    test(nextslice[up],32.0f)+
    test(nextslice[upforward],64.0f)+
    test(nextslice[forward],128.0);
  if (a>0.5f&&a<(2.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+0.5f)) {
    vertex=float4(center.x,center.y,slice.x,a);
    push(vertex);
  }
}
kernel void processSliceNoCompact (float curgather[][],
                                   float nextslice[][],
                                   out float4 vertex<>,
                                   iter float2 center<>,
                                   iter float2 up<>,
                                   iter float2 forward<>,
                                   iter float2 upforward<>,
                                   float2 slice) {
  float a=
    test(curgather[center],1.0f)+
    test(curgather[up],2.0f)+
    test(curgather[upforward],4.0f)+
    test(curgather[forward],8.0f)+
    test(nextslice[center],16.0f)+
    test(nextslice[up],32.0f)+
    test(nextslice[upforward],64.0f)+
    test(nextslice[forward],128.0);
  if (a>0.5f&&a<(2.0f+4.0f+8.0f+16.0f+32.0f+64.0f+128.0f+0.5f)) {
    vertex=float4(center.x,center.y,slice.x,a);
  }else {
    vertex=float4(-1,-1,-1,-1);
  }
  
}
                           
kernel void processVirtualSlice(vout[1] float4 vertex<>,
                                iter float2 center<>,
                                iter float2 opposing<>,
                                float2 slice/*first value is cur then next*/) {
  float pattern;
  if((pattern=evaluateNeighbors(center,opposing,slice))) {
    vertex=float4(center.x,center.y,slice.x,pattern);
    push(vertex);
  }
}
kernel void processVirtualSliceNoCompact(out float4 vertex<>,
                                         iter float2 center<>,
                                         iter float2 opposing<>,
                                         float2 slice/*first value is cur then next*/) {
  float pattern;
  if((pattern=evaluateNeighbors(center,opposing,slice))) {
    vertex=float4(center.x,center.y,slice.x,pattern);
  }else {
    vertex=float4(-1.0,-1.0f,-1.0f,-1.0f);
  }
}

kernel void processTrianglesNoCompact(out float3 trianglesA<>, 
                                      out float3 trianglesB<>, 
                                      out float3 trianglesC<>,
                                      out float3 trianglesD<>, 
                                      out float3 trianglesE<>, 
                                      float4 vertices1<>,
                                      float3 volumeTriangles[][]) {
   float4 whichVolumeTriangle={fmod((indexof trianglesA).x,3),vertices1.w,0,0};
   float3 vertices=vertices1.xyz;
  //whichVolumeTriangle.x*=(float)(whichVolumeTriangle.x+.5<3);
  if (whichVolumeTriangle.x+.5>3) whichVolumeTriangle.x=0;
  trianglesA=vertices.xyz+volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.x+=3;
  trianglesB=vertices.xyz+volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.x+=3;
  trianglesC=vertices.xyz+volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.x+=3;  
  trianglesD=vertices.xyz+volumeTriangles[whichVolumeTriangle];  
  whichVolumeTriangle.x+=3;  
  trianglesE=vertices.xyz+volumeTriangles[whichVolumeTriangle];  
}

kernel void processTriangles(vout[3] float3 triangles<>, 
                             float4 vertices<>,
                             float3 volumeTriangles[][],
                             iter float2 streamsize<>) {

  float4 whichVolumeTriangle={fmod(streamsize.x,5.0f)*3.0f,vertices.w,0,0};
  float3 firstTrianglePos;

   if (whichVolumeTriangle.x+.5>15.0f) whichVolumeTriangle.x=0;
   firstTrianglePos=volumeTriangles[whichVolumeTriangle];
   if (1||abs(firstTrianglePos.x-.5)<.75) {
     triangles=vertices.xyz+firstTrianglePos;
     push(triangles);
     whichVolumeTriangle.x+=1;
     triangles=vertices.xyz+volumeTriangles[whichVolumeTriangle];
     push(triangles);
     whichVolumeTriangle.x+=1;
     triangles=vertices.xyz+volumeTriangles[whichVolumeTriangle];
     push(triangles);
   }  
}

unsigned int reverseBits(unsigned int x, unsigned int base) {
   unsigned int i,ret=0;
   unsigned int j=base-1;
   for (i=0;i<base;++i,--j) {
      if (x&(1<<i))         
         ret|=(1<<j);
   }
   return ret;
}
typedef float3 Triangle[5][3];
char volumeTriangles(Triangle tri[256]) {
   unsigned int i,j,k;

   for (i=0;i<256;++i) {
      for (j=0;j<15;++j) {
         tri[i][(j/3)%5][j%3]=/*float3((float)i,(float)i,(float)i);*/float3(1.0f/(float)floor(.5),1.0f/(float)floor(.5),1.0f/(float)floor(.5));
      }
      //      continue;
      j=0;
      while(1) {
         if (m_triTable[i][j]==-1){
            m_triNum[i]=(float)(j/3);
            break;           
         }
         for (k=0;k<3;++k) {
            float3 * p=&tri[i][j/3][k];
            p->x=m_triTable[i][j+k];
            p->y=m_triTable[i][j+k];
            p->z=m_triTable[i][j+k];
            switch ((int)m_triTable[i][j+k]) {
            case 0:
               p->x=p->z=0;p->y=0.5f;
               break;
            case 1:
               p->x=0.5f;p->z=0;p->y=1.0f;
               break;
            case 2:
               p->x=1.0f;p->z=0;p->y=0.5f;
               break;
            case 3:
               p->x=0.5f;p->z=0;p->y=0;
               break;
            case 4:
               p->x=0;p->z=1.0f;p->y=0.5f;
               break;
            case 5:
               p->x=0.5f;p->z=1.0f;p->y=1.0f;
               break;
            case 6:
               p->x=1.0f;p->z=1.0f;p->y=0.5f;
               break;
            case 7:
               p->x=0.5f;p->z=1.0f;p->y=0;
               break;
            case 8:
               p->x=p->y=0; p->z=0.5f;
               break;
            case 9:
               p->x=0;p->y=1.0f;p->z=0.5f;
               break;
            case 10:
               p->x=1.0f;p->y=1.0f;p->z=0.5f;
               break;
            case 11:
               p->x=1.0f;p->y=0;p->z=0.5f;
               break;
            }
         }
         j+=3;
      }
   }
  //fill in with brilliant triangle computations
  return 0;
}
Triangle* getVolumeTriangles () {
  static Triangle tri[256];
  static char eval =volumeTriangles(tri);
  return tri;
}

float tof (int a) {
  return (float)a;
}
int toi (float a) {
  return (int)a;
}
 int main (int argc, char ** argv) {
   int i;
   float3 volumeTriangles<256,15>;
   struct ppm dat;
   float * slice=0;
   char generatedData=0;
   for (i=0;i<argc;++i) {
     char match=0;
     int j;
     if (strcmp(argv[i],"-nofilter")==0) {
       match=1;
       use_vout_filter=0;
     }else if (strcmp(argv[i],"-noamplify")==0) {
       match=1;
       use_vout_amplify=0;
     }
     if (match) {
       for (j=i+1;j<argc;++j) argv[j-1]=argv[j];
       argc--;
       i--;
     }
   }
   streamRead(volumeTriangles,getVolumeTriangles());
   //   streamPrint(volumeTriangles,1);
   if (argc<2) {
      printf ("Usage: volume_division <FILE.pnm>\n      volume_divison <width>\n");
      exit (1);
   }
   
   if (argc==2)
   {           
      if (atoi(argv[1])==0) {
         dat = openPPM (argv[1]);
         if (!dat.fp)
            exit(1);
      }else {
         dat = randomPPM(atoi(argv[1]),atoi(argv[1]),atoi(argv[1]));
      }
      slice = mallocSlice(dat);
   }else {
     int width=atoi (argv[1]);
     int depth=atoi (argv[2]);
     int height;
     generatedData=1;
     if (argc>3)
       height=atoi (argv[3]);
     else
       height=width;
     dat = randomPPM(width,height,depth);
   }   
      {
         unsigned int i;
         float2 sliceZ;
         float cur<(dat.height),(dat.width)>;
         float next<(dat.height),(dat.width)>;
         float4 v<(dat.height),(use_vout_filter?1:dat.width)>;
         iter float2 center <(dat.height),(dat.width)> 
           = iter (float2(0.0f,0.0f),
                   float2(tof(dat.width),
                          tof(dat.height)));
         iter float2 up <(dat.height),(dat.width)> 
           = iter (float2(0.0f,1.0f),
                   float2(0.0f+tof(dat.width),
                          1.0f+tof(dat.height)));
         iter float2 upforward <(dat.height),(dat.width)> 
           = iter (float2(1.0f,1.0f),
                   float2(1.0f+tof(dat.width),
                          1.0f+tof(dat.height)));
         iter float2 forward <(dat.height),(dat.width)> 
           = iter (float2(1.0f,0.0f),
                   float2(1.0f+tof(dat.width),
                          tof(dat.height)));
         if (dat.width>512) {
           printf("Exceeded 512 wide texture bounds %d\n",dat.width);
           return 1;
         }
         if (!generatedData) {
            readPPM3dSlice(dat,0,slice);
            streamRead(next,slice);
         }
         sliceZ.x=0.0f;sliceZ.y=1.0f;
         for (i=0;i<dat.depth-1;++i) {
            if (!generatedData) {
               readPPM3dSlice(dat,i+1,slice);
               streamSwap(cur,next);
               if (i!=dat.depth-1) {
                  streamRead(next,slice);
               }
               use_vout_filter?processSlice(cur,
                                     i!=dat.depth-1?next:cur,
                                     v,
                                     center,
                                     up,
                                     upforward,
                                     forward,
                                     sliceZ):
                 processSliceNoCompact(cur,
                                       i!=dat.depth-1?next:cur,
                                       v,
                                       center,
                                       up,
                                       upforward,
                                       forward,
                                       sliceZ);
            }else {
              use_vout_filter?
                processVirtualSlice(v,center,upforward,sliceZ):
                processVirtualSliceNoCompact(v,center,upforward,sliceZ);
            }
            if (streamSize(v).y){
              if (use_vout_amplify) {
                iter float2 newsize <(toi(streamSize(v).y)),
                                    (toi(streamSize(v).x)*5)> =
                  iter(float2(0,0),float2(streamSize(v).x*5.0f,
                                          streamSize(v).y));
                float3 triangles <1,(toi(streamSize(v).x)*5)>;
                processTriangles(triangles, 
                                 v,
                                 volumeTriangles,
                                 newsize);
                 streamWrite(triangles,
                             consolidateVertices(dat,streamSize(triangles)));
                                
              }else {
                 float3 trianglesA<(toi(streamSize(v).y)),
                                  (toi(streamSize(v).x)*3)>;
                 float3 trianglesB<(toi(streamSize(v).y)),
                                  (toi(streamSize(v).x)*3)>;
                 float3 trianglesC<(toi(streamSize(v).y)),
                                  (toi(streamSize(v).x)*3)>;
                 float3 trianglesD<(toi(streamSize(v).y)),
                                  (toi(streamSize(v).x)*3)>;
                 float3 trianglesE<(toi(streamSize(v).y)),
                                  (toi(streamSize(v).x)*3)>;
                 processTrianglesNoCompact(trianglesA,
                                           trianglesB,
                                           trianglesC,
                                           trianglesD,
                                           trianglesE,
                                           v, 
                                           volumeTriangles);
                 streamWrite(trianglesA,
                             consolidateVertices(dat,streamSize(trianglesA)));
                 streamWrite(trianglesB,
                             consolidateVertices(dat,streamSize(trianglesB)));
                 streamWrite(trianglesC,
                             consolidateVertices(dat,streamSize(trianglesC)));
                 streamWrite(trianglesD,
                             consolidateVertices(dat,streamSize(trianglesD)));
                 streamWrite(trianglesE,
                             consolidateVertices(dat,streamSize(trianglesE)));
              //              streamPrint(trianglesA,1);
              //              streamPrint(trianglesB,1);
              //              streamPrint(trianglesC,1);
              //              streamPrint(trianglesD,1);
              }
            }
            sliceZ.x++;sliceZ.y++;
         }
      }
      free(slice);
      printVolume(dat);
   return 0;
   
 }


