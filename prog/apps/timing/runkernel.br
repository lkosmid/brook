/*
 * runkernel.br
 *
 *      Simple tests to time how long it takes to invoke various kernels
 *      (i.e. ratio of execution time to stream length).
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "main.h"
#include "runkernel.h"

#if 1
#define CHECK_MISMATCH 1
#else
#define CHECK_MISMATCH 0
#endif

/*
 * RunKernelKickKernel --
 *
 *      Just copy.  This kernel is separate from the test kernels just so
 *      nothing related to it gets cached.  It exists only for priming the
 *      BRT so we can ignore cold start timing.
 */

kernel void
RunKernelKickKernel(float s<>, out float o<>)
{
   o = s;
}


/*
 * RunKernelHardWork --
 *
 *      Try for a kernel that will actually exercise the GPU
 */

kernel void
RunKernelHardWork(float4 c, float4 s<>, out float4 o<>)
{
   o = s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   /*
   */
}


/*
 * RunKernelHardWorkCPU --
 *
 *      Simple C code to mimic the HardWork kernel.  Makes a plausible
 *      baseline for a naive native implementation.
 */

static void
RunKernelHardWorkCPU(int streamLength, float4 c, float4 *input, float4 *output)
{
   int i;

   for (i = 0; i < streamLength * streamLength; i++) {
      output[i].x = input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;
      output[i].x = c.x * output[i].x + input[i].x;


      output[i].y = input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;
      output[i].y = c.y * output[i].y + input[i].y;


      output[i].z = input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;
      output[i].z = c.z * output[i].z + input[i].z;


      output[i].w = input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
      output[i].w = c.w * output[i].w + input[i].w;
   }
}


/*
 * RunKernelKickBRT --
 *
 *      Running the first kernel is very slow because a lot of one time
 *      initialization happens in BRT itself.  So we make sure we run one
 *      untimed kernel to grease the tracks.  We intentionally don't use the
 *      same kernel we time to avoid introducing false caching behaviors.
 */

static void
RunKernelKickBRT(void)
{
   float d[1] = { 12.34f };
   float s<1>, o<1>;

   streamRead(s, d);
   RunKernelKickKernel(s, o);
   streamWrite(o, d);

   if (CHECK_MISMATCH && d[0] != 12.34f) {
      fprintf(stderr, "RunKernelKickBRT: Mismatch!  Got %.2f expecting %.2f\n",
              d[0], 12.34f);
   }
}


/*
 * RunKernelBuildData --
 *
 *      Helper function that allocates memory and fills it with the stream
 *      test pattern.
 */

static void
RunKernelBuildData(float4 **data, int numEntries)
{
   int i;

   *data = (float4 *) malloc(numEntries * sizeof **data);
   assert(*data);

   for (i = 0; i < numEntries; i++) {
      (*data)[i].x = (*data)[i].y = (*data)[i].z = (*data)[i].w = (float) i;
   }
}


/*
 * RunKernelProcessTiming --
 *
 *      Interpret the numbers, calculate FLOPS, and check to make certain
 *      the output is the expected transformation on the input.
 *
 *      NOTE: stop and start are tunnelled in as globals for the same ease
 *      of implementation issue as the fact that they're declared in main.h
 *      instead of here.
 */

static void
RunKernelProcessTiming(char *name, float4 *data,
                       int length, int numEntries, int nRuns)
{
   float scale, elapsed;
   int i;

   elapsed = (float) (stop - start);

   /*
    * Our kernel does one assignment and n '1.0*output + input' so the
    * result should be n*input and there will have been n + 1 ops in the
    * kernel.
    */
   scale = numEntries > 1 ? data[1].x : 0.0f;
   if (scale > 1024.0f || (scale < 61.0f && numEntries > 1)) {
      printf("(* Got back garbage!  data[1].x is %.2f *)\n", data[1].x);
      scale = 0.0f;
   }

   /*
    * 'MFLOPS' calculation:
    *   - numEntries * nRuns entries processed total
    *   - calculations took elapsed usecs = elapsed/10^6 secs
    *   - scale + 1 instructions
    *   - 4 floats per entry
    */
   printf("%8I64d\t%6.2f\t\t%4d\t\t(* %s %d R%d *)\n",
          stop - start,
          numEntries * nRuns / elapsed * (scale + 1.0f) * 4.0f,
          nRuns, name, length, nRuns);

   for (i = 0; CHECK_MISMATCH && i < numEntries; i++) {
      float expected = scale * i;
      float cur = data[i].x;

      /*
       * Grr.  Tolerate precision errors so long as the result isn't
       * wrong by more than 10%.  Since you start to see skipping around
       * 2^24 on nv30 and around 2^17 on ATI, once we're dealing with
       * reasonable scales and 1024x1024 streams, there are precision
       * artifacts.  Sad.  --Jeremy.
       */

      if ((cur != expected &&
           (cur - expected > 0.1f * expected || expected - cur > 0.1f * cur)) ||
          data[i].y != cur || data[i].z != cur || data[i].w != cur) {
         printf("(* Mismatch %d,%d/%d: *)\n"
                "(* Expected %.2f, Got: %.2f %.2f %.2f %.2f *)\n",
                 i / length, i % length, length, name, expected,
                 data[i].x, data[i].y, data[i].z, data[i].w, name);
         return;
      }
   }
}


/*
 * RunKernel1D --
 *
 *      Runs a simple kernel on a 1D stream and times it.
 */

static void
RunKernel1D(char *logName, int streamLength, int nRuns)
{
   float4 s<streamLength>, o<streamLength>;
   float4 *data;
   int i;

   RunKernelBuildData(&data, streamLength);

   start = GetTime();
   streamRead(s, data);
   for (i = 0; i < nRuns; i++) {
      RunKernelHardWork(float4(1.0f, 1.0f, 1.0f, 1.0f), s, o);
   }
   streamWrite(o, data);
   stop = GetTime();

   RunKernelProcessTiming(logName, data, streamLength, streamLength, nRuns);
   free(data);
}


/*
 * RunKernel2D --
 *
 *      Runs a simple kernel on a 2D stream and times it.
 */

static void
RunKernel2D(char *logName, int streamLength, int nRuns)
{
   float4 s<streamLength, streamLength>, o<streamLength, streamLength>;
   float4 *data;
   int i;

   RunKernelBuildData(&data, streamLength * streamLength);

   start = GetTime();
   streamRead(s, data);
   for (i = 0; i < nRuns; i++) {
      RunKernelHardWork(float4(1.0f, 1.0f, 1.0f, 1.0f), s, o);
   }
   streamWrite(o, data);
   stop = GetTime();

   RunKernelProcessTiming(logName, data,
                          streamLength, streamLength * streamLength, nRuns);
   free(data);
}


/*
 * RunKernel2DCPU --
 *
 *      Simple CPU implementation to see what comes from the CPU runtime and
 *      what's just that the CPU is slow.
 */

static void
RunKernel2DCPU(char *logName, int streamLength, int nRuns)
{
   float4 *data, *outData;
   int i;

   RunKernelBuildData(&data, streamLength * streamLength);
   outData = (float4 *) malloc(streamLength * streamLength * sizeof *outData);

   start = GetTime();
   for (i = 0; i < nRuns; i++) {
      RunKernelHardWorkCPU(streamLength,
                           float4(1.0f, 1.0f, 1.0f, 1.0f), data, outData);
   }
   stop = GetTime();

   RunKernelProcessTiming(logName, outData, streamLength,
                          streamLength * streamLength, nRuns);
   free(data);
   free(outData);
}




/*
 * RunKernel_Time --
 *
 *      Entry point for the kernel overhead tests.  We measure execution
 *      time as a function of stream length.
 */

void
RunKernel_Time(int maxLength)
{
   static const int runLengths[] = { 1, 2, 4, 8, 10, 20, 40, 50, /*75, 150, 200*/ };
   static const int lengths[] = { 1, 4, 16, 64, 256, 512, 1024, 2048 };
   static const int numLengths = sizeof lengths / sizeof lengths[0];
   static const int numRunLengths = sizeof runLengths / sizeof runLengths[0];
   int i, j;

   RunKernelKickBRT();

   for (i = 0; i < numLengths && lengths[i] < maxLength; i++) {
      printf("(* RunKernel1D: length %d *)\n",lengths[i]);
      printf("(* usecs\tMFLOPS\t\truns *)\n");
      for (j = 0; j < numRunLengths; j++) {
         RunKernel1D("RunK1D", lengths[i], runLengths[j]);
      }
      printf("\n");
   }
   printf("(* RunKernel1D length %d *)\n", maxLength);
   printf("(* usecs\tMFLOPS\t\truns *)\n");
   for (j = 0; j < numRunLengths; j++) {
      RunKernel1D("RunK1D", maxLength, runLengths[j]);
   }
   printf("\n");

   for (i = 0; i < numLengths && lengths[i] < maxLength; i++) {
      printf("(* RunKernel2D length %d *)\n",lengths[i]);
      printf("(* usecs\tMFLOPS\t\truns *)\n");
      for (j = 0; j < numRunLengths; j++) {
         RunKernel2D("RunK2D", lengths[i], runLengths[j]);
         //RunKernel2DCPU("RunK2DCPU", lengths[i], runLengths[j]);
      }
      printf("\n");
   }
   printf("(* RunKernel2D length %d *)\n", maxLength);
   printf("(* usecs\tMFLOPS\t\truns *)\n");
   for (j = 0; j < numRunLengths; j++) {
      RunKernel2D("RunK2D", maxLength, runLengths[j]);
      //RunKernel2DCPU("RunK2DCPU", maxLength, runLengths[j]);
   }
}
