/*
 * runkernel.br
 *
 *      Simple tests to time how long it takes to invoke various kernels
 *      (i.e. ratio of execution time to stream length).
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "main.h"
#include "runkernel.h"

#if 0
#define CHECK_MISMATCH 1
#else
#define CHECK_MISMATCH 0
#endif

/*
 * RunKernelKickKernel --
 *
 *      Just copy.  This kernel is separate from the test kernels just so
 *      nothing related to it gets cached.  It exists only for priming the
 *      BRT so we can ignore cold start timing.
 */

kernel void
RunKernelKickKernel(float s<>, out float o<>)
{
   o = s;
}


/*
 * RunKernelDouble --
 *
 *      A dead simple 1D kernel.  Just double every element
 */

kernel void
RunKernelDouble(float4 s<>, out float4 o<>)
{
   o = s + s;
}


/*
 * RunKernelHardWork --
 *
 *      Try for a kernel that will actually exercise the GPU
 */

static void RunKernelHardWork2(float4 c, ...) {}

kernel void
RunKernelHardWork(float4 c, float4 s<>, out float4 o<>)
{
   o = s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   o = c*o + s;
   /*
   */
}


/*
 * RunKernelKickBRT --
 *
 *      Running the first kernel is very slow because a lot of one time
 *      initialization happens in BRT itself.  So we make sure we run one
 *      untimed kernel to grease the tracks.  We intentionally don't use the
 *      same kernel we time to avoid introducing false caching behaviors.
 */

static void
RunKernelKickBRT(void)
{
   float d[1] = { 12.34f };
   float s<1>, o<1>;

   streamRead(s, d);
   RunKernelKickKernel(s, o);
   streamWrite(o, d);

   if (CHECK_MISMATCH && d[0] != 12.34f) {
      fprintf(stderr, "RunKernelKickBRT: Mismatch!  Got %.2f expecting %.2f\n",
              d[0], 12.34f);
   }
}


/*
 * RunKernel1D --
 *
 *      Runs a simple kernel on a 1D stream and times it.
 */

static void
RunKernel1D(int streamLength, int nRuns)
{
   float4 *data;
   float4 s<streamLength>, o<streamLength>;
   float elapsed;
   int numBytes, i;

   numBytes = streamLength * sizeof(*data);
   data = (float4 *) malloc(numBytes);
   assert(data);

   for (i = 0; i < streamLength; i++) {
      data[i].x = data[i].y = data[i].z = data[i].w = (float) i;
   }

   start = GetTime();
   streamRead(s, data);
   for (i = 0; i < nRuns; i++) {
      //RunKernelDouble(s, o);
      RunKernelHardWork(float4(1.0f, 1.0f, 1.0f, 1.0f), s, o);
   }
   streamWrite(o, data);
   stop = GetTime();
   elapsed = (stop - start) / 1.0f /*(float) nRuns*/;

   printf("   %I64d\t\t%.2f\t\t%d\n",
          stop - start, (float) (nRuns * streamLength / elapsed), nRuns);

   for (i = 0; CHECK_MISMATCH && i < streamLength; i++) {
      if (data[i].x != (float) 63*i || data[i].y != data[i].x ||
          data[i].z != data[i].x || data[i].w != data[i].x) {
         fprintf(stderr, "RunKernel1D: Mismatch %d/%d: %.2f %.2f %.2f %.2f\n",
                 i, streamLength, data[i].x, data[i].y, data[i].z, data[i].w);
         exit(1);
      }
   }

   free(data);
}


/*
 * RunKernel2D --
 *
 *      Runs a simple kernel on a 2D stream and times it.
 */

static void
RunKernel2D(int streamLength, int nRuns)
{
   float4 *data;
   float4 s<streamLength, streamLength>, o<streamLength, streamLength>;
   float elapsed;
   int numBytes, i, j;

   numBytes = streamLength * streamLength * sizeof(*data);
   data = (float4 *) malloc(numBytes);
   assert(data);

   for (i = 0; i < streamLength; i++) {
      for (j = 0; j < streamLength; j++) {
         float4 *cur = (data + i*streamLength + j);

         cur->x = cur->y = cur->z = cur->w = (float) (i*streamLength + j);
      }
   }

   start = GetTime();
   streamRead(s, data);
   for (i = 0; i < nRuns; i++) {
      //RunKernelDouble(s, o);
      RunKernelHardWork(float4(1.0f, 1.0f, 1.0f, 1.0f), s, o);
   }
   streamWrite(o, data);
   stop = GetTime();
   elapsed = (stop - start) / 1.0f /*(float) nRuns*/;

   printf("   %I64d\t\t%.2f\t\t%d\n",
          stop - start,
          (float) (nRuns * streamLength * streamLength / elapsed), nRuns);

   for (i = 0; CHECK_MISMATCH && i < streamLength; i++) {
      for (j = 0; j < streamLength; j++) {
         float4 *cur = (data + i*streamLength + j);

         if (cur->x != (float) (63*(i*streamLength + j)) ||
             cur->y != cur->x || cur->z != cur->x || cur->w != cur->x) {
            fprintf(stderr, "RunKernel2D: Mismatch %d/%d: %.2f %.2f %.2f %.2f\n",
                    i, streamLength, cur->x, cur->y, cur->z, cur->w);
            exit(1);
         }
      }
   }

   free(data);
}


/*
 * RunKernel_Time --
 *
 *      Entry point for the kernel overhead tests.  We measure execution
 *      time as a function of stream length.
 */

void
RunKernel_Time(int maxLength)
{
   static const int runLengths[] = { 1, 10, 50, 75, /*150, 200*/ };
   static const int lengths[] = { 1, 4, 16, 64, 256, 512, 1024, 2048 };
   static const int numLengths = sizeof lengths / sizeof lengths[0];
   static const int numRunLengths = sizeof runLengths / sizeof runLengths[0];
   int i, j;

   RunKernelKickBRT();

   for (i = 0; i < numLengths && lengths[i] < maxLength; i++) {
      printf("(* RunKernel1D streamLength %d *)\n", lengths[i]);
      printf("(* usecs\tMFloat4s/s\t\truns *)\n");
      for (j = 0; j < numRunLengths; j++) {
         RunKernel1D(lengths[i], runLengths[j]);
      }
      printf("\n");
   }
   printf("(* RunKernel1D streamLength %d *)\n", maxLength);
   printf("(* usecs\tMFloat4s/s\t\truns *)\n");
   for (j = 0; j < numRunLengths; j++) {
      RunKernel1D(maxLength, runLengths[j]);
   }
   printf("\n");

   for (i = 0; i < numLengths && lengths[i] < maxLength; i++) {
      printf("(* RunKernel2D streamLength %d *)\n", lengths[i]);
      printf("(* usecs\tMFloat4s/s\t\truns *)\n");
      for (j = 0; j < numRunLengths; j++) {
         RunKernel2D(lengths[i], runLengths[j]);
      }
      printf("\n");
   }
   printf("(* RunKernel2D streamLength %d *)\n", maxLength);
   printf("(* usecs\tMFloat4s/s\t\truns *)\n");
   for (j = 0; j < numRunLengths; j++) {
      RunKernel2D(maxLength, runLengths[j]);
   }
}
