/*
 * readwrite.br
 *
 *      Very simple tests of how long it takes to fill and then read back a
 *      stream.
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "main.h"
#include "readwrite.h"


/*
 * ReadWriteNOP --
 *
 *      We need to touch our streams in order to force the runtime to pull
 *      them down to the card, so we use the simplest kernel to accomplish
 *      that.
 */

kernel void
ReadWriteNOP(float4 s<>, out float4 o<>)
{
   o = s;
}


/*
 * ReadWrite1D --
 *
 *      Measure how fast we can streamRead() and streamWrite() a 1D stream
 *      of float4's of the specified length.
 */

static void
ReadWrite1D(int length)
{
   float4 *in, *output;
   float4 s<length>, o<length>;
   int numBytes, i;

   numBytes = length * sizeof(*in);
   in = (float4 *) malloc(numBytes);
   assert(in);
   output = (float4 *) malloc(numBytes);
   assert(output);

   for (i = 0; i < length; i++) {
      in[i].x = (float) i;
      in[i].y = (float) i;
      in[i].z = (float) i;
      in[i].w = (float) i;
      output[i] = float4(-1.0f, -1.0f, -1.0f, -1.0f);
   }

   start = GetTime();
   streamRead(s, in);
   ReadWriteNOP(s, o);
   streamWrite(o, output);
   stop = GetTime();

   printf("Read1D: Read / NOP / Write took %d usecs (%.2f MB/sec).\n",
          (int) (stop - start), numBytes / (float) (stop - start));

   for (i = 0; i < length; i++) {
      if (in[i].x != output[i].x ||
          in[i].y != output[i].y ||
          in[i].z != output[i].z ||
          in[i].w != output[i].w) {
         fprintf(stderr, "ReadWrite1D: Mismatch %d.  In: %f, Out: %f\n",
                 i, in[i].x, output[i].x);
      }
   }
}


/*
 * ReadWrite2D --
 *
 *      Measure how fast we can streamRead() and streamWrite() a 2D stream
 *      of float4's of the specified length in each dimension.
 */

static void
ReadWrite2D(int length)
{
   float4 *in, *output;
   float4 s<length, length>, o<length, length>;
   int numBytes, i, j;

   numBytes = length * length * sizeof(*in);
   in = (float4 *) malloc(numBytes);
   assert(in);
   output = (float4 *) malloc(numBytes);
   assert(output);

   for (i = 0; i < length; i++) {
      for (j = 0; j < length; j++) {
         (*(in + i*length + j)).x = (float) (i * length + j);
         (*(in + i*length + j)).y = (float) (i * length + j);
         (*(in + i*length + j)).z = (float) (i * length + j);
         (*(in + i*length + j)).w = (float) (i * length + j);
         *(output + i*length + j) = float4(-1.0f, -1.0f, -1.0f, -1.0f);
      }
   }

   start = GetTime();
   streamRead(s, in);
   ReadWriteNOP(s, o);
   streamWrite(o, output);
   stop = GetTime();

   printf("Read2D: Read / NOP / Write took %d usecs (%.2f MB/sec).\n",
          (int) (stop - start), numBytes / (float) (stop - start));

   for (i = 0; i < length; i++) {
      for (j = 0; j < length; j++) {
         float4 cur_in, cur_out;

         cur_in = *(in + i*length + j);
         cur_out = *(output + i*length + j);
         if (cur_in.x != cur_out.x &&
             cur_in.y != cur_out.y &&
             cur_in.z != cur_out.z &&
             cur_in.w != cur_out.w) {
            fprintf(stderr, "ReadWrite2D: Mismatch %d, %d.  In: %f, Out: %f\n",
                    i, j, cur_in.x, cur_out.x);
            exit (1);
         }
      }
   }
}

void
ReadWrite_Time(int length)
{
   float4 s<1>, o<1>;

   /* Prevent kernel cold start costs from inflating ReadWrite1D() */
   ReadWriteNOP(s, o);

   ReadWrite1D(length);
   ReadWrite2D(length);
}
