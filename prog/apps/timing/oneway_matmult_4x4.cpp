
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Jan  9 2004 11:04:30
////////////////////////////////////////////

#include <brook.hpp>
#include "main.h"


#include <stdio.h>

#define MAX_ITER 1000

typedef struct matrix4_t {
  float4  row0;
  float4  row1;
  float4  row2;
  float4  row3;
} matrix4;typedef struct __cpustruct_matrix4_t {
__BrtFloat4 row0;
__BrtFloat4 row1;
__BrtFloat4 row2;
__BrtFloat4 row3;
}
__cpustruct_matrix4;

namespace brook {
	template<> inline const __BRTStreamType* getStreamType(matrix4*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}


static const char* __matmult_4x4_ps20[] = {
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s0\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r4, t1, s4\n"
"    texld r2, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r0, t1, s7\n"
"    texld r1, t0, s0\n"
"    mov r5.x, r4.x\n"
"    mov r5.y, r2.x\n"
"    mov r5.z, r3.x\n"
"    mov r5.w, r0.x\n"
"    dp4 r0.x, r1, r5\n"
"    mov r5.x, r4.y\n"
"    mov r5.y, r2.y\n"
"    mov r5.z, r3.y\n"
"    mov r5.w, r0.y\n"
"    dp4 r0.y, r1, r5\n"
"    mov r3.x, r4.z\n"
"    mov r2.x, r4.w\n"
"    mov r3.y, r2.z\n"
"    mov r2.y, r2.w\n"
"    mov r2.z, r3.w\n"
"    mov r3.w, r0.z\n"
"    mov r2.w, r0.w\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:0:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s1\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r4, t1, s4\n"
"    texld r2, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r0, t1, s7\n"
"    texld r1, t0, s1\n"
"    mov r5.x, r4.x\n"
"    mov r5.y, r2.x\n"
"    mov r5.z, r3.x\n"
"    mov r5.w, r0.x\n"
"    dp4 r0.x, r1, r5\n"
"    mov r5.x, r4.y\n"
"    mov r5.y, r2.y\n"
"    mov r5.z, r3.y\n"
"    mov r5.w, r0.y\n"
"    dp4 r0.y, r1, r5\n"
"    mov r3.x, r4.z\n"
"    mov r2.x, r4.w\n"
"    mov r3.y, r2.z\n"
"    mov r2.y, r2.w\n"
"    mov r2.z, r3.w\n"
"    mov r3.w, r0.z\n"
"    mov r2.w, r0.w\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:1:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s2\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r4, t1, s4\n"
"    texld r2, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r0, t1, s7\n"
"    texld r1, t0, s2\n"
"    mov r5.x, r4.x\n"
"    mov r5.y, r2.x\n"
"    mov r5.z, r3.x\n"
"    mov r5.w, r0.x\n"
"    dp4 r0.x, r1, r5\n"
"    mov r5.x, r4.y\n"
"    mov r5.y, r2.y\n"
"    mov r5.z, r3.y\n"
"    mov r5.w, r0.y\n"
"    dp4 r0.y, r1, r5\n"
"    mov r3.x, r4.z\n"
"    mov r2.x, r4.w\n"
"    mov r3.y, r2.z\n"
"    mov r2.y, r2.w\n"
"    mov r2.z, r3.w\n"
"    mov r3.w, r0.z\n"
"    mov r2.w, r0.w\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:2:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s3\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r4, t1, s4\n"
"    texld r2, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r0, t1, s7\n"
"    texld r1, t0, s3\n"
"    mov r5.x, r4.x\n"
"    mov r5.y, r2.x\n"
"    mov r5.z, r3.x\n"
"    mov r5.w, r0.x\n"
"    dp4 r0.x, r1, r5\n"
"    mov r5.x, r4.y\n"
"    mov r5.y, r2.y\n"
"    mov r5.z, r3.y\n"
"    mov r5.w, r0.y\n"
"    dp4 r0.y, r1, r5\n"
"    mov r3.x, r4.z\n"
"    mov r2.x, r4.w\n"
"    mov r3.y, r2.z\n"
"    mov r2.y, r2.w\n"
"    mov r2.z, r3.w\n"
"    mov r3.w, r0.z\n"
"    mov r2.w, r0.w\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:3:1:\n"
"",
NULL};


static const char *__matmult_4x4_fp30 = NULL;

static void  __matmult_4x4_cpu_inner (const __cpustruct_matrix4 &a,
                               const __cpustruct_matrix4 &b,
                               __cpustruct_matrix4 &result){
  __BrtFloat4  b_col0 = __BrtFloat4 (b.row0.swizzle1(maskX),b.row1.swizzle1(maskX),b.row2.swizzle1(maskX),b.row3.swizzle1(maskX));
  __BrtFloat4  b_col1 = __BrtFloat4 (b.row0.swizzle1(maskY),b.row1.swizzle1(maskY),b.row2.swizzle1(maskY),b.row3.swizzle1(maskY));
  __BrtFloat4  b_col2 = __BrtFloat4 (b.row0.swizzle1(maskZ),b.row1.swizzle1(maskZ),b.row2.swizzle1(maskZ),b.row3.swizzle1(maskZ));
  __BrtFloat4  b_col3 = __BrtFloat4 (b.row0.swizzle1(maskW),b.row1.swizzle1(maskW),b.row2.swizzle1(maskW),b.row3.swizzle1(maskW));

  result.row0 = __BrtFloat4 (__dot_cpu_inner(a.row0,b_col0),__dot_cpu_inner(a.row0,b_col1),__dot_cpu_inner(a.row0,b_col2),__dot_cpu_inner(a.row0,b_col3));
  result.row1 = __BrtFloat4 (__dot_cpu_inner(a.row1,b_col0),__dot_cpu_inner(a.row1,b_col1),__dot_cpu_inner(a.row1,b_col2),__dot_cpu_inner(a.row1,b_col3));
  result.row2 = __BrtFloat4 (__dot_cpu_inner(a.row2,b_col0),__dot_cpu_inner(a.row2,b_col1),__dot_cpu_inner(a.row2,b_col2),__dot_cpu_inner(a.row2,b_col3));
  result.row3 = __BrtFloat4 (__dot_cpu_inner(a.row3,b_col0),__dot_cpu_inner(a.row3,b_col1),__dot_cpu_inner(a.row3,b_col2),__dot_cpu_inner(a.row3,b_col3));
}
static void  __matmult_4x4_cpu (const std::vector<void *>&args,
                         const std::vector<const unsigned int *>&extents,
                         const std::vector<unsigned int>&dims,
                         unsigned int mapbegin, 
                         unsigned int mapextent) {
  __cpustruct_matrix4*arg0 = (__cpustruct_matrix4*)args[0];
  __cpustruct_matrix4*arg1 = (__cpustruct_matrix4*)args[1];
  __cpustruct_matrix4*arg2 = (__cpustruct_matrix4*)args[2];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  unsigned int ratio0 = extents[2][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[2][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[2]);
  unsigned int ratio1 = extents[2][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[2][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[2]);
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __matmult_4x4_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *arg2);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg2;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[2]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[2]);
    }
  }
}

static void  matmult_4x4 (const ::brook::stream& a,
		const ::brook::stream& b,
		::brook::stream& result) {
  static const void *__matmult_4x4_fp[] = {
     "fp30", __matmult_4x4_fp30,
     "ps20", __matmult_4x4_ps20,
     "cpu", (void *) __matmult_4x4_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__matmult_4x4_fp);

  k->PushStream(a);
  k->PushStream(b);
  k->PushOutput(result);
  k->Map();

}



static const char* __matmult_4x4_pretransposed_ps20[] = {
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s0\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r0, t1, s4\n"
"    texld r1, t0, s0\n"
"    texld r4, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r2, t1, s7\n"
"    dp4 r0.x, r1, r0\n"
"    dp4 r0.y, r1, r4\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:0:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s1\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r0, t1, s4\n"
"    texld r1, t0, s1\n"
"    texld r4, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r2, t1, s7\n"
"    dp4 r0.x, r1, r0\n"
"    dp4 r0.y, r1, r4\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:1:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s2\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r0, t1, s4\n"
"    texld r1, t0, s2\n"
"    texld r4, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r2, t1, s7\n"
"    dp4 r0.x, r1, r0\n"
"    dp4 r0.y, r1, r4\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:2:1:\n"
"",
"    ps_2_0\n"
"    dcl t0.xy\n"
"    dcl t1.xy\n"
"    dcl_2d s3\n"
"    dcl_2d s4\n"
"    dcl_2d s5\n"
"    dcl_2d s6\n"
"    dcl_2d s7\n"
"    texld r0, t1, s4\n"
"    texld r1, t0, s3\n"
"    texld r4, t1, s5\n"
"    texld r3, t1, s6\n"
"    texld r2, t1, s7\n"
"    dp4 r0.x, r1, r0\n"
"    dp4 r0.y, r1, r4\n"
"    dp4 r0.z, r1, r3\n"
"    dp4 r0.w, r1, r2\n"
"    mov oC0, r0\n"
"\n"
" \n"
"//!!BRCC\n"
"//narg:3\n"
"//s:0:a\n"
"//s:0:b\n"
"//o:0:result\n"
"//workspace:1024\n"
"//!!multipleOutputInfo:3:1:\n"
"",
NULL};


static const char *__matmult_4x4_pretransposed_fp30 = NULL;

static void  __matmult_4x4_pretransposed_cpu_inner (const __cpustruct_matrix4 &a,
                                             const __cpustruct_matrix4 &b,
                                             __cpustruct_matrix4 &result){
  result.row0 = __BrtFloat4 (__dot_cpu_inner(a.row0,b.row0),__dot_cpu_inner(a.row0,b.row1),__dot_cpu_inner(a.row0,b.row2),__dot_cpu_inner(a.row0,b.row3));
  result.row1 = __BrtFloat4 (__dot_cpu_inner(a.row1,b.row0),__dot_cpu_inner(a.row1,b.row1),__dot_cpu_inner(a.row1,b.row2),__dot_cpu_inner(a.row1,b.row3));
  result.row2 = __BrtFloat4 (__dot_cpu_inner(a.row2,b.row0),__dot_cpu_inner(a.row2,b.row1),__dot_cpu_inner(a.row2,b.row2),__dot_cpu_inner(a.row2,b.row3));
  result.row3 = __BrtFloat4 (__dot_cpu_inner(a.row3,b.row0),__dot_cpu_inner(a.row3,b.row1),__dot_cpu_inner(a.row3,b.row2),__dot_cpu_inner(a.row3,b.row3));
}
static void  __matmult_4x4_pretransposed_cpu (const std::vector<void *>&args,
                                       const std::vector<const unsigned int *>&extents,
                                       const std::vector<unsigned int>&dims,
                                       unsigned int mapbegin, 
                                       unsigned int mapextent) {
  __cpustruct_matrix4*arg0 = (__cpustruct_matrix4*)args[0];
  __cpustruct_matrix4*arg1 = (__cpustruct_matrix4*)args[1];
  __cpustruct_matrix4*arg2 = (__cpustruct_matrix4*)args[2];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  unsigned int ratio0 = extents[2][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[2][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[2]);
  unsigned int ratio1 = extents[2][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[2][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[2]);
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __matmult_4x4_pretransposed_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *arg2);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg2;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[2]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[2]);
    }
  }
}

static void  matmult_4x4_pretransposed (const ::brook::stream& a,
		const ::brook::stream& b,
		::brook::stream& result) {
  static const void *__matmult_4x4_pretransposed_fp[] = {
     "fp30", __matmult_4x4_pretransposed_fp30,
     "ps20", __matmult_4x4_pretransposed_ps20,
     "cpu", (void *) __matmult_4x4_pretransposed_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__matmult_4x4_pretransposed_fp);

  k->PushStream(a);
  k->PushStream(b);
  k->PushOutput(result);
  k->Map();

}


static void  floatFill(float  *outBuffer, int  inCount, float  inValue)
{
  int  count = inCount;
  float  *buffer = outBuffer;

  while (count--)
    *buffer++ = inValue;
}

static void  runTest(int  inSize, int  inIterations, int  *outTime, float  *outFlops, float* outInBW, float* outOutBW )
{
  ::brook::stream a(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream b(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream c(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  matrix4  *data;
  int  i;
  int64  startTime;
  int64  stopTime;
  int  elapsed;

  data = (matrix4 *) (malloc(inSize * inSize * sizeof(matrix4 ) ));
  floatFill((float *) (data),inSize * inSize * 4,1.000000f);
  startTime = GetTime();
  streamRead(a,data);
  streamRead(b,data);
  for (i = 0; i < inIterations; i++)
  {
    matmult_4x4(a,b,c);
  }

  streamWrite(c,data);
  stopTime = GetTime();
  elapsed = (int ) (stopTime - startTime);
  *outTime = elapsed;
  *outFlops = 23.000000f * inIterations * inSize * inSize / (float ) (elapsed);
  *outInBW = (float)(4*5*sizeof(float4)) * inIterations * inSize * inSize / (float ) (elapsed);
  *outOutBW = (float)(4*sizeof(float4)) * inIterations * inSize * inSize / (float ) (elapsed);
}

static void  runPretransposedTest(int  inSize, int  inIterations, int  *outTime, float  *outFlops, float* outInBW, float* outOutBW )
{
  ::brook::stream a(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream b(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream c(::brook::getStreamType(( matrix4  *)0), inSize , inSize,-1);
  matrix4  *data;
  int  i;
  int64  startTime;
  int64  stopTime;
  int  elapsed;

  data = (matrix4 *) (malloc(inSize * inSize * sizeof(matrix4 ) ));
  floatFill((float *) (data),inSize * inSize * 4,1.000000f);
  startTime = GetTime();
  streamRead(a,data);
  streamRead(b,data);
  for (i = 0; i < inIterations; i++)
  {
    matmult_4x4_pretransposed(a,b,c);
  }

  streamWrite(c,data);
  stopTime = GetTime();
  elapsed = (int ) (stopTime - startTime);
  *outTime = elapsed;
  *outFlops = 23.000000f * inIterations * inSize * inSize / (float ) (elapsed);
  *outInBW = (float)(4*5*sizeof(float4)) * inIterations * inSize * inSize / (float ) (elapsed);
  *outOutBW = (float)(4*sizeof(float4)) * inIterations * inSize * inSize / (float ) (elapsed);
}

void  Matmult4x4_1way_Time(int  inStreamSize)
{
  int  time;
  float  flops;
  float inputBandwidth;
  float outputBandwidth;
  
  runTest(inStreamSize,MAX_ITER,&time,&flops,&inputBandwidth,&outputBandwidth);

  printf("matmult4x4 1-way\n");
  printf("iterations = %d\n", MAX_ITER);
  printf("stream size = %d * %d * 4*float4\n",inStreamSize,inStreamSize);
  printf("time(microseconds) ops(megaflop/s) bandwidth in/out(megabytes/s)\n");
  printf("%9d  %5.6f %5.6f %5.6f\n",time,flops,inputBandwidth,outputBandwidth);
  printf("\n\n");
}

void  Matmult4x4_1wayPretransposed_Time(int  inStreamSize)
{
  int  time;
  float  flops;
  float inputBandwidth;
  float outputBandwidth;
  
  runPretransposedTest(inStreamSize,MAX_ITER,&time,&flops,&inputBandwidth,&outputBandwidth);

  printf("matmult4x4 1-way pretransposed\n");
  printf("iterations = %d\n", MAX_ITER);
  printf("stream size = %d * %d * 4*float4\n",inStreamSize,inStreamSize);
  printf("time(microseconds) ops(megaflop/s) bandwidth in/out(megabytes/s)\n");
  printf("%9d  %5.6f %5.6f %5.6f\n",time,flops,inputBandwidth,outputBandwidth);
  printf("\n\n");
}

