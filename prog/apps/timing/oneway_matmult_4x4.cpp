
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Apr 22 2004 11:27:18
////////////////////////////////////////////

#include <brook/brook.hpp>
#include "main.h"


#include <stdio.h>


typedef struct oneway_matrix4_t {
  float4  row0;
  float4  row1;
  float4  row2;
  float4  row3;
} matrix4;typedef struct __cpustruct_oneway_matrix4_t {
__BrtFloat4 row0;
__BrtFloat4 row1;
__BrtFloat4 row2;
__BrtFloat4 row3;
}
__cpustruct_matrix4;

const brook::StreamType* getStreamTypeMatrix4(matrix4*) {
 static const brook::StreamType result[] = {::brook::__BRTFLOAT4, ::brook::__BRTFLOAT4, ::brook::__BRTFLOAT4, ::brook::__BRTFLOAT4, ::brook::__BRTNONE};
   return result;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r4, t1, s4\n"
				"    texld r2, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r0, t1, s7\n"
				"    texld r1, t0, s0\n"
				"    mov r5.x, r4.x\n"
				"    mov r5.y, r2.x\n"
				"    mov r5.z, r3.x\n"
				"    mov r5.w, r0.x\n"
				"    dp4 r0.x, r1, r5\n"
				"    mov r5.x, r4.y\n"
				"    mov r5.y, r2.y\n"
				"    mov r5.z, r3.y\n"
				"    mov r5.w, r0.y\n"
				"    dp4 r0.y, r1, r5\n"
				"    mov r3.x, r4.z\n"
				"    mov r2.x, r4.w\n"
				"    mov r3.y, r2.z\n"
				"    mov r2.y, r2.w\n"
				"    mov r2.z, r3.w\n"
				"    mov r3.w, r0.z\n"
				"    mov r2.w, r0.w\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s1\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r4, t1, s4\n"
				"    texld r2, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r0, t1, s7\n"
				"    texld r1, t0, s1\n"
				"    mov r5.x, r4.x\n"
				"    mov r5.y, r2.x\n"
				"    mov r5.z, r3.x\n"
				"    mov r5.w, r0.x\n"
				"    dp4 r0.x, r1, r5\n"
				"    mov r5.x, r4.y\n"
				"    mov r5.y, r2.y\n"
				"    mov r5.z, r3.y\n"
				"    mov r5.w, r0.y\n"
				"    dp4 r0.y, r1, r5\n"
				"    mov r3.x, r4.z\n"
				"    mov r2.x, r4.w\n"
				"    mov r3.y, r2.z\n"
				"    mov r2.y, r2.w\n"
				"    mov r2.z, r3.w\n"
				"    mov r3.w, r0.z\n"
				"    mov r2.w, r0.w\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:1:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s2\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r4, t1, s4\n"
				"    texld r2, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r0, t1, s7\n"
				"    texld r1, t0, s2\n"
				"    mov r5.x, r4.x\n"
				"    mov r5.y, r2.x\n"
				"    mov r5.z, r3.x\n"
				"    mov r5.w, r0.x\n"
				"    dp4 r0.x, r1, r5\n"
				"    mov r5.x, r4.y\n"
				"    mov r5.y, r2.y\n"
				"    mov r5.z, r3.y\n"
				"    mov r5.w, r0.y\n"
				"    dp4 r0.y, r1, r5\n"
				"    mov r3.x, r4.z\n"
				"    mov r2.x, r4.w\n"
				"    mov r3.y, r2.z\n"
				"    mov r2.y, r2.w\n"
				"    mov r2.z, r3.w\n"
				"    mov r3.w, r0.z\n"
				"    mov r2.w, r0.w\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:2:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r4, t1, s4\n"
				"    texld r2, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r0, t1, s7\n"
				"    texld r1, t0, s3\n"
				"    mov r5.x, r4.x\n"
				"    mov r5.y, r2.x\n"
				"    mov r5.z, r3.x\n"
				"    mov r5.w, r0.x\n"
				"    dp4 r0.x, r1, r5\n"
				"    mov r5.x, r4.y\n"
				"    mov r5.y, r2.y\n"
				"    mov r5.z, r3.y\n"
				"    mov r5.w, r0.y\n"
				"    dp4 r0.y, r1, r5\n"
				"    mov r3.x, r4.z\n"
				"    mov r2.x, r4.w\n"
				"    mov r3.y, r2.z\n"
				"    mov r2.y, r2.w\n"
				"    mov r2.z, r3.w\n"
				"    mov r3.w, r0.z\n"
				"    mov r2.w, r0.w\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:3:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_ps20 = &__oneway_matmult_4x4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX7, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX6, RECT;\n"
				"MOVR R2.w, R0.w;\n"
				"MOVR R2.z, R1.w;\n"
				"MOVR R3.w, R0.z;\n"
				"MOVR R3.z, R1.z;\n"
				"TEX R4, f[TEX1].xyxx, TEX5, RECT;\n"
				"TEX R5, f[TEX1].xyxx, TEX4, RECT;\n"
				"MOVR R2.y, R4.w;\n"
				"MOVR R2.x, R5.w;\n"
				"MOVR R3.y, R4.z;\n"
				"MOVR R3.x, R5.z;\n"
				"MOVR R6.w, R0.y;\n"
				"MOVR R6.z, R1.y;\n"
				"MOVR R6.y, R4.y;\n"
				"MOVR R6.x, R5.y;\n"
				"MOVR R0.w, R0.x;\n"
				"MOVR R0.z, R1.x;\n"
				"MOVR R0.y, R4.x;\n"
				"MOVR R0.x, R5.x;\n"
				"TEX R1, f[TEX0].xyxx, TEX0, RECT;\n"
				"DP4R R2.x, R1, R2;\n"
				"DP4R R2.y, R1, R3;\n"
				"DP4R R2.z, R1, R6;\n"
				"DP4R R0.x, R1, R0;\n"
				"MOVR o[COLR].w, R2.x;\n"
				"MOVR o[COLR].z, R2.y;\n"
				"MOVR o[COLR].y, R2.z;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_1 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX7, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX6, RECT;\n"
				"MOVR R2.w, R0.w;\n"
				"MOVR R2.z, R1.w;\n"
				"MOVR R3.w, R0.z;\n"
				"MOVR R3.z, R1.z;\n"
				"TEX R4, f[TEX1].xyxx, TEX5, RECT;\n"
				"TEX R5, f[TEX1].xyxx, TEX4, RECT;\n"
				"MOVR R2.y, R4.w;\n"
				"MOVR R2.x, R5.w;\n"
				"MOVR R3.y, R4.z;\n"
				"MOVR R3.x, R5.z;\n"
				"MOVR R6.w, R0.y;\n"
				"MOVR R6.z, R1.y;\n"
				"MOVR R6.y, R4.y;\n"
				"MOVR R6.x, R5.y;\n"
				"MOVR R0.w, R0.x;\n"
				"MOVR R0.z, R1.x;\n"
				"MOVR R0.y, R4.x;\n"
				"MOVR R0.x, R5.x;\n"
				"TEX R1, f[TEX0].xyxx, TEX1, RECT;\n"
				"DP4R R2.x, R1, R2;\n"
				"DP4R R2.y, R1, R3;\n"
				"DP4R R2.z, R1, R6;\n"
				"DP4R R0.x, R1, R0;\n"
				"MOVR o[COLR].w, R2.x;\n"
				"MOVR o[COLR].z, R2.y;\n"
				"MOVR o[COLR].y, R2.z;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_2 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX7, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX6, RECT;\n"
				"MOVR R2.w, R0.w;\n"
				"MOVR R2.z, R1.w;\n"
				"MOVR R3.w, R0.z;\n"
				"MOVR R3.z, R1.z;\n"
				"TEX R4, f[TEX1].xyxx, TEX5, RECT;\n"
				"TEX R5, f[TEX1].xyxx, TEX4, RECT;\n"
				"MOVR R2.y, R4.w;\n"
				"MOVR R2.x, R5.w;\n"
				"MOVR R3.y, R4.z;\n"
				"MOVR R3.x, R5.z;\n"
				"MOVR R6.w, R0.y;\n"
				"MOVR R6.z, R1.y;\n"
				"MOVR R6.y, R4.y;\n"
				"MOVR R6.x, R5.y;\n"
				"MOVR R0.w, R0.x;\n"
				"MOVR R0.z, R1.x;\n"
				"MOVR R0.y, R4.x;\n"
				"MOVR R0.x, R5.x;\n"
				"TEX R1, f[TEX0].xyxx, TEX2, RECT;\n"
				"DP4R R2.x, R1, R2;\n"
				"DP4R R2.y, R1, R3;\n"
				"DP4R R2.z, R1, R6;\n"
				"DP4R R0.x, R1, R0;\n"
				"MOVR o[COLR].w, R2.x;\n"
				"MOVR o[COLR].z, R2.y;\n"
				"MOVR o[COLR].y, R2.z;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_3 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX7, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX6, RECT;\n"
				"MOVR R2.w, R0.w;\n"
				"MOVR R2.z, R1.w;\n"
				"MOVR R3.w, R0.z;\n"
				"MOVR R3.z, R1.z;\n"
				"TEX R4, f[TEX1].xyxx, TEX5, RECT;\n"
				"TEX R5, f[TEX1].xyxx, TEX4, RECT;\n"
				"MOVR R2.y, R4.w;\n"
				"MOVR R2.x, R5.w;\n"
				"MOVR R3.y, R4.z;\n"
				"MOVR R3.x, R5.z;\n"
				"MOVR R6.w, R0.y;\n"
				"MOVR R6.z, R1.y;\n"
				"MOVR R6.y, R4.y;\n"
				"MOVR R6.x, R5.y;\n"
				"MOVR R0.w, R0.x;\n"
				"MOVR R0.z, R1.x;\n"
				"MOVR R0.y, R4.x;\n"
				"MOVR R0.x, R5.x;\n"
				"TEX R1, f[TEX0].xyxx, TEX3, RECT;\n"
				"DP4R R2.x, R1, R2;\n"
				"DP4R R2.y, R1, R3;\n"
				"DP4R R2.z, R1, R6;\n"
				"DP4R R0.x, R1, R0;\n"
				"MOVR o[COLR].w, R2.x;\n"
				"MOVR o[COLR].z, R2.y;\n"
				"MOVR o[COLR].y, R2.z;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_fp30 = &__oneway_matmult_4x4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r4, t1, texture[4], RECT;\n"
				"TEX r2, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r0, t1, texture[7], RECT;\n"
				"TEX r1, t0, texture[0], RECT;\n"
				"MOV r5.x, r4.x;\n"
				"MOV r5.y, r2.x;\n"
				"MOV r5.z, r3.x;\n"
				"MOV r5.w, r0.x;\n"
				"DP4 r0.x, r1, r5;\n"
				"MOV r5.x, r4.y;\n"
				"MOV r5.y, r2.y;\n"
				"MOV r5.z, r3.y;\n"
				"MOV r5.w, r0.y;\n"
				"DP4 r0.y, r1, r5;\n"
				"MOV r3.x, r4.z;\n"
				"MOV r2.x, r4.w;\n"
				"MOV r3.y, r2.z;\n"
				"MOV r2.y, r2.w;\n"
				"MOV r2.z, r3.w;\n"
				"MOV r3.w, r0.z;\n"
				"MOV r2.w, r0.w;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r4, t1, texture[4], RECT;\n"
				"TEX r2, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r0, t1, texture[7], RECT;\n"
				"TEX r1, t0, texture[1], RECT;\n"
				"MOV r5.x, r4.x;\n"
				"MOV r5.y, r2.x;\n"
				"MOV r5.z, r3.x;\n"
				"MOV r5.w, r0.x;\n"
				"DP4 r0.x, r1, r5;\n"
				"MOV r5.x, r4.y;\n"
				"MOV r5.y, r2.y;\n"
				"MOV r5.z, r3.y;\n"
				"MOV r5.w, r0.y;\n"
				"DP4 r0.y, r1, r5;\n"
				"MOV r3.x, r4.z;\n"
				"MOV r2.x, r4.w;\n"
				"MOV r3.y, r2.z;\n"
				"MOV r2.y, r2.w;\n"
				"MOV r2.z, r3.w;\n"
				"MOV r3.w, r0.z;\n"
				"MOV r2.w, r0.w;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r4, t1, texture[4], RECT;\n"
				"TEX r2, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r0, t1, texture[7], RECT;\n"
				"TEX r1, t0, texture[2], RECT;\n"
				"MOV r5.x, r4.x;\n"
				"MOV r5.y, r2.x;\n"
				"MOV r5.z, r3.x;\n"
				"MOV r5.w, r0.x;\n"
				"DP4 r0.x, r1, r5;\n"
				"MOV r5.x, r4.y;\n"
				"MOV r5.y, r2.y;\n"
				"MOV r5.z, r3.y;\n"
				"MOV r5.w, r0.y;\n"
				"DP4 r0.y, r1, r5;\n"
				"MOV r3.x, r4.z;\n"
				"MOV r2.x, r4.w;\n"
				"MOV r3.y, r2.z;\n"
				"MOV r2.y, r2.w;\n"
				"MOV r2.z, r3.w;\n"
				"MOV r3.w, r0.z;\n"
				"MOV r2.w, r0.w;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r4, t1, texture[4], RECT;\n"
				"TEX r2, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r0, t1, texture[7], RECT;\n"
				"TEX r1, t0, texture[3], RECT;\n"
				"MOV r5.x, r4.x;\n"
				"MOV r5.y, r2.x;\n"
				"MOV r5.z, r3.x;\n"
				"MOV r5.w, r0.x;\n"
				"DP4 r0.x, r1, r5;\n"
				"MOV r5.x, r4.y;\n"
				"MOV r5.y, r2.y;\n"
				"MOV r5.z, r3.y;\n"
				"MOV r5.w, r0.y;\n"
				"DP4 r0.y, r1, r5;\n"
				"MOV r3.x, r4.z;\n"
				"MOV r2.x, r4.w;\n"
				"MOV r3.y, r2.z;\n"
				"MOV r2.y, r2.w;\n"
				"MOV r2.z, r3.w;\n"
				"MOV r3.w, r0.z;\n"
				"MOV r2.w, r0.w;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_arb = &__oneway_matmult_4x4_arb_desc;
}

void  oneway_matmult_4x4 (::brook::stream a,
		::brook::stream b,
		::brook::stream result) {
  static const void *__oneway_matmult_4x4_fp[] = {
     "fp30", __oneway_matmult_4x4_fp30,
     "arb", __oneway_matmult_4x4_arb,
     "ps20", __oneway_matmult_4x4_ps20,
     NULL, NULL };
  static brook::kernel k(__oneway_matmult_4x4_fp);

  k->PushStream(a);
  k->PushStream(b);
  k->PushOutput(result);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_pretransposed_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r0, t1, s4\n"
				"    texld r1, t0, s0\n"
				"    texld r4, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r2, t1, s7\n"
				"    dp4 r0.x, r1, r0\n"
				"    dp4 r0.y, r1, r4\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s1\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r0, t1, s4\n"
				"    texld r1, t0, s1\n"
				"    texld r4, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r2, t1, s7\n"
				"    dp4 r0.x, r1, r0\n"
				"    dp4 r0.y, r1, r4\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:1:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s2\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r0, t1, s4\n"
				"    texld r1, t0, s2\n"
				"    texld r4, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r2, t1, s7\n"
				"    dp4 r0.x, r1, r0\n"
				"    dp4 r0.y, r1, r4\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:2:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    dcl_2d s5\n"
				"    dcl_2d s6\n"
				"    dcl_2d s7\n"
				"    texld r0, t1, s4\n"
				"    texld r1, t0, s3\n"
				"    texld r4, t1, s5\n"
				"    texld r3, t1, s6\n"
				"    texld r2, t1, s7\n"
				"    dp4 r0.x, r1, r0\n"
				"    dp4 r0.y, r1, r4\n"
				"    dp4 r0.z, r1, r3\n"
				"    dp4 r0.w, r1, r2\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//s:0:a\n"
				"//s:0:b\n"
				"//o:0:result\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:3:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_pretransposed_ps20 = &__oneway_matmult_4x4_pretransposed_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_pretransposed_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX7, RECT;\n"
				"DP4R R1.x, R0, R1;\n"
				"TEX R2, f[TEX1].xyxx, TEX6, RECT;\n"
				"TEX R3, f[TEX1].xyxx, TEX5, RECT;\n"
				"DP4R R1.y, R0, R2;\n"
				"DP4R R1.z, R0, R3;\n"
				"MOVR o[COLR].w, R1.x;\n"
				"MOVR o[COLR].z, R1.y;\n"
				"MOVR o[COLR].y, R1.z;\n"
				"TEX R1, f[TEX1].xyxx, TEX4, RECT;\n"
				"DP4R R0.x, R0, R1;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_1 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX1, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX7, RECT;\n"
				"DP4R R1.x, R0, R1;\n"
				"TEX R2, f[TEX1].xyxx, TEX6, RECT;\n"
				"TEX R3, f[TEX1].xyxx, TEX5, RECT;\n"
				"DP4R R1.y, R0, R2;\n"
				"DP4R R1.z, R0, R3;\n"
				"MOVR o[COLR].w, R1.x;\n"
				"MOVR o[COLR].z, R1.y;\n"
				"MOVR o[COLR].y, R1.z;\n"
				"TEX R1, f[TEX1].xyxx, TEX4, RECT;\n"
				"DP4R R0.x, R0, R1;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_2 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX2, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX7, RECT;\n"
				"DP4R R1.x, R0, R1;\n"
				"TEX R2, f[TEX1].xyxx, TEX6, RECT;\n"
				"TEX R3, f[TEX1].xyxx, TEX5, RECT;\n"
				"DP4R R1.y, R0, R2;\n"
				"DP4R R1.z, R0, R3;\n"
				"MOVR o[COLR].w, R1.x;\n"
				"MOVR o[COLR].z, R1.y;\n"
				"MOVR o[COLR].y, R1.z;\n"
				"TEX R1, f[TEX1].xyxx, TEX4, RECT;\n"
				"DP4R R0.x, R0, R1;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.1.0003, build date Jul  7 2003  11:55:19\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.__structsampler0_a : TEXUNIT0\n"
				"#semantic main.__structsampler1_a : TEXUNIT1\n"
				"#semantic main.__structsampler2_a : TEXUNIT2\n"
				"#semantic main.__structsampler3_a : TEXUNIT3\n"
				"#semantic main.__structsampler0_b : TEXUNIT4\n"
				"#semantic main.__structsampler1_b : TEXUNIT5\n"
				"#semantic main.__structsampler2_b : TEXUNIT6\n"
				"#semantic main.__structsampler3_b : TEXUNIT7\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT __structsampler0_a : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT __structsampler1_a : TEXUNIT1 : texunit 1 : 1 : 1\n"
				"#var samplerRECT __structsampler2_a : TEXUNIT2 : texunit 2 : 2 : 1\n"
				"#var samplerRECT __structsampler3_a : TEXUNIT3 : texunit 3 : 3 : 1\n"
				"#var float2 _tex_a_pos : $vin.TEXCOORD0 : TEXCOORD0 : 4 : 1\n"
				"#var samplerRECT __structsampler0_b : TEXUNIT4 : texunit 4 : 5 : 1\n"
				"#var samplerRECT __structsampler1_b : TEXUNIT5 : texunit 5 : 6 : 1\n"
				"#var samplerRECT __structsampler2_b : TEXUNIT6 : texunit 6 : 7 : 1\n"
				"#var samplerRECT __structsampler3_b : TEXUNIT7 : texunit 7 : 8 : 1\n"
				"#var float2 _tex_b_pos : $vin.TEXCOORD1 : TEXCOORD1 : 9 : 1\n"
				"#var float4 __output_3 : $vout.COLOR0 : COLOR0 : 10 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX3, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX7, RECT;\n"
				"DP4R R1.x, R0, R1;\n"
				"TEX R2, f[TEX1].xyxx, TEX6, RECT;\n"
				"TEX R3, f[TEX1].xyxx, TEX5, RECT;\n"
				"DP4R R1.y, R0, R2;\n"
				"DP4R R1.z, R0, R3;\n"
				"MOVR o[COLR].w, R1.x;\n"
				"MOVR o[COLR].z, R1.y;\n"
				"MOVR o[COLR].y, R1.z;\n"
				"TEX R1, f[TEX1].xyxx, TEX4, RECT;\n"
				"DP4R R0.x, R0, R1;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_pretransposed_fp30 = &__oneway_matmult_4x4_pretransposed_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __oneway_matmult_4x4_pretransposed_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[4], RECT;\n"
				"TEX r1, t0, texture[0], RECT;\n"
				"TEX r4, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r2, t1, texture[7], RECT;\n"
				"DP4 r0.x, r1, r0;\n"
				"DP4 r0.y, r1, r4;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[4], RECT;\n"
				"TEX r1, t0, texture[1], RECT;\n"
				"TEX r4, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r2, t1, texture[7], RECT;\n"
				"DP4 r0.x, r1, r0;\n"
				"DP4 r0.y, r1, r4;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 1)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[4], RECT;\n"
				"TEX r1, t0, texture[2], RECT;\n"
				"TEX r4, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r2, t1, texture[7], RECT;\n"
				"DP4 r0.x, r1, r0;\n"
				"DP4 r0.y, r1, r4;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 2)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[4], RECT;\n"
				"TEX r1, t0, texture[3], RECT;\n"
				"TEX r4, t1, texture[5], RECT;\n"
				"TEX r3, t1, texture[6], RECT;\n"
				"TEX r2, t1, texture[7], RECT;\n"
				"DP4 r0.x, r1, r0;\n"
				"DP4 r0.y, r1, r4;\n"
				"DP4 r0.z, r1, r3;\n"
				"DP4 r0.w, r1, r2;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##s:0:a\n"
				"##s:0:b\n"
				"##o:0:result\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.sampler(1, 1)
				.sampler(1, 2)
				.sampler(1, 3)
				.sampler(2, 0)
				.sampler(2, 1)
				.sampler(2, 2)
				.sampler(2, 3)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(3, 3)
			)
		);
	static const void* __oneway_matmult_4x4_pretransposed_arb = &__oneway_matmult_4x4_pretransposed_arb_desc;
}

void  oneway_matmult_4x4_pretransposed (::brook::stream a,
		::brook::stream b,
		::brook::stream result) {
  static const void *__oneway_matmult_4x4_pretransposed_fp[] = {
     "fp30", __oneway_matmult_4x4_pretransposed_fp30,
     "arb", __oneway_matmult_4x4_pretransposed_arb,
     "ps20", __oneway_matmult_4x4_pretransposed_ps20,
     NULL, NULL };
  static brook::kernel k(__oneway_matmult_4x4_pretransposed_fp);

  k->PushStream(a);
  k->PushStream(b);
  k->PushOutput(result);
  k->Map();

}

static void fillEntry( float* outEntry, float inValue )
{
  float* e = outEntry;
  *e++ = inValue;
  *e++ = 0.0f;
  *e++ = 0.0f;
  *e++ = 0.0f;

  *e++ = 0.0f;
  *e++ = inValue;
  *e++ = 0.0f;
  *e++ = 0.0f;

  *e++ = 0.0f;
  *e++ = 0.0f;
  *e++ = inValue;
  *e++ = 0.0f;

  *e++ = 0.0f;
  *e++ = 0.0f;
  *e++ = 0.0f;
  *e++ = inValue;
}

static void matrixFill( float* outBuffer, int inSize )
{
  int i,j;
  float* b = outBuffer;
  for( i = 0; i < inSize; i++ )
  {
    for( j = 0; j < inSize; j++ )
    {
      fillEntry( b, (float)(i % 16) );
      b += 16;
    }
  }
}

static void checkEntry( float* inEntry, float inValue )
{
  float* e = inEntry;
  
  if( *e++ != inValue ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);

  if( *e++ != 0.0f ) assert(false);
  if( *e++ != inValue ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);

  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != inValue ) assert(false);
  if( *e++ != 0.0f ) assert(false);

  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != 0.0f ) assert(false);
  if( *e++ != inValue ) assert(false);
}

static void matrixCheck( float* inBuffer, int inSize )
{
  int i,j;
  int f;
  float* b = inBuffer;
  for( i = 0; i < inSize; i++ )
  {
    for( j = 0; j < inSize; j++ )
    {
      f = (i % 16) * (i % 16);
      checkEntry( b, (float)(f) );
      b += 16;
    }
  }
}

static void  runTest(int  inSize, int  inIterations, int  *outTime, float  *outFlops)
{
  ::brook::stream a(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream b(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream c(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  matrix4  *data;
  int  i;
  int  startTime;
  int  stopTime;
  int  elapsed;

  data = (matrix4 *) (malloc(inSize * inSize * sizeof(matrix4 ) ));
  matrixFill((float *) (data),inSize);
  startTime = GetTimeMillis();
  streamRead(a,data);
  streamRead(b,data);
  for (i = 0; i < inIterations; i++)
  {
    oneway_matmult_4x4(a,b,c);
  }

  streamWrite(c,data);
  stopTime = GetTimeMillis();
  elapsed = (int ) (stopTime - startTime);
  *outTime = elapsed;
  *outFlops = 0.001f * 23.000000f * inIterations * inSize * inSize / (float ) (elapsed);
  matrixCheck((float *) (data),inSize);
}

static void  runPretransposedTest(int  inSize, int  inIterations, int  *outTime, float  *outFlops)
{
  ::brook::stream a(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream b(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  ::brook::stream c(getStreamTypeMatrix4(( matrix4  *)0), inSize , inSize,-1);
  matrix4  *data;
  int  i;
  int  startTime;
  int  stopTime;
  int  elapsed;

  data = (matrix4 *) (malloc(inSize * inSize * sizeof(matrix4 ) ));
  matrixFill((float *) (data),inSize);
  startTime = GetTimeMillis();
  streamRead(a,data);
  streamRead(b,data);
  for (i = 0; i < inIterations; i++)
  {
    oneway_matmult_4x4_pretransposed(a,b,c);
  }

  streamWrite(c,data);
  stopTime = GetTimeMillis();
  elapsed = (int ) (stopTime - startTime);
  *outTime = elapsed;
  *outFlops = 0.001f * 23.000000f * inIterations * inSize * inSize / (float ) (elapsed);
//  matrixCheck((float *) (data),inSize);
}

#define MAX_ITERS 1000


void  Matmult4x4_1way_Time(int  inStreamSize)
{
  int  time;
  float  flops;
//  int  pretransposedTime;
//  float  pretransposedFlops;

  runTest(inStreamSize,MAX_ITERS,&time,&flops);
//  runPretransposedTest(inStreamSize,MAX_ITERS,&pretransposedTime,&pretransposedFlops);
  printf("matmult4x4 1-way\n");
  printf("stream size = %d * %d * 4*float4\n",inStreamSize,inStreamSize);
//  printf("\n\n");
//  printf("default\n");
  printf("%4d  %9d  %f",MAX_ITERS,time, flops);
//  printf("\n\n");
//  printf("pretransposed\n");
//  printf("%4d  %9d  %5.6f",MAX_ITERS,pretransposedTime,pretransposedFlops);
}


