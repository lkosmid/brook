
#include <stdio.h>
#include <stdlib.h>


#define MAX_NZ_PER_ROW  7
#define NUM_ROWS        200
#define MAX_NZ          (NUM_ROWS*MAX_NZ_PER_ROW)


/*** Kernels needed for Sparse Matrix-Vector multiplication *****************************************/

kernel void mult(float a<>, float b<>, out float c<>) {
  c = a*b;
}

kernel void sparse_matmult_product( float index<>, float x[][], float A<>, out float result<> )
{
  result = x[index][0] * A;
}


/*** Kernels called in the CG iterations ************************************************************/


kernel void square(float a<>, out float b<>) {
  b = a*a;
}

kernel void scaleAdd(float a<>, float b<>, float scale, out float c<>) {
  c = a + (scale*b);
}

void kernel subtract(float a<>, float b<>, out float c<>) {
  c = a - b;
}

void kernel copy(float a<>, out float b<>) {
  b = a;
}

reduce void sum(float a<>, reduce float result) {
  result += a;
}


/******************************************************************************************************/


void createCSRFromPoisson(int size, int dim, float nz[MAX_NZ], int cols[MAX_NZ], int rowStart[NUM_ROWS+1]) {

  int nnzPerRow = 0, matSize = 0;
  int i=0,j=0;
  int offsets[7][2];
  int nnz = 0;
  int idx = 0;

  switch (dim) {
    case 1:
      nnzPerRow = 3;
      matSize = size;
      offsets[0][0] = -1; offsets[0][1] = -1;
      offsets[1][0] = 0; offsets[1][1] = 2;
      offsets[2][0] = 1; offsets[2][1] = -1;
      break;
            
    case 2:
      nnzPerRow = 5;
      matSize = size*size;
      offsets[0][0] = -size; offsets[0][1] = -1;
      offsets[1][0] = -1; offsets[1][1] = -1;
      offsets[2][0] = 0; offsets[2][1] = 4;
      offsets[3][0] = 1; offsets[3][1] = -1;
      offsets[4][0] = size; offsets[4][1] = -1;
      break;
    case 3:
      nnzPerRow = 7;
      matSize = size*size*size;
      offsets[0][0] = -size*size; offsets[0][1] = -1;
      offsets[1][0] = -size; offsets[1][1] = -1;
      offsets[2][0] = -1; offsets[2][1] = -1;
      offsets[3][0] = 0; offsets[3][1] = 6;
      offsets[4][0] = 1; offsets[4][1] = -1;
      offsets[5][0] = size; offsets[5][1] = -1;
      offsets[6][0] = size*size; offsets[6][1] = -1;
      break;

    default: printf("Error in createCSRFromPoisson()\n"); return;
  }

  for (i=0;i<matSize;i++) {
    for (j=0;j<nnzPerRow;j++) {
      int col = i+offsets[j][0];        
      if (col >= 0 && col < matSize)
        nnz++;
    }
  }

  rowStart[0] = 0;

  for (i=0;i<matSize;i++) {
    for (j=0;j<nnzPerRow;j++) {
      int col = i+offsets[j][0];
      if (col>= 0 && col < matSize) {
        nz[idx] = (float)offsets[j][1];
        cols[idx] = col;
        idx++;
      }
    }
    rowStart[i+1] = idx;
  }

}


// take a standard CSR storage representation and turn it into a padded version for streaming
void reshuffleData(float nz[MAX_NZ], int cols[MAX_NZ], int rowStart[NUM_ROWS+1],
                   float Anz[MAX_NZ], float Acols[MAX_NZ]) {
  int i,j;

  for (i=0;i<NUM_ROWS;i++) {
    int offset = 0;

    for (j=rowStart[i];j<rowStart[i+1];j++) {
      Anz[MAX_NZ_PER_ROW*i + offset] = nz[j];
      Acols[MAX_NZ_PER_ROW*i + offset] = (float)cols[j];
      offset++;
    }
  
    // must pad the rest of the row
    while (offset < MAX_NZ_PER_ROW) {
      Anz[MAX_NZ_PER_ROW*i + offset] = 0.0f;
      Acols[MAX_NZ_PER_ROW*i + offset] = (float)0.0f;   // this should be an invalid index.... but doesn't have to be since x multiplied by a zero here
      offset++;
    }
  }

}

int parseCmdLine(int argc, char** argv, char* filename, int* it_max, float* eps) {
  
  if (argc < 3) {
    printf("it_max and eps arguments.\n");
    return 1;
  }

  *it_max = atoi(argv[1]);
  *eps = (float)atof(argv[2]);

  return 0;

}


int main(int argc, char** argv) {

  int i;

  char filename[80];

  int it, it_max;
  float eps;
  float alpha, resNew, resOld, convergeThresh;

  float  Anz[MAX_NZ];
  float  cIdx[MAX_NZ];
  float  x[NUM_ROWS];
  float  b[NUM_ROWS];
  //float  zeros[NUM_ROWS];
  //float  tmp[NUM_ROWS];

  float  AStrm<NUM_ROWS,MAX_NZ_PER_ROW>;
  float  cIdxStrm<NUM_ROWS,MAX_NZ_PER_ROW>;
  float  productsStrm<NUM_ROWS,MAX_NZ_PER_ROW>;
  float  vecGatherStrm<NUM_ROWS,MAX_NZ_PER_ROW>;

  float  xStrm<NUM_ROWS,1>;
  float  bStrm<NUM_ROWS,1>;


  float  rStrm<NUM_ROWS,1>;
  float  qStrm<NUM_ROWS,1>;
  float  dStrm<NUM_ROWS,1>;
  float  tmpStrm<NUM_ROWS,1>;
  


  float  csrNz[MAX_NZ];
  int    csrCols[MAX_NZ];
  int    csrRowStart[NUM_ROWS+1];

  if (parseCmdLine(argc, argv, filename, &it_max, &eps))
    return 1;

  // load the CSR matrix structure here //////////////////////////////////////////

  /*
  FILE* data;
  data = fopen(filename, "r");
  
  if (!data) {
    printf("Couldn't open CSR data file: %s\n", filename);
    return 1;
  }

  for (i=0;i<NUM_ROWS+1;i++)
    fscanf(data, "%d", &csrRowStart[i]);

  for (i=0;i<csrRowStart[NUM_ROWS];i++)
    fscanf(data, "%d", &csrCols[i]);

  for (i=0;i<csrRowStart[NUM_ROWS];i++)
    fscanf(data, "%f", &csrNz[i]);
  
  printf("CSR Sparse Matrix Form:  [value(col)]\n");
  for (i=0;i<NUM_ROWS;i++) {
    for (j=csrRowStart[i];j<csrRowStart[i+1];j++)
      printf("%.3f(%d)  ", csrNz[j], csrCols[j]);

    printf("\n");
  }
*/

  /////////////////////////////////////////////////////////////////////////////////

  createCSRFromPoisson(NUM_ROWS, 1, csrNz, csrCols, csrRowStart);

  // convert from pure CSR to a padded scheme better suited for streaming
  reshuffleData(csrNz, csrCols, csrRowStart, Anz, cIdx);

  //printf("\n");
  //printf("Padded Non-zero values:\n");
  //for (i=0;i<NUM_ROWS;i++) {
  //  for (j=0;j<MAX_NZ_PER_ROW;j++)
  //    printf("%3.3f ", Anz[i*MAX_NZ_PER_ROW + j]);
  //  printf("\n");
  //}

  //printf("\n");
  //printf("Padded Col Indices:\n");
  //for (i=0;i<NUM_ROWS;i++) {
  //  for (j=0;j<MAX_NZ_PER_ROW;j++)
  //    printf("%3.1f ", cIdx[i*MAX_NZ_PER_ROW + j]);
  //  printf("\n");
  //}
  
  // read in the matrix data
  streamRead(AStrm, Anz);
  streamRead(cIdxStrm, cIdx);
  
  /*
  streamRead(xStrm, x);

  // these four lines constitute a sparse matrix-vector multiply
  streamRead(yStrm, zeros);
  gather(cIdxStrm, xStrm, xStrmGather);
  mult(AStrm, xStrmGather, productsStrm);
  sumRows(productsStrm, yStrm); // be sure to set yStream values to 0.0f

  // yStream now holds the result of the matVect multiply
  
  streamWrite(yStrm, y);

  printf("\n");
  printf("result: y = Ax\n");
  for (i=0;i<NUM_ROWS;i++)
    printf("%.3f\n",y[i]);
  */


////////////////////////////////////////////////////////////////////////////////////////////////
// CG PART
////////////////////////////////////////////////////////////////////////////////////////////////

  printf("\n\n");

  // initial guess for x is zero.  Hard code some rhs for b
  for (i=0;i<NUM_ROWS;i++) {
    x[i] = 0.0f;
    b[i] = 50.0f;
//    zeros[i] = 0.0f;
  }


  // KAYVON: set 'eps', and 'it_max' here

  streamRead(xStrm, x);
  streamRead(bStrm, b);

  // Ax_0
  // these two lines constitute a sparse matrix-vector multiply
  sparse_matmult_product( cIdxStrm, xStrm, AStrm, productsStrm );
  sum( productsStrm, rStrm );

  // r = b - Ax
  subtract(bStrm, rStrm, rStrm);

  // d = r
  copy(rStrm, dStrm);

  // resNormNew = r dot r
  resNew = 0.0f;
  square(rStrm, tmpStrm);
  sum(tmpStrm, resNew);
  convergeThresh = eps * eps * resNew;

  printf("initial r norm = %f\n", resNew);
  printf("max it = %d\n", it_max);
  printf("eps = %f\n", eps);

  //printf("Initial d:\n");
  //streamWrite(dStrm, tmp);
  //for(i=0;i<NUM_ROWS;i++)
  //  printf("%.3f ", tmp[i]);
  //printf("\n");

  it = 0;
  // CG loop
  while (it < it_max && resNew > convergeThresh ) {

    if (it > 0)
	    scaleAdd(rStrm, dStrm, resNew / resOld, dStrm);

	  // q = Ad
    // these two lines constitute a sparse matrix-vector multiply
    sparse_matmult_product( cIdxStrm, dStrm, AStrm, productsStrm );
    sum( productsStrm, qStrm );

    //printf("qStrm:\n");
    //streamWrite(qStrm, tmp);
    //for(i=0;i<NUM_ROWS;i++)
    //  printf("%.3f ", tmp[i]);
    //printf("\n");

    // alpha = d dot q
	  mult(dStrm, qStrm, tmpStrm);

    //printf("tmpStrm:\n");
    //streamWrite(tmpStrm, tmp);
    //for(i=0;i<NUM_ROWS;i++)
    //  printf("%.3f ", tmp[i]);
    //printf("\n");

    sum(tmpStrm, alpha);
    //printf("alpha_i = %.3f\n", alpha);
	  alpha = resNew / alpha;
    //printf("alpha = %.3f\n", alpha);

	  // x = x + alpha * d 
	  scaleAdd(xStrm, dStrm, alpha, xStrm);

    //printf("new x:\n");
    //streamWrite(xStrm, tmp);
    //for(i=0;i<NUM_ROWS;i++)
    //  printf("%.3f ", tmp[i]);
    //printf("\n");

	  // r = r - alpha * q
	  scaleAdd(rStrm, qStrm, -1.0f * alpha, rStrm);

    //printf("new r:\n");
    //streamWrite(rStrm, tmp);
    //for(i=0;i<NUM_ROWS;i++)
    //  printf("%.3f ", tmp[i]);
    //printf("\n");

    // resNew = r dot r
    resOld = resNew;
	  square(rStrm, tmpStrm);
    sum(tmpStrm, resNew);

	  it++;
    printf("iteration %d.  Current residual norm: %f\n", it, resNew);
  }      


  streamWrite(xStrm, x);

  printf("\n");
  printf("Solution x:\n");
  for (i=0;i<NUM_ROWS;i++)
    printf("%.3f  " ,x[i]);

  printf("\n");
  

  return 0;
}

