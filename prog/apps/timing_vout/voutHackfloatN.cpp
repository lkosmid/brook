
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Mar 29 2004 17:20:37
////////////////////////////////////////////

#include <brook.hpp>
#include <stdio.h>

#include <stdlib.h>

unsigned int  debug_vout = 0;
#define debugStreamPrint(stream,title) if (debug_vout) { printf ("%s\n",title); streamPrint(stream,1);  printf ("\n\n"); }

extern ::brook::stream &quickAllocStream(const __BRTStreamType *t, int wid, int len, int garbage);
namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __kernelReadItem_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 0, 0, 0\n"
				"    dcl_2d s0\n"
				"    mov r1.xy, c1\n"
				"    mad r7.x, c0.x, r1.x, c0.z\n"
				"    mad r7.y, c0.y, r1.y, c0.w\n"
				"    texld r2, r7, s0\n"
				"    mov r2.yzw, c2.x\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//c:1:items\n"
				"//c:2:index\n"
				"//o:1:item\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __kernelReadItem_ps20 = &__kernelReadItem_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __kernelReadItem_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.items : TEXUNIT0\n"
				"#semantic main.__gatherconst_items : C0\n"
				"#semantic main.index : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var samplerRECT items[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_items : C0 :  : 1 : 1\n"
				"#var float2 index : C1 :  : 2 : 1\n"
				"#var float4 __workspace : C2 :  : 4 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE __gatherconst_items;\n"
				"DECLARE index;\n"
				"DECLARE __workspace;\n"
				"TEX o[COLR].x, index.xyxx, TEX0, RECT;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##c:1:items\n"
				"##c:2:index\n"
				"##o:1:item\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __kernelReadItem_fp30 = &__kernelReadItem_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __kernelReadItem_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r2;\n"
				"TEMP r7;\n"
				"MOV r1.xy, c1;\n"
				"MAD r7.x, c0.x, r1.x, c0.z;\n"
				"MAD r7.y, c0.y, r1.y, c0.w;\n"
				"TEX r2, r7, texture[0], RECT;\n"
				"MOV r2.yzw, c2.x;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##c:1:items\n"
				"##c:2:index\n"
				"##o:1:item\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __kernelReadItem_arb = &__kernelReadItem_arb_desc;
}

void __kernelReadItem_cpu_inner (const __BrtArray2d<__BrtFloat1  > &items,
                                  const __BrtFloat2  &index,
                                  __BrtFloat1  &item){
  item = items[index];
}
void  __kernelReadItem_cpu (const std::vector<void *>&args,
                            const std::vector<const unsigned int *>&extents,
                            const std::vector<unsigned int>&dims,
                            unsigned int mapbegin, 
                            unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __kernelReadItem_cpu_inner (
      arg0,
      *arg1,
      *arg2);
    i++;
    ++arg2;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  kernelReadItem (::brook::stream items,
		const float2  index,
		::brook::stream item) {
  static const void *__kernelReadItem_fp[] = {
     "fp30", __kernelReadItem_fp30,
     "arb", __kernelReadItem_arb,
     "ps20", __kernelReadItem_ps20,
     "cpu", (void *) __kernelReadItem_cpu,
     NULL, NULL };
  static __BRTKernel k(__kernelReadItem_fp);

  k->PushGatherStream(items);
  k->PushConstant(index);
  k->PushOutput(item);
  k->Map();

}


void  cpuGetIndexAt(float2  inputindex, float  shiftRight, float2  maxvalue, float2  *index)
{
  index->x = inputindex.x + shiftRight;
  index->y = inputindex.y + floor(index->x / maxvalue.x);
  index->x = fmod(index->x,maxvalue.x);
  if (index->x < 0)
    index->x += maxvalue.x;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __getIndexAt_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c3, 0.5, 0.25, 0, -0.5\n"
				"    mov r5.w, c1.x\n"
				"    add r0.w, c0.x, r5.w\n"
				"    add r7.w, r0.w, c3.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c2.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r1.w, r7.w, r11.w\n"
				"    frc r8.w, r6.w\n"
				"    mul r3.w, r8.w, c2.x\n"
				"    add r10.w, r3.w, c3.x\n"
				"    frc r5.w, r10.w\n"
				"    add r7.w, r10.w, -r5.w\n"
				"    add r9.w, -r7.w, c3.w\n"
				"    add r4.w, r7.w, c2.x\n"
				"    cmp r11.w, r9.w, r4.w, r7.w\n"
				"    add r6.w, r11.w, c3.y\n"
				"    add r3.w, r6.w, -c2.x\n"
				"    cmp r10.x, r3.w, c3.z, r11.w\n"
				"    frc r5.w, r1.w\n"
				"    add r1.w, r1.w, -r5.w\n"
				"    add r10.y, r1.w, c0.y\n"
				"    mov r10.zw, c3.z\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:4:inputindex\n"
				"//c:1:shiftRight\n"
				"//c:2:maxvalue\n"
				"//o:2:outputindex\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __getIndexAt_ps20 = &__getIndexAt_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __getIndexAt_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.inputindex : C0\n"
				"#semantic main.shiftRight : C1\n"
				"#semantic main.maxvalue : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var float4 inputindex : C0 :  : 0 : 1\n"
				"#var float shiftRight : C1 :  : 1 : 1\n"
				"#var float2 maxvalue : C2 :  : 2 : 1\n"
				"#var float4 __workspace : C3 :  : 4 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE inputindex;\n"
				"DECLARE shiftRight;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.x, shiftRight.x;\n"
				"ADDR R0.x, inputindex.x, R0.x;\n"
				"ADDR R0.y, {0.5}.x, R0.x;\n"
				"MOVR R1.x, R0.x;\n"
				"RCPR R0.x, maxvalue.x;\n"
				"MULR R0.x, R0.y, R0.x;\n"
				"FLRR R0.x, R0.x;\n"
				"ADDR R0.x, inputindex.y, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"ADDR R0.x, R1.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.x, R0.x, {-0.5}.x;\n"
				"MOVR R1.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), R0.x;\n"
				"ADDR R0.x, R1.x, {0.25}.x;\n"
				"SGER H0.x, R0.x, maxvalue.x;\n"
				"MOVR R0.xy, R1.xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {0}.x;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:inputindex\n"
				"##c:1:shiftRight\n"
				"##c:2:maxvalue\n"
				"##o:2:outputindex\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __getIndexAt_fp30 = &__getIndexAt_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __getIndexAt_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"MOV r5.w, c1.x;\n"
				"ADD r0.w, c0.x, r5.w;\n"
				"ADD r7.w, r0.w, c3.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c2.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r1.w, r7.w, r11.w;\n"
				"FRC r8.w, r6.w;\n"
				"MUL r3.w, r8.w, c2.x;\n"
				"ADD r10.w, r3.w, c3.x;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r7.w, r10.w, -r5.w;\n"
				"ADD r9.w, -r7.w, c3.w;\n"
				"ADD r4.w, r7.w, c2.x;\n"
				"CMP r11.w, r9.w, r7.w, r4.w;\n"
				"ADD r6.w, r11.w, c3.y;\n"
				"ADD r3.w, r6.w, -c2.x;\n"
				"CMP r10.x, r3.w, r11.w, c3.z;\n"
				"FRC r5.w, r1.w;\n"
				"ADD r1.w, r1.w, -r5.w;\n"
				"ADD r10.y, r1.w, c0.y;\n"
				"MOV r10.zw, c3.z;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:inputindex\n"
				"##c:1:shiftRight\n"
				"##c:2:maxvalue\n"
				"##o:2:outputindex\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __getIndexAt_arb = &__getIndexAt_arb_desc;
}

void __getIndexAt_cpu_inner (const __BrtFloat4  &inputindex,
                              const __BrtFloat1  &shiftRight,
                              const __BrtFloat2  &maxvalue,
                              __BrtFloat2  &outputindex){
  __BrtFloat2  index;

  index.mask1(inputindex.swizzle1(maskX) + shiftRight,maskX);
  index.mask1(inputindex.swizzle1(maskY) + __floor_cpu_inner((__BrtFloat1(0.500000f) + index.swizzle1(maskX)) / maxvalue.swizzle1(maskX)),maskY);
  index.mask1(__round_cpu_inner(__fmod_cpu_inner(__round_cpu_inner(index.swizzle1(maskX)),maxvalue.swizzle1(maskX))),maskX);
  if (index.swizzle1(maskX) <= -__BrtFloat1(0.500000f))
    index.mask1(index.swizzle1(maskX) + maxvalue.swizzle1(maskX),maskX);
  if (index.swizzle1(maskX) + __BrtFloat1(0.250000f) >= maxvalue.swizzle1(maskX))
    index.mask1(__BrtFloat1((float)0),maskX);
  outputindex = index;
}
void  __getIndexAt_cpu (const std::vector<void *>&args,
                        const std::vector<const unsigned int *>&extents,
                        const std::vector<unsigned int>&dims,
                        unsigned int mapbegin, 
                        unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat2 *arg2 = (__BrtFloat2 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[3];
  unsigned int newline=extents[3][dim-1];
  arg3+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __getIndexAt_cpu_inner (
      *arg0,
      *arg1,
      *arg2,
      *arg3);
    i++;
    ++arg3;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  getIndexAt (const float4  inputindex,
		const float  shiftRight,
		const float2  maxvalue,
		::brook::stream outputindex) {
  static const void *__getIndexAt_fp[] = {
     "fp30", __getIndexAt_fp30,
     "arb", __getIndexAt_arb,
     "ps20", __getIndexAt_ps20,
     "cpu", (void *) __getIndexAt_cpu,
     NULL, NULL };
  static __BRTKernel k(__getIndexAt_fp);

  k->PushConstant(inputindex);
  k->PushConstant(shiftRight);
  k->PushConstant(maxvalue);
  k->PushOutput(outputindex);
  k->Map();

}


const unsigned int  MAX_VOUT_STREAMS = 31;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateDividedIndex_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c3, 0.03125, 0, 0, 0\n"
				"    rcp r0.w, c1.x\n"
				"    mul r7.xy, r0.w, c0\n"
				"    frc r7.w, r7.y\n"
				"    mad r7.w, r7.w, c2.x, r7.x\n"
				"    add r2.w, r7.y, c3.x\n"
				"    add r9.w, r7.w, c3.x\n"
				"    rcp r4.w, c2.x\n"
				"    mul r11.w, r9.w, r4.w\n"
				"    frc r6.w, r11.w\n"
				"    mul r1.w, r6.w, c2.x\n"
				"    frc r8.w, r1.w\n"
				"    add r10.x, r1.w, -r8.w\n"
				"    frc r5.w, r2.w\n"
				"    add r10.y, r2.w, -r5.w\n"
				"    mov r10.zw, c3.w\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:4:index\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//o:2:newindex\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __calculateDividedIndex_ps20 = &__calculateDividedIndex_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateDividedIndex_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.index : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.length : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var float4 index : C0 :  : 0 : 1\n"
				"#var float modulus : C1 :  : 1 : 1\n"
				"#var float length : C2 :  : 2 : 1\n"
				"#var float4 __workspace : C3 :  : 4 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE index;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE __workspace;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.xy, index.xyxx, R0.x;\n"
				"FRCR R0.w, R0.y;\n"
				"MULR R0.w, R0.w, length.x;\n"
				"ADDR R0.w, R0.x, R0.w;\n"
				"ADDR R0.w, R0.w, {0.03125}.x;\n"
				"SLTR H0.x, R0.w, {0}.x;\n"
				"RCPR R1.x, length.x;\n"
				"MULR R1.x, R0.w, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |length.x|;\n"
				"MOVR R0.w, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.w(GT.x), -R1.x;\n"
				"FLRR R0.w, R0.w;\n"
				"MOVR R0.x, R0.w;\n"
				"ADDR R0.w, R0.y, {0.03125}.x;\n"
				"FLRR R0.w, R0.w;\n"
				"MOVR R1.x, R0.x;\n"
				"MOVR R1.y, R0.w;\n"
				"MOVR R1.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R1;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:index\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##o:2:newindex\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __calculateDividedIndex_fp30 = &__calculateDividedIndex_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateDividedIndex_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = {0.03125, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"RCP r0.w, c1.x;\n"
				"MUL r7.xy, r0.w, c0;\n"
				"FRC r7.w, r7.y;\n"
				"MAD r7.w, r7.w, c2.x, r7.x;\n"
				"ADD r2.w, r7.y, c3.x;\n"
				"ADD r9.w, r7.w, c3.x;\n"
				"RCP r4.w, c2.x;\n"
				"MUL r11.w, r9.w, r4.w;\n"
				"FRC r6.w, r11.w;\n"
				"MUL r1.w, r6.w, c2.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.x, r1.w, -r8.w;\n"
				"FRC r5.w, r2.w;\n"
				"ADD r10.y, r2.w, -r5.w;\n"
				"MOV r10.zw, c3.w;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:index\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##o:2:newindex\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.output(4, 0)
			)
		);
	static const void* __calculateDividedIndex_arb = &__calculateDividedIndex_arb_desc;
}

void __calculateDividedIndex_cpu_inner (const __BrtFloat4  &index,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         __BrtFloat2  &newindex){
  __BrtFloat1  epsilon = __BrtFloat1(1.000000f) / __BrtFloat1(32.000000f);

  newindex = __BrtFloat2 (index.swizzle1(maskX),index.swizzle1(maskY));
  newindex /= modulus;
  newindex.mask1(__floor_cpu_inner(__fmod_cpu_inner(newindex.swizzle1(maskX) + __frac_cpu_inner(newindex.swizzle1(maskY)) * length + epsilon,length)),maskX);
  newindex.mask1(__floor_cpu_inner(newindex.swizzle1(maskY) + epsilon),maskY);
}
void  __calculateDividedIndex_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[3];
  unsigned int newline=extents[3][dim-1];
  arg3+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __calculateDividedIndex_cpu_inner (
      *arg0,
      *arg1,
      *arg2,
      *arg3);
    i++;
    ++arg3;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  calculateDividedIndex (const float4  index,
		const float  modulus,
		const float  length,
		::brook::stream newindex) {
  static const void *__calculateDividedIndex_fp[] = {
     "fp30", __calculateDividedIndex_fp30,
     "arb", __calculateDividedIndex_arb,
     "ps20", __calculateDividedIndex_ps20,
     "cpu", (void *) __calculateDividedIndex_cpu,
     NULL, NULL };
  static __BRTKernel k(__calculateDividedIndex_fp);

  k->PushConstant(index);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushOutput(newindex);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateIndexModulus_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 0, 0, 0, 0\n"
				"    rcp r0.w, c1.x\n"
				"    mul r7.w, r0.w, c0.x\n"
				"    frc r2.w, r7.w\n"
				"    mul r9.w, r2.w, c1.x\n"
				"    mov r2.w, c3.x\n"
				"    mad r11.w, c0.y, r2.w, r9.w\n"
				"    mul r6.w, r0.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c1.x\n"
				"    add r10.w, r8.w, -c2.x\n"
				"    frc r5.w, r10.w\n"
				"    add r7.x, r10.w, -r5.w\n"
				"    mov r7.yzw, c4.x\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//c:4:index\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:lengthmodmodulus\n"
				"//o:1:which\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.output(5, 0)
			)
		);
	static const void* __calculateIndexModulus_ps20 = &__calculateIndexModulus_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateIndexModulus_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.index : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.offset : C2\n"
				"#semantic main.lengthmodmodulus : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var float4 index : C0 :  : 0 : 1\n"
				"#var float modulus : C1 :  : 1 : 1\n"
				"#var float offset : C2 :  : 2 : 1\n"
				"#var float lengthmodmodulus : C3 :  : 3 : 1\n"
				"#var float4 __workspace : C4 :  : 5 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"DECLARE index;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE __workspace;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, index.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"MOVR R0.y, {0}.x;\n"
				"SLTR H0.x, index.x, R0.y;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"MOVR R0.x, lengthmodmodulus.x;\n"
				"MADR R0.y, index.y, R0.x, R0.y;\n"
				"SLTR H0.x, R0.y, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R0.y, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -offset.x;\n"
				"FLRR o[COLR].x, R0.y;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:4:index\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:lengthmodmodulus\n"
				"##o:1:which\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.output(5, 0)
			)
		);
	static const void* __calculateIndexModulus_fp30 = &__calculateIndexModulus_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __calculateIndexModulus_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"RCP r0.w, c1.x;\n"
				"MUL r7.w, r0.w, c0.x;\n"
				"FRC r2.w, r7.w;\n"
				"MUL r9.w, r2.w, c1.x;\n"
				"MOV r2.w, c3.x;\n"
				"MAD r11.w, c0.y, r2.w, r9.w;\n"
				"MUL r6.w, r0.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c1.x;\n"
				"ADD r10.w, r8.w, -c2.x;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r7.x, r10.w, -r5.w;\n"
				"MOV r7.yzw, c4.x;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:4:index\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:lengthmodmodulus\n"
				"##o:1:which\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, 0)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.output(5, 0)
			)
		);
	static const void* __calculateIndexModulus_arb = &__calculateIndexModulus_arb_desc;
}

void __calculateIndexModulus_cpu_inner (const __BrtFloat4  &index,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &offset,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat1  &which){
  which = __floor_cpu_inner(__fmod_cpu_inner(index.swizzle1(maskY) * lengthmodmodulus + __fmod_cpu_inner(index.swizzle1(maskX),modulus),modulus) - offset);
}
void  __calculateIndexModulus_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  unsigned int dim=dims[4];
  unsigned int newline=extents[4][dim-1];
  arg4+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __calculateIndexModulus_cpu_inner (
      *arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4);
    i++;
    ++arg4;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  calculateIndexModulus (const float4  index,
		const float  modulus,
		const float  offset,
		const float  lengthmodmodulus,
		::brook::stream which) {
  static const void *__calculateIndexModulus_fp[] = {
     "fp30", __calculateIndexModulus_fp30,
     "arb", __calculateIndexModulus_arb,
     "ps20", __calculateIndexModulus_ps20,
     "cpu", (void *) __calculateIndexModulus_cpu,
     NULL, NULL };
  static __BRTKernel k(__calculateIndexModulus_fp);

  k->PushConstant(index);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(which);
  k->Map();

}


#define finite_float2(output) finite_float(output.x)

#define finite_float3(output) finite_float(output.x)

#define finite_float4(output) finite_float(output.x)

#define VECTOR_TEMPLATIZED_FUNCTIONS


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r9.x, -r0.w, r7.x, r0.x\n"
				"    mov r9.yzw, c0.x\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    max r6.w, -r9.w, r9.w\n"
				"    cmp r8.x, -r6.w, r2.x, r2.w\n"
				"    mov r8.yzw, c0.x\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    add r11.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r11.w, -r9.w, r9.w\n"
				"    cmp r9.w, -r9.w, r2.x, r2.w\n"
				"    rcp r6.w, r9.w\n"
				"    max r3.w, -r6.w, r6.w\n"
				"    cmp r5.x, -r3.w, r9.x, r9.w\n"
				"    mov r5.yzw, c0.x\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    add r11.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r11.w, -r9.w, r9.w\n"
				"    cmp r9.w, -r9.w, r2.x, r2.w\n"
				"    rcp r4.w, r9.w\n"
				"    add r1.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r1.w, -r4.w, r4.w\n"
				"    cmp r4.w, -r4.w, r9.x, r9.w\n"
				"    rcp r8.w, r4.w\n"
				"    max r5.w, -r8.w, r8.w\n"
				"    cmp r7.x, -r5.w, r4.x, r4.w\n"
				"    mov r7.yzw, c0.x\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    add r11.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r11.w, -r9.w, r9.w\n"
				"    cmp r9.w, -r9.w, r2.x, r2.w\n"
				"    rcp r4.w, r9.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    cmp r4.w, -r4.w, r9.x, r9.w\n"
				"    rcp r11.w, r4.w\n"
				"    add r8.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r8.w, -r11.w, r11.w\n"
				"    cmp r11.w, -r11.w, r4.x, r4.w\n"
				"    rcp r3.w, r11.w\n"
				"    max r0.w, -r3.w, r3.w\n"
				"    cmp r2.x, -r0.w, r11.x, r11.w\n"
				"    mov r2.yzw, c0.x\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    add r11.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r11.w, -r9.w, r9.w\n"
				"    cmp r9.w, -r9.w, r2.x, r2.w\n"
				"    rcp r4.w, r9.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    cmp r4.w, -r4.w, r9.x, r9.w\n"
				"    rcp r11.w, r4.w\n"
				"    add r1.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r1.w, -r11.w, r11.w\n"
				"    cmp r11.w, -r11.w, r4.x, r4.w\n"
				"    rcp r6.w, r11.w\n"
				"    add r3.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r3.w, -r6.w, r6.w\n"
				"    cmp r6.w, -r6.w, r11.x, r11.w\n"
				"    rcp r10.w, r6.w\n"
				"    max r7.w, -r10.w, r10.w\n"
				"    cmp r9.x, -r7.w, r6.x, r6.w\n"
				"    mov r9.yzw, c0.x\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl t7.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s0\n"
				"    texld r1, t7, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r2.w, -r0.w, r7.x, r0.x\n"
				"    rcp r9.w, r2.w\n"
				"    add r11.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r11.w, -r9.w, r9.w\n"
				"    cmp r9.w, -r9.w, r2.x, r2.w\n"
				"    rcp r4.w, r9.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    cmp r4.w, -r4.w, r9.x, r9.w\n"
				"    rcp r11.w, r4.w\n"
				"    add r1.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r1.w, -r11.w, r11.w\n"
				"    cmp r11.w, -r11.w, r4.x, r4.w\n"
				"    rcp r6.w, r11.w\n"
				"    add r8.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r8.w, -r6.w, r6.w\n"
				"    cmp r6.w, -r6.w, r11.x, r11.w\n"
				"    rcp r1.w, r6.w\n"
				"    add r10.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r10.w, -r1.w, r1.w\n"
				"    cmp r1.w, -r1.w, r6.x, r6.w\n"
				"    rcp r5.w, r1.w\n"
				"    max r2.w, -r5.w, r5.w\n"
				"    cmp r4.x, -r2.w, r1.x, r1.w\n"
				"    mov r4.yzw, c0.x\n"
				"    mov oC0, r4\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:input\n"
				"//s:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat_ps20 = &__valueProducedfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 5 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX1, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 6 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 7 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX3].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 8 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX4].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 9 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX5].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 10 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX6].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex___reduce7_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD7 : TEX7 : 10 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.x, f[TEX6].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX7].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.y;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), R2.x;\n"
				"MOVR R0.yzw, {0, 0, 0, 0}.yyzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat_fp30 = &__valueProducedfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r2;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r9.x, -r0.w, r0.x, r7.x;\n"
				"MOV r9.yzw, c0.x;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r2;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"MAX r6.w, -r9.w, r9.w;\n"
				"CMP r8.x, -r6.w, r2.w, r2.x;\n"
				"MOV r8.yzw, c0.x;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"ADD r11.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r11.w, r9.w, -r9.w;\n"
				"CMP r9.w, -r9.w, r2.w, r2.x;\n"
				"RCP r6.w, r9.w;\n"
				"MAX r3.w, -r6.w, r6.w;\n"
				"CMP r5.x, -r3.w, r9.w, r9.x;\n"
				"MOV r5.yzw, c0.x;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"ADD r11.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r11.w, r9.w, -r9.w;\n"
				"CMP r9.w, -r9.w, r2.w, r2.x;\n"
				"RCP r4.w, r9.w;\n"
				"ADD r1.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r1.w, r4.w, -r4.w;\n"
				"CMP r4.w, -r4.w, r9.w, r9.x;\n"
				"RCP r8.w, r4.w;\n"
				"MAX r5.w, -r8.w, r8.w;\n"
				"CMP r7.x, -r5.w, r4.w, r4.x;\n"
				"MOV r7.yzw, c0.x;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"ADD r11.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r11.w, r9.w, -r9.w;\n"
				"CMP r9.w, -r9.w, r2.w, r2.x;\n"
				"RCP r4.w, r9.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"CMP r4.w, -r4.w, r9.w, r9.x;\n"
				"RCP r11.w, r4.w;\n"
				"ADD r8.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r8.w, r11.w, -r11.w;\n"
				"CMP r11.w, -r11.w, r4.w, r4.x;\n"
				"RCP r3.w, r11.w;\n"
				"MAX r0.w, -r3.w, r3.w;\n"
				"CMP r2.x, -r0.w, r11.w, r11.x;\n"
				"MOV r2.yzw, c0.x;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"ADD r11.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r11.w, r9.w, -r9.w;\n"
				"CMP r9.w, -r9.w, r2.w, r2.x;\n"
				"RCP r4.w, r9.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"CMP r4.w, -r4.w, r9.w, r9.x;\n"
				"RCP r11.w, r4.w;\n"
				"ADD r1.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r1.w, r11.w, -r11.w;\n"
				"CMP r11.w, -r11.w, r4.w, r4.x;\n"
				"RCP r6.w, r11.w;\n"
				"ADD r3.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r3.w, r6.w, -r6.w;\n"
				"CMP r6.w, -r6.w, r11.w, r11.x;\n"
				"RCP r10.w, r6.w;\n"
				"MAX r7.w, -r10.w, r10.w;\n"
				"CMP r9.x, -r7.w, r6.w, r6.x;\n"
				"MOV r9.yzw, c0.x;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"ATTRIB t7 = fragment.texcoord[7];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[0], RECT;\n"
				"TEX r1, t7, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r2.w, -r0.w, r0.x, r7.x;\n"
				"RCP r9.w, r2.w;\n"
				"ADD r11.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r11.w, r9.w, -r9.w;\n"
				"CMP r9.w, -r9.w, r2.w, r2.x;\n"
				"RCP r4.w, r9.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"CMP r4.w, -r4.w, r9.w, r9.x;\n"
				"RCP r11.w, r4.w;\n"
				"ADD r1.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r1.w, r11.w, -r11.w;\n"
				"CMP r11.w, -r11.w, r4.w, r4.x;\n"
				"RCP r6.w, r11.w;\n"
				"ADD r8.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r8.w, r6.w, -r6.w;\n"
				"CMP r6.w, -r6.w, r11.w, r11.x;\n"
				"RCP r1.w, r6.w;\n"
				"ADD r10.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r10.w, r1.w, -r1.w;\n"
				"CMP r1.w, -r1.w, r6.w, r6.x;\n"
				"RCP r5.w, r1.w;\n"
				"MAX r2.w, -r5.w, r5.w;\n"
				"CMP r4.x, -r2.w, r1.w, r1.x;\n"
				"MOV r4.yzw, c0.x;\n"
				"MOV oC0, r4;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat_arb = &__valueProducedfloat_arb_desc;
}

void __valueProducedfloat_cpu_inner (const __BrtFloat1  &input,
                                      __BrtFloat1  &output){
  output = __isinf_cpu_inner(input.swizzle1(maskX)).questioncolon(output,input);
}
void  __valueProducedfloat__base_cpu_inner (const __BrtFloat1  &input,
                                            __BrtFloat1  &output) {
  output = input;
}
void  __valueProducedfloat__combine_cpu_inner (const __BrtFloat1  &input,
                                               __BrtFloat1  &output,
                                               __BrtFloat1  &__combiner) {
  __valueProducedfloat_cpu_inner (__combiner, output);
}
void  __valueProducedfloat_cpu (const std::vector<void *>&args,
                                const std::vector<const unsigned int *>&extents,
                                const std::vector<unsigned int>&dims,
                                unsigned int mapbegin, 
                                unsigned int mapextent) {
  __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int i=0; 
  if (mapextent) {
    __valueProducedfloat__base_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
  while (i<mapextent) {
    __valueProducedfloat_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
}
void  __valueProducedfloat_ndcpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  const unsigned int *mapbegin, 
                                  const unsigned int *mapextents) {
  __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=mapextents[dim-1];
  unsigned int mapextent = mapextents[0], i=1;
  for (;i<dim;++i) mapextent*=mapextents[i];

  unsigned int iter0 = getIndexOf(0, mapbegin, mapextents, extents[0], dim, extents[0]);
  i=0; 
  if (mapextent) {
    __valueProducedfloat__base_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
  while (i<mapextent) {
    __valueProducedfloat_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
}
void  __valueProducedfloat__combine_cpu (const std::vector<void *>&args,
                                         const std::vector<const unsigned int *>&extents,
                                         const std::vector<unsigned int>&dims,
                                         unsigned int mapbegin) {
    __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
    arg0+=mapbegin;
    __valueProducedfloat__combine_cpu_inner (
      *arg0,
      *arg1,
      *arg2);
}

class __valueProducedfloat_scatterclass{ public:
  void operator () (__BrtFloat1  &output, 
                    const __BrtFloat1  &input) const {
    __valueProducedfloat_cpu_inner (input, output);
  }
}__valueProducedfloat_scatter;
void  valueProducedfloat (::brook::stream input,
		::brook::stream output) {
  static const void *__valueProducedfloat_fp[] = {
     "fp30", __valueProducedfloat_fp30,
     "arb", __valueProducedfloat_arb,
     "ps20", __valueProducedfloat_ps20,
     "cpu", (void *) __valueProducedfloat_cpu,
     "ndcpu", (void *) __valueProducedfloat_ndcpu,
     "combine", (void *) __valueProducedfloat__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}

void  valueProducedfloat (::brook::stream input,
		float  & output) {
  static const void *__valueProducedfloat_fp[] = {
     "fp30", __valueProducedfloat_fp30,
     "arb", __valueProducedfloat_arb,
     "ps20", __valueProducedfloat_ps20,
     "cpu", (void *) __valueProducedfloat_cpu,
     "ndcpu", (void *) __valueProducedfloat_ndcpu,
     "combine", (void *) __valueProducedfloat__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    texld r0, t0, s0\n"
				"    rcp r7.w, r0.x\n"
				"    max r4.w, -r7.w, r7.w\n"
				"    cmp_pp r6.x, -r4.w, c0.x, c0.w\n"
				"    mov r6.yzw, c0.x\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:1:inp\n"
				"//o:1:outp\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat_ps20 = &__isFiniteKernelfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_inp : TEXUNIT0\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_inp : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __workspace : C0 :  : 3 : 1\n"
				"#var float2 _tex_inp_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVX o[COLR].x, H0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat_fp30 = &__isFiniteKernelfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r4.w, -r7.w, r7.w;\n"
				"CMP r6.x, -r4.w, c0.w, c0.x;\n"
				"MOV r6.yzw, c0.x;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat_arb = &__isFiniteKernelfloat_arb_desc;
}

void __isFiniteKernelfloat_cpu_inner (const __BrtFloat1  &inp,
                                       __BrtFloat1  &outp){
  outp = !__isinf_cpu_inner(inp.swizzle1(maskX));
}
void  __isFiniteKernelfloat_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  unsigned int ratio0 = extents[1][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[1][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[1]);
  arg1+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __isFiniteKernelfloat_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    ++arg1;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[1]);
    }
  }
}

void  isFiniteKernelfloat (::brook::stream inp,
		::brook::stream outp) {
  static const void *__isFiniteKernelfloat_fp[] = {
     "fp30", __isFiniteKernelfloat_fp30,
     "arb", __isFiniteKernelfloat_arb,
     "ps20", __isFiniteKernelfloat_ps20,
     "cpu", (void *) __isFiniteKernelfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__isFiniteKernelfloat_fp);

  k->PushStream(inp);
  k->PushOutput(outp);
  k->Map();

}


int  finiteValueProducedfloat(::brook::stream input)
{
  static ::brook::stream output(::brook::getStreamType(( float  *)0), 1 , 1,-1);
  static ::brook::stream finiteout(::brook::getStreamType(( float  *)0), 1 , 1,-1);
  float  rettype;
  float  ret;

  debugStreamPrint(input,"Finite Values in...");
  valueProducedfloat(input,output);
  streamWrite(output,&rettype);
  isFiniteKernelfloat(output,finiteout);
  streamWrite(finiteout,&ret);
  return (int ) (ret);
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0.1, 0, 0\n"
				"    dcl_2d s0\n"
				"    mov r1.xy, c1\n"
				"    mad r7.x, c0.x, r1.x, c0.z\n"
				"    mad r7.y, c0.y, r1.y, c0.w\n"
				"    texld r2, r7, s0\n"
				"    mov r2.w, -c2.y\n"
				"    add r2.w, r2.w, c1.y\n"
				"    cmp_pp r2.w, r2.w, c4.x, c4.w\n"
				"    mov r1.w, c1.y\n"
				"    add r9.w, c4.y, r1.w\n"
				"    cmp_pp r4.w, r9.w, c4.w, c4.x\n"
				"    add_pp r2.w, r2.w, r4.w\n"
				"    cmp r11.x, -r2.w, r2.x, c3.x\n"
				"    mov r11.yzw, c4.w\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//c:1:value\n"
				"//c:2:index\n"
				"//o:1:output\n"
				"//c:2:maxvalue\n"
				"//c:1:nothing\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat_ps20 = &__valueAtfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main.index : C1\n"
				"#semantic main.maxvalue : C2\n"
				"#semantic main.nothing : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float2 index : C1 :  : 2 : 1\n"
				"#var float2 maxvalue : C2 :  : 4 : 1\n"
				"#var float nothing : C3 :  : 5 : 1\n"
				"#var float4 __workspace : C4 :  : 6 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE index;\n"
				"DECLARE maxvalue;\n"
				"DECLARE nothing;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, index.xyxx, TEX0, RECT;\n"
				"MOVR R1.y, maxvalue.y;\n"
				"SGER H0.x, index.y, R1.y;\n"
				"MOVR R1.x, {-0.1}.x;\n"
				"SLTR H0.y, index.y, R1.x;\n"
				"ADDX H0.y, H0.x, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MOVR o[COLR].x, nothing.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:1:value\n"
				"##c:2:index\n"
				"##o:1:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat_fp30 = &__valueAtfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0.1, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"MOV r1.xy, c1;\n"
				"MAD r7.x, c0.x, r1.x, c0.z;\n"
				"MAD r7.y, c0.y, r1.y, c0.w;\n"
				"TEX r2, r7, texture[0], RECT;\n"
				"MOV r2.w, -c2.y;\n"
				"ADD r2.w, r2.w, c1.y;\n"
				"CMP r2.w, r2.w, c4.w, c4.x;\n"
				"MOV r1.w, c1.y;\n"
				"ADD r9.w, c4.y, r1.w;\n"
				"CMP r4.w, r9.w, c4.x, c4.w;\n"
				"ADD r2.w, r2.w, r4.w;\n"
				"CMP r11.x, -r2.w, c3.x, r2.x;\n"
				"MOV r11.yzw, c4.w;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:1:value\n"
				"##c:2:index\n"
				"##o:1:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat_arb = &__valueAtfloat_arb_desc;
}

void __valueAtfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                const __BrtFloat2  &index,
                                __BrtFloat1  &output,
                                const __BrtFloat2  &maxvalue,
                                const __BrtFloat1  &nothing){
  if (index.swizzle1(maskY) >= maxvalue.swizzle1(maskY) || index.swizzle1(maskY) < -__BrtFloat1(0.100000f))
    output = nothing;
  else
    output = value[index];
}
void  __valueAtfloat_cpu (const std::vector<void *>&args,
                          const std::vector<const unsigned int *>&extents,
                          const std::vector<unsigned int>&dims,
                          unsigned int mapbegin, 
                          unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __valueAtfloat_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4);
    i++;
    ++arg2;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  valueAtfloat (::brook::stream value,
		const float2  index,
		::brook::stream output,
		const float2  maxvalue,
		const float  nothing) {
  static const void *__valueAtfloat_fp[] = {
     "fp30", __valueAtfloat_fp30,
     "arb", __valueAtfloat_arb,
     "ps20", __valueAtfloat_ps20,
     "cpu", (void *) __valueAtfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueAtfloat_fp);

  k->PushGatherStream(value);
  k->PushConstant(index);
  k->PushOutput(output);
  k->PushConstant(maxvalue);
  k->PushConstant(nothing);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 0.5, 0.25, 0, -0.5\n"
				"    def c5, 1, 0, 0, 0.1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c4.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c4.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c4.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c4.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c4.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c5.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, r3.w, c5.x, r2.w\n"
				"    mov r2.w, c5.x\n"
				"    cmp_pp r9.w, r9.w, c4.z, r2.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c4.z\n"
				"    rcp r4.w, r4.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, -r4.w, c5.x, r2.w\n"
				"    rcp r1.w, r4.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp_pp r0.w, -r10.w, c5.x, r2.w\n"
				"    add_pp r2.x, r4.w, r0.w\n"
				"    mov r2.yzw, c4.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat_ps20 = &__NanToBoolRightfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.sign : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float sign : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, sign.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.y, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.y, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"SNER H0.y, R2.x, {0}.x;\n"
				"MULR R1.x, R2.x, {2}.x;\n"
				"SEQR H0.z, R2.x, R1.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.z, R0.x, R1.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {1}.x;\n"
				"ADDR o[COLR].x, R0.x, R0.y;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat_fp30 = &__NanToBoolRightfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {0.5, 0.25, 0, -0.5};\n"
				"PARAM c5 = {1, 0, 0, 0.1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c4.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c4.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c4.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c4.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c4.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c5.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, r3.w, r2.w, c5.x;\n"
				"MOV r2.w, c5.x;\n"
				"CMP r9.w, r9.w, r2.w, c4.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c4.z, r9.x;\n"
				"RCP r4.w, r4.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, -r4.w, r2.w, c5.x;\n"
				"RCP r1.w, r4.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r0.w, -r10.w, r2.w, c5.x;\n"
				"ADD r2.x, r4.w, r0.w;\n"
				"MOV r2.yzw, c4.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat_arb = &__NanToBoolRightfloat_arb_desc;
}

void __NanToBoolRightfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                       __BrtFloat1  &output,
                                       const __BrtFloat1  &sign,
                                       const __BrtFloat2  &maxvalue,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,sign,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = (__isinf_cpu_inner(value[__indexof_output].swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0))) + (__isinf_cpu_inner(neighbor.swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0)));
}
void  __NanToBoolRightfloat_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToBoolRightfloat_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToBoolRightfloat (::brook::stream value,
		::brook::stream output,
		const float  sign,
		const float2  maxvalue) {
  static const void *__NanToBoolRightfloat_fp[] = {
     "fp30", __NanToBoolRightfloat_fp30,
     "arb", __NanToBoolRightfloat_arb,
     "ps20", __NanToBoolRightfloat_ps20,
     "cpu", (void *) __NanToBoolRightfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToBoolRightfloat_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r4.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r9.w, r9.w, c5.z, r0.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c5.z\n"
				"    add r11.w, r4.x, r4.w\n"
				"    add r6.w, r11.w, c5.x\n"
				"    frc r1.w, r6.w\n"
				"    add r7.x, r6.w, -r1.w\n"
				"    mov r7.yzw, c5.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat_ps20 = &__NanToRightfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R2.x, R0.x, R2.x;\n"
				"ADDR R2.x, R2.x, {0.5}.x;\n"
				"FLRR o[COLR].x, R2.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat_fp30 = &__NanToRightfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r4.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r9.w, r9.w, r0.w, c5.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c5.z, r9.x;\n"
				"ADD r11.w, r4.x, r4.w;\n"
				"ADD r6.w, r11.w, c5.x;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r7.x, r6.w, -r1.w;\n"
				"MOV r7.yzw, c5.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat_arb = &__NanToRightfloat_arb_desc;
}

void __NanToRightfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                   __BrtFloat1  &output,
                                   const __BrtFloat1  &twotoi,
                                   const __BrtFloat2  &maxvalue,
                                   const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = __round_cpu_inner(value[__indexof_output] + neighbor);
}
void  __NanToRightfloat_cpu (const std::vector<void *>&args,
                             const std::vector<const unsigned int *>&extents,
                             const std::vector<unsigned int>&dims,
                             unsigned int mapbegin, 
                             unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToRightfloat_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToRightfloat (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__NanToRightfloat_fp[] = {
     "fp30", __NanToRightfloat_fp30,
     "arb", __NanToRightfloat_arb,
     "ps20", __NanToRightfloat_ps20,
     "cpu", (void *) __NanToRightfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToRightfloat_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r4.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r9.w, r9.w, c5.z, r0.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c5.z\n"
				"    add r11.x, r4.x, r4.w\n"
				"    mov r11.yzw, c5.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat_ps20 = &__CountToRightfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR o[COLR].x, R0.x, R2.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat_fp30 = &__CountToRightfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r4.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r9.w, r9.w, r0.w, c5.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c5.z, r9.x;\n"
				"ADD r11.x, r4.x, r4.w;\n"
				"MOV r11.yzw, c5.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat_arb = &__CountToRightfloat_arb_desc;
}

void __CountToRightfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                     __BrtFloat1  &output,
                                     const __BrtFloat1  &twotoi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = value[__indexof_output] + neighbor;
}
void  __CountToRightfloat_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __CountToRightfloat_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  CountToRightfloat (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__CountToRightfloat_fp[] = {
     "fp30", __CountToRightfloat_fp30,
     "arb", __CountToRightfloat_arb,
     "ps20", __CountToRightfloat_ps20,
     "cpu", (void *) __CountToRightfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__CountToRightfloat_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r3.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r3.w\n"
				"    mad r5.x, r3.x, c2.x, c2.z\n"
				"    mad r5.y, r3.y, c2.y, c2.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    texld r2, r5, s1\n"
				"    texld r9, r0, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r2.w, r3.y, c7.w\n"
				"    mov r0.w, c8.z\n"
				"    cmp_pp r9.w, r3.w, c7.x, r0.w\n"
				"    mov r0.w, c7.x\n"
				"    cmp_pp r2.w, r2.w, c8.z, r0.w\n"
				"    add_pp r2.w, r9.w, r2.w\n"
				"    cmp r4.w, -r2.w, r2.x, c8.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp_pp r10.w, -r8.w, c8.z, r0.w\n"
				"    cmp r5.w, -r2.w, r9.x, c8.z\n"
				"    add r3.w, r5.w, -c5.x\n"
				"    mov r2.w, -r5.w\n"
				"    abs r4.w, r3.w\n"
				"    mov r11.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r11.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r10.w, r6.w\n"
				"    mov r7.w, -c3.x\n"
				"    add r10.w, r7.w, c5.x\n"
				"    cmp r5.w, -r1.w, r10.w, c5.x\n"
				"    add r0.w, r2.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r3.w, c3.x, r4.w\n"
				"    cmp r2.x, r0.w, r5.w, r3.w\n"
				"    mov r2.yzw, c8.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:1:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat_ps20 = &__GatherGuessfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.x, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.x, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.x, R2.x, halfk.x;\n"
				"SEQR H0.z, R2.x, halfk.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.y, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR o[COLR].x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), halfk.x;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, -R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat_fp30 = &__GatherGuessfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r3.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r3.w;\n"
				"MAD r5.x, r3.x, c2.x, c2.z;\n"
				"MAD r5.y, r3.y, c2.y, c2.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"TEX r2, r5, texture[1], RECT;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r2.w, r3.y, c7.w;\n"
				"MOV r0.w, c8.z;\n"
				"CMP r9.w, r3.w, r0.w, c7.x;\n"
				"MOV r0.w, c7.x;\n"
				"CMP r2.w, r2.w, r0.w, c8.z;\n"
				"ADD r2.w, r9.w, r2.w;\n"
				"CMP r4.w, -r2.w, c8.z, r2.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r10.w, -r8.w, r0.w, c8.z;\n"
				"CMP r5.w, -r2.w, c8.z, r9.x;\n"
				"ADD r3.w, r5.w, -c5.x;\n"
				"MOV r2.w, -r5.w;\n"
				"ABS r4.w, r3.w;\n"
				"MOV r11.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r11.w, r4.w, c7.x;\n"
				"MUL r1.w, r10.w, r6.w;\n"
				"MOV r7.w, -c3.x;\n"
				"ADD r10.w, r7.w, c5.x;\n"
				"CMP r5.w, -r1.w, c5.x, r10.w;\n"
				"ADD r0.w, r2.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r3.w, c3.x, r4.w;\n"
				"CMP r2.x, r0.w, r3.w, r5.w;\n"
				"MOV r2.yzw, c8.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat_arb = &__GatherGuessfloat_arb_desc;
}

void __GatherGuessfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                    __BrtFloat1  &output,
                                    const __BrtArray2d<__BrtFloat1  > &value,
                                    const __BrtFloat1  &twotologkminusi,
                                    const __BrtFloat2  &maxvalue,
                                    const __BrtFloat1  &halfk,
                                    const __BrtFloat1  &sign,
                                    const __BrtFloat4 &__indexof_output){
  __BrtFloat1  neighbor;
  __BrtFloat2  nextPlaceToLook;

  __getIndexAt_cpu_inner(__indexof_output,-sign * halfk,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(scatterindex,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  if (neighbor > halfk)
  {
    output = halfk + twotologkminusi;
  }

  else
  {
    __BrtFloat1  actualValue;

    __valueAtfloat_cpu_inner(value,nextPlaceToLook,actualValue,maxvalue,__BrtFloat1((float)0));
    if (neighbor == halfk && !__isinf_cpu_inner(actualValue.swizzle1(maskX)))
    {
      output = halfk;
    }

    else
    {
      output = halfk - twotologkminusi;
    }

  }

}
void  __GatherGuessfloat_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __GatherGuessfloat_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  GatherGuessfloat (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__GatherGuessfloat_fp[] = {
     "fp30", __GatherGuessfloat_fp30,
     "arb", __GatherGuessfloat_arb,
     "ps20", __GatherGuessfloat_ps20,
     "cpu", (void *) __GatherGuessfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__GatherGuessfloat_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r2.x, r3.x, c2.x, c2.z\n"
				"    mad r2.y, r3.y, c2.y, c2.w\n"
				"    mad r9.x, r3.x, c0.x, c0.z\n"
				"    mad r9.y, r3.y, c0.y, c0.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    texld r11, r2, s1\n"
				"    texld r6, r9, s0\n"
				"    texld r1, r4, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r11.w, r3.y, c7.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r3.w, c7.x, r4.w\n"
				"    mov r4.w, c7.x\n"
				"    cmp_pp r11.w, r11.w, c8.z, r4.w\n"
				"    add_pp r11.w, r6.w, r11.w\n"
				"    cmp r1.w, -r11.w, r11.x, c8.z\n"
				"    rcp r1.w, r1.w\n"
				"    add r7.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r7.w, -r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.z, r4.w\n"
				"    cmp r10.w, -r11.w, r6.x, c8.z\n"
				"    add r0.w, r10.w, -c5.x\n"
				"    abs r4.w, r0.w\n"
				"    mov r3.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r11.w, r3.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r1.w, r11.w\n"
				"    mov r6.w, -c3.x\n"
				"    add r8.w, r6.w, c5.x\n"
				"    cmp r1.w, -r1.w, r8.w, c5.x\n"
				"    add r7.w, -r10.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r10.w, c3.x, r4.w\n"
				"    cmp r1.w, r7.w, r1.w, r10.w\n"
				"    abs r0.w, r1.x\n"
				"    cmp r9.x, -r0.w, c8.z, r1.w\n"
				"    mov r9.yzw, c8.z\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:1:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat_ps20 = &__EstablishGuessfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SEQR H0.x, R0.x, {0}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H1.x, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H1.y, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H1.y, R0.x, {-0.5}.x;\n"
				"MULX H1.y, H0.y, H1.y;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"SLTR H0.z, R2.y, {-0.1}.x;\n"
				"SGER H0.w, R2.y, maxvalue.y;\n"
				"ADDX H0.z, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.x, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.y, R2.x, halfk.x;\n"
				"SEQR H0.w, R2.x, halfk.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H1.x, H0.y;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R1.x;\n"
				"SNER H0.z, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.z, -H1.x, H0.z, {1}.x;\n"
				"MULX H1.x, H0.w, H0.z;\n"
				"MADX H0.z, -H0.w, H0.z, {1}.x;\n"
				"MULX H1.x, H0.y, H1.x;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R0.x(GT.x), halfk.x;\n"
				"MOVR R0.y, twotologkminusi.x;\n"
				"ADDR R0.y, halfk.x, -R0.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R0.y;\n"
				"MOVR o[COLR].x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat_fp30 = &__EstablishGuessfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r2.x, r3.x, c2.x, c2.z;\n"
				"MAD r2.y, r3.y, c2.y, c2.w;\n"
				"MAD r9.x, r3.x, c0.x, c0.z;\n"
				"MAD r9.y, r3.y, c0.y, c0.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"TEX r11, r2, texture[1], RECT;\n"
				"TEX r6, r9, texture[0], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r11.w, r3.y, c7.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r3.w, r4.w, c7.x;\n"
				"MOV r4.w, c7.x;\n"
				"CMP r11.w, r11.w, r4.w, c8.z;\n"
				"ADD r11.w, r6.w, r11.w;\n"
				"CMP r1.w, -r11.w, c8.z, r11.x;\n"
				"RCP r1.w, r1.w;\n"
				"ADD r7.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r7.w, r1.w, -r1.w;\n"
				"CMP r1.w, -r1.w, r4.w, c8.z;\n"
				"CMP r10.w, -r11.w, c8.z, r6.x;\n"
				"ADD r0.w, r10.w, -c5.x;\n"
				"ABS r4.w, r0.w;\n"
				"MOV r3.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r11.w, r3.w, r4.w, c7.x;\n"
				"MUL r1.w, r1.w, r11.w;\n"
				"MOV r6.w, -c3.x;\n"
				"ADD r8.w, r6.w, c5.x;\n"
				"CMP r1.w, -r1.w, c5.x, r8.w;\n"
				"ADD r7.w, -r10.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r10.w, c3.x, r4.w;\n"
				"CMP r1.w, r7.w, r10.w, r1.w;\n"
				"ABS r0.w, r1.x;\n"
				"CMP r9.x, -r0.w, r1.w, c8.z;\n"
				"MOV r9.yzw, c8.z;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat_arb = &__EstablishGuessfloat_arb_desc;
}

void __EstablishGuessfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                       __BrtFloat1  &output,
                                       const __BrtArray2d<__BrtFloat1  > &value,
                                       const __BrtFloat1  &twotologkminusi,
                                       const __BrtFloat2  &maxvalue,
                                       const __BrtFloat1  &halfk,
                                       const __BrtFloat1  &sign,
                                       const __BrtFloat4 &__indexof_output){
  if (scatterindex[__indexof_output] == __BrtFloat1((float)0))
  {
    output = __BrtFloat1((float)0);
  }

  else
  {
    __GatherGuessfloat_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,halfk,sign,__indexof_output);
  }

}
void  __EstablishGuessfloat_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __EstablishGuessfloat_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  EstablishGuessfloat (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__EstablishGuessfloat_fp[] = {
     "fp30", __EstablishGuessfloat_fp30,
     "arb", __EstablishGuessfloat_arb,
     "ps20", __EstablishGuessfloat_ps20,
     "cpu", (void *) __EstablishGuessfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__EstablishGuessfloat_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 1, 0, 0, 0.1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    texld r0, t1, s2\n"
				"    mad r2.x, t0.x, c1.x, c1.z\n"
				"    mad r2.y, t0.y, c1.y, c1.w\n"
				"    mad r2.w, r0.x, -c5.x, r2.x\n"
				"    add r2.w, r2.w, c7.x\n"
				"    frc r0.w, r2.w\n"
				"    add r0.w, r2.w, -r0.w\n"
				"    rcp r9.w, c4.x\n"
				"    mul r0.w, r0.w, r9.w\n"
				"    mul r2.w, r2.w, r9.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    add r0.w, r0.w, c7.x\n"
				"    frc r4.w, r0.w\n"
				"    add r0.w, r0.w, -r4.w\n"
				"    add r1.w, -r0.w, c7.w\n"
				"    add r8.w, r0.w, c4.x\n"
				"    cmp r0.w, r1.w, r8.w, r0.w\n"
				"    add r3.w, r0.w, c7.y\n"
				"    add r5.w, r3.w, -c4.x\n"
				"    cmp r7.x, r5.w, c7.z, r0.w\n"
				"    frc r7.w, r2.w\n"
				"    add r7.w, r2.w, -r7.w\n"
				"    add r7.y, r2.y, r7.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    mad r11.x, r7.x, c2.x, c2.z\n"
				"    mad r11.y, r7.y, c2.y, c2.w\n"
				"    texld r6, r4, s0\n"
				"    texld r1, r11, s1\n"
				"    add r7.w, r7.y, -c4.y\n"
				"    add r6.w, r7.y, c6.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r1.w, r7.w, c6.x, r11.w\n"
				"    mov r11.w, c6.x\n"
				"    cmp_pp r6.w, r6.w, c7.z, r11.w\n"
				"    add_pp r6.w, r1.w, r6.w\n"
				"    cmp r0.w, -r6.w, r6.x, c7.z\n"
				"    add r3.w, r0.w, -r0.x\n"
				"    abs r5.w, r3.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r2.w, -r5.w, c6.x, r11.w\n"
				"    cmp r4.w, -r6.w, r1.x, c7.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r1.w, -r11.w, r11.w\n"
				"    mov r8.w, -r1.w\n"
				"    mov r1.w, c6.x\n"
				"    cmp_pp r3.w, r8.w, c7.z, r1.w\n"
				"    mul_pp r10.w, r2.w, r3.w\n"
				"    add r2.w, r0.x, -c3.x\n"
				"    cmp r4.w, -r10.w, r2.w, r0.x\n"
				"    add r0.w, r0.x, -r0.w\n"
				"    add r11.w, r0.x, c3.x\n"
				"    cmp r7.x, r0.w, r4.w, r11.w\n"
				"    mov r7.yzw, c7.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:1:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//s:1:lastguess\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat_ps20 = &__UpdateGuessfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main._tex_lastguess : TEXUNIT2\n"
				"#semantic main.sign : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var samplerRECT _tex_lastguess : TEXUNIT2 : texunit 2 : 9 : 1\n"
				"#var float sign : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"#var float2 _tex_lastguess_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"MADR R1.w, -sign.x, R0.x, R1.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxvalue.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R3.y, {-0.1}.x;\n"
				"SGER H0.y, R3.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R3.y, {-0.1}.x;\n"
				"SGER H0.z, R3.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.x, R3.xyxx, TEX0, RECT;\n"
				"TEX R2.x, R3.xyxx, TEX1, RECT;\n"
				"MOVR R3.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"SGTR H0.x, R3.x, R0.x;\n"
				"SEQR H0.z, R3.x, R0.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), R2.x;\n"
				"SNER H0.y, R1.x, {0}.x;\n"
				"MULR R1.y, R1.x, {2}.x;\n"
				"SEQR H1.x, R1.x, R1.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"ADDR o[COLR].x, R0.x, twotologkminusi.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"ADDR R0.x, R0.x, -twotologkminusi.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat_fp30 = &__UpdateGuessfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {1, 0, 0, 0.1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[2], RECT;\n"
				"MAD r2.x, t0.x, c1.x, c1.z;\n"
				"MAD r2.y, t0.y, c1.y, c1.w;\n"
				"MAD r2.w, r0.x, -c5.x, r2.x;\n"
				"ADD r2.w, r2.w, c7.x;\n"
				"FRC r0.w, r2.w;\n"
				"ADD r0.w, r2.w, -r0.w;\n"
				"RCP r9.w, c4.x;\n"
				"MUL r0.w, r0.w, r9.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"ADD r0.w, r0.w, c7.x;\n"
				"FRC r4.w, r0.w;\n"
				"ADD r0.w, r0.w, -r4.w;\n"
				"ADD r1.w, -r0.w, c7.w;\n"
				"ADD r8.w, r0.w, c4.x;\n"
				"CMP r0.w, r1.w, r0.w, r8.w;\n"
				"ADD r3.w, r0.w, c7.y;\n"
				"ADD r5.w, r3.w, -c4.x;\n"
				"CMP r7.x, r5.w, r0.w, c7.z;\n"
				"FRC r7.w, r2.w;\n"
				"ADD r7.w, r2.w, -r7.w;\n"
				"ADD r7.y, r2.y, r7.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"MAD r11.x, r7.x, c2.x, c2.z;\n"
				"MAD r11.y, r7.y, c2.y, c2.w;\n"
				"TEX r6, r4, texture[0], RECT;\n"
				"TEX r1, r11, texture[1], RECT;\n"
				"ADD r7.w, r7.y, -c4.y;\n"
				"ADD r6.w, r7.y, c6.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r1.w, r7.w, r11.w, c6.x;\n"
				"MOV r11.w, c6.x;\n"
				"CMP r6.w, r6.w, r11.w, c7.z;\n"
				"ADD r6.w, r1.w, r6.w;\n"
				"CMP r0.w, -r6.w, c7.z, r6.x;\n"
				"ADD r3.w, r0.w, -r0.x;\n"
				"ABS r5.w, r3.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r2.w, -r5.w, r11.w, c6.x;\n"
				"CMP r4.w, -r6.w, c7.z, r1.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r1.w, -r11.w, r11.w;\n"
				"MOV r8.w, -r1.w;\n"
				"MOV r1.w, c6.x;\n"
				"CMP r3.w, r8.w, r1.w, c7.z;\n"
				"MUL r10.w, r2.w, r3.w;\n"
				"ADD r2.w, r0.x, -c3.x;\n"
				"CMP r4.w, -r10.w, r0.x, r2.w;\n"
				"ADD r0.w, r0.x, -r0.w;\n"
				"ADD r11.w, r0.x, c3.x;\n"
				"CMP r7.x, r0.w, r11.w, r4.w;\n"
				"MOV r7.yzw, c7.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:1:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat_arb = &__UpdateGuessfloat_arb_desc;
}

void __UpdateGuessfloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                    __BrtFloat1  &output,
                                    const __BrtArray2d<__BrtFloat1  > &value,
                                    const __BrtFloat1  &twotologkminusi,
                                    const __BrtFloat2  &maxvalue,
                                    const __BrtFloat1  &lastguess,
                                    const __BrtFloat1  &sign,
                                    const __BrtFloat4 &__indexof_output){
  __GatherGuessfloat_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,lastguess,sign,__indexof_output);
}
void  __UpdateGuessfloat_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  unsigned int ratio5 = extents[1][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[1][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[1]);
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __UpdateGuessfloat_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[1]);
    }
  }
}

void  UpdateGuessfloat (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		::brook::stream lastguess,
		const float  sign) {
  static const void *__UpdateGuessfloat_fp[] = {
     "fp30", __UpdateGuessfloat_fp30,
     "arb", __UpdateGuessfloat_arb,
     "ps20", __UpdateGuessfloat_ps20,
     "cpu", (void *) __UpdateGuessfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__UpdateGuessfloat_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushStream(lastguess);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.0625, 1.0625, 0, 1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    mad r7.x, t0.x, c0.x, c0.z\n"
				"    mad r7.y, t0.y, c0.y, c0.w\n"
				"    mad r9.x, r7.x, c1.x, c1.z\n"
				"    mad r9.y, r7.y, c1.y, c1.w\n"
				"    texld r4, r9, s0\n"
				"    mov r7.w, -c3.x\n"
				"    mad r6.w, r4.x, r7.w, r7.x\n"
				"    add r1.w, r6.w, c7.x\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    rcp r5.w, c4.x\n"
				"    mul r0.w, r10.w, r5.w\n"
				"    frc r2.w, r0.w\n"
				"    mul r9.w, r2.w, c4.x\n"
				"    add r4.w, r9.w, c7.x\n"
				"    frc r11.w, r4.w\n"
				"    add r8.w, r4.w, -r11.w\n"
				"    add r10.w, -r8.w, c7.w\n"
				"    add r0.w, r8.w, c4.x\n"
				"    cmp r2.w, r10.w, r0.w, r8.w\n"
				"    add r9.w, r2.w, c7.y\n"
				"    add r11.w, r9.w, -c4.x\n"
				"    cmp r1.x, r11.w, c7.z, r2.w\n"
				"    mul r1.w, r1.w, r5.w\n"
				"    frc r6.w, r1.w\n"
				"    add r1.w, r1.w, -r6.w\n"
				"    add r1.y, r7.y, r1.w\n"
				"    mad r5.x, r1.x, c2.x, c2.z\n"
				"    mad r5.y, r1.y, c2.y, c2.w\n"
				"    texld r3, r5, s1\n"
				"    texld r10, t1, s2\n"
				"    mad r7.w, r7.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c7.x\n"
				"    mul r3.w, r5.w, r7.w\n"
				"    frc r10.w, r3.w\n"
				"    add r3.w, r3.w, -r10.w\n"
				"    add r4.y, r7.y, r3.w\n"
				"    frc r10.w, r7.w\n"
				"    add r10.w, r7.w, -r10.w\n"
				"    mul r3.w, r10.w, r5.w\n"
				"    frc r10.w, r3.w\n"
				"    mul r3.w, r10.w, c4.x\n"
				"    add r10.w, r3.w, c7.x\n"
				"    frc r3.w, r10.w\n"
				"    add r10.w, r10.w, -r3.w\n"
				"    add r3.w, -r10.w, c7.w\n"
				"    add r0.w, r10.w, c4.x\n"
				"    cmp r10.w, r3.w, r0.w, r10.w\n"
				"    add r4.w, -c4.x, r10.w\n"
				"    add r4.w, r4.w, c7.y\n"
				"    cmp r4.x, r4.w, c7.z, r10.w\n"
				"    add r9.xy, r4, -c4\n"
				"    add r9.w, r9.y, c6.y\n"
				"    mov r0.w, c7.z\n"
				"    cmp_pp r9.w, r9.w, c6.w, r0.w\n"
				"    add r3.w, r9.x, c6.x\n"
				"    add r10.w, r9.y, c6.x\n"
				"    cmp_pp r3.w, r3.w, c6.w, r0.w\n"
				"    mul r3.w, r9.w, r3.w\n"
				"    cmp_pp r10.w, r10.w, c6.w, r0.w\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r11.x, -r3.w, r3.x, r10.x\n"
				"    mov r11.yzw, c7.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:1:output\n"
				"//c:1:gatherindex\n"
				"//c:1:value\n"
				"//s:1:inf\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//c:1:maxshift\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat_ps20 = &__RelativeGatherfloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_output_invscalebias : C0\n"
				"#semantic main.gatherindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_gatherindex : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main._tex_inf : TEXUNIT2\n"
				"#semantic main.sign : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.maxshift : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var float4 _const_output_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT gatherindex[0] : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var float4 __gatherconst_gatherindex : C1 :  : 4 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var samplerRECT _tex_inf : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float sign : C3 :  : 9 : 1\n"
				"#var float2 maxvalue : C4 :  : 10 : 1\n"
				"#var float maxshift : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_inf_pos : $vin.TEXCOORD1 : TEX1 : 8 : 1\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_gatherindex;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE maxshift;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, maxshift.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R1.x, R0.xyxx, TEX0, RECT;\n"
				"MADR R0.w, -sign.x, R1.x, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R3.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R3.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"ADDR R0.x, R3.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.y, R0.x, {0}.x;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"ADDR R0.z, R0.z, {0.5}.x;\n"
				"FLRR R0.z, R0.z;\n"
				"SLER H0.x, R0.z, {-0.5}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.y, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.z;\n"
				"ADDR R0.z, R0.z, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.z;\n"
				"ADDR R0.y, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.y, maxvalue.x;\n"
				"MOVR R3.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"ADDR R2.xy, R2.xyxx, -maxvalue.xyxx;\n"
				"SGER H0.x, R2.y, {-0.0625}.x;\n"
				"SGER H0.y, R2.x, {-0.0625}.x;\n"
				"SGER H0.z, R2.y, {-1.0625}.x;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R3.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"TEX R0.x, R3.xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:1:output\n"
				"##c:1:gatherindex\n"
				"##c:1:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat_fp30 = &__RelativeGatherfloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.0625, 1.0625, 0, 1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, r7.x, c1.x, c1.z;\n"
				"MAD r9.y, r7.y, c1.y, c1.w;\n"
				"TEX r4, r9, texture[0], RECT;\n"
				"MOV r7.w, -c3.x;\n"
				"MAD r6.w, r4.x, r7.w, r7.x;\n"
				"ADD r1.w, r6.w, c7.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"RCP r5.w, c4.x;\n"
				"MUL r0.w, r10.w, r5.w;\n"
				"FRC r2.w, r0.w;\n"
				"MUL r9.w, r2.w, c4.x;\n"
				"ADD r4.w, r9.w, c7.x;\n"
				"FRC r11.w, r4.w;\n"
				"ADD r8.w, r4.w, -r11.w;\n"
				"ADD r10.w, -r8.w, c7.w;\n"
				"ADD r0.w, r8.w, c4.x;\n"
				"CMP r2.w, r10.w, r8.w, r0.w;\n"
				"ADD r9.w, r2.w, c7.y;\n"
				"ADD r11.w, r9.w, -c4.x;\n"
				"CMP r1.x, r11.w, r2.w, c7.z;\n"
				"MUL r1.w, r1.w, r5.w;\n"
				"FRC r6.w, r1.w;\n"
				"ADD r1.w, r1.w, -r6.w;\n"
				"ADD r1.y, r7.y, r1.w;\n"
				"MAD r5.x, r1.x, c2.x, c2.z;\n"
				"MAD r5.y, r1.y, c2.y, c2.w;\n"
				"TEX r3, r5, texture[1], RECT;\n"
				"TEX r10, t1, texture[2], RECT;\n"
				"MAD r7.w, r7.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c7.x;\n"
				"MUL r3.w, r5.w, r7.w;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r3.w, r3.w, -r10.w;\n"
				"ADD r4.y, r7.y, r3.w;\n"
				"FRC r10.w, r7.w;\n"
				"ADD r10.w, r7.w, -r10.w;\n"
				"MUL r3.w, r10.w, r5.w;\n"
				"FRC r10.w, r3.w;\n"
				"MUL r3.w, r10.w, c4.x;\n"
				"ADD r10.w, r3.w, c7.x;\n"
				"FRC r3.w, r10.w;\n"
				"ADD r10.w, r10.w, -r3.w;\n"
				"ADD r3.w, -r10.w, c7.w;\n"
				"ADD r0.w, r10.w, c4.x;\n"
				"CMP r10.w, r3.w, r10.w, r0.w;\n"
				"ADD r4.w, -c4.x, r10.w;\n"
				"ADD r4.w, r4.w, c7.y;\n"
				"CMP r4.x, r4.w, r10.w, c7.z;\n"
				"ADD r9.xy, r4, -c4;\n"
				"ADD r9.w, r9.y, c6.y;\n"
				"MOV r0.w, c7.z;\n"
				"CMP r9.w, r9.w, r0.w, c6.w;\n"
				"ADD r3.w, r9.x, c6.x;\n"
				"ADD r10.w, r9.y, c6.x;\n"
				"CMP r3.w, r3.w, r0.w, c6.w;\n"
				"MUL r3.w, r9.w, r3.w;\n"
				"CMP r10.w, r10.w, r0.w, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r11.x, -r3.w, r10.x, r3.x;\n"
				"MOV r11.yzw, c7.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:1:output\n"
				"##c:1:gatherindex\n"
				"##c:1:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat_arb = &__RelativeGatherfloat_arb_desc;
}

void __RelativeGatherfloat_cpu_inner (__BrtFloat1  &output,
                                       const __BrtArray2d<__BrtFloat1  > &gatherindex,
                                       const __BrtArray2d<__BrtFloat1  > &value,
                                       const __BrtFloat1  &inf,
                                       const __BrtFloat1  &sign,
                                       const __BrtFloat2  &maxvalue,
                                       const __BrtFloat1  &maxshift,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  isoffedge;

  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * gatherindex[__indexof_output],maxvalue,nextPlaceToLook);
  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * maxshift,maxvalue,isoffedge);
  isoffedge -= maxvalue;
  if (isoffedge.swizzle1(maskY) >= -__BrtFloat1(0.062500f) || isoffedge.swizzle1(maskY) >= -__BrtFloat1(1.062500f) && isoffedge.swizzle1(maskX) >= -__BrtFloat1(0.062500f))
  {
    output = inf;
  }

  else
  {
    output = value[nextPlaceToLook];
  }

}
void  __RelativeGatherfloat_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtFloat1 *arg0 = (__BrtFloat1 *)args[0];
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio3 = extents[0][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[0][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __RelativeGatherfloat_cpu_inner (
      *arg0,
      arg1,
      arg2,
      *(arg3 + iter3),
      *arg4,
      *arg5,
      *arg6,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[0]);
    }
  }
}

void  RelativeGatherfloat (::brook::stream output,
		::brook::stream gatherindex,
		::brook::stream value,
		::brook::stream inf,
		const float  sign,
		const float2  maxvalue,
		const float  maxshift) {
  static const void *__RelativeGatherfloat_fp[] = {
     "fp30", __RelativeGatherfloat_fp30,
     "arb", __RelativeGatherfloat_arb,
     "ps20", __RelativeGatherfloat_ps20,
     "cpu", (void *) __RelativeGatherfloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__RelativeGatherfloat_fp);

  k->PushOutput(output);
  k->PushGatherStream(gatherindex);
  k->PushGatherStream(value);
  k->PushStream(inf);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->PushConstant(maxshift);
  k->Map();

}


float  shiftValuesfloat(::brook::stream list_stream, ::brook::stream (*output_stream), int  WIDTH, int  LENGTH, int  sign)
{
  ::brook::stream tmp_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream ret_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream guess_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  unsigned int  i;
  float2  maxvalue;
  unsigned int  logN;
  unsigned int  LogNMinusK;
  float  maxshift;

  maxvalue.x = (float ) (LENGTH);
  maxvalue.y = (float ) (WIDTH);
  logN = (unsigned int ) (ceil(log((float ) (LENGTH) * WIDTH) / log(2.000000f)));
  debugStreamPrint(list_stream,"Combined...");
  NanToBoolRightfloat(list_stream,ret_stream,(float ) (sign),maxvalue);
  for (i = 1; i < logN; ++i)
  {
    streamSwap(ret_stream,tmp_stream);
    NanToRightfloat(tmp_stream,ret_stream,(float ) (sign) * (1 << i),maxvalue);
  }

  debugStreamPrint(ret_stream,"scattering...");
  {
    static ::brook::stream item(::brook::getStreamType(( float  *)0), 1,-1);
    float2  index;

    if (sign == -1)
    {
      index.y = (float ) (WIDTH - 1);
      index.x = (float ) (LENGTH - 1);
    }

    else
    {
      index.y = index.x = 0;
    }

    kernelReadItem(ret_stream,index,item);
    streamWrite(item,&maxshift);
  }

  LogNMinusK = logN - 2;
  i = logN - 1;
  EstablishGuessfloat(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,(float ) (1 << i),(float ) (sign));
  for (i = 1; i < logN; ++i)
  {
    LogNMinusK = logN - 1 - i;
    streamSwap(tmp_stream,guess_stream);
    UpdateGuessfloat(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,tmp_stream,(float ) (sign));
  }

  debugStreamPrint(guess_stream,"Gather Value");
  if (1)
  {
    unsigned int  size;
    unsigned int  width;

    size = (unsigned int ) (LENGTH) * (unsigned int ) (WIDTH) - (unsigned int ) (maxshift);
    width = size / LENGTH + ((size % LENGTH) ? (1) : (0));
    if (1)
    {
      ::brook::stream proper_output_stream=quickAllocStream(::brook::getStreamType(( float  *)0), width , LENGTH,-1);

      if (width)
      {
        RelativeGatherfloat(proper_output_stream,guess_stream,list_stream,*sentinelStream(2),(float ) (sign),maxvalue,maxshift);
      }

      streamSwap(*output_stream,proper_output_stream);
    }

    debugStreamPrint(*output_stream,"Final Value");
  }

  return maxshift;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine1_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t1.x, c5.x, c5.z\n"
				"    mad r7.y, t1.y, c5.y, c5.w\n"
				"    rcp r7.w, c1.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c0.x, c0.z\n"
				"    mad r8.y, r9.y, c0.y, c0.w\n"
				"    texld r3, r8, s0\n"
				"    texld r10, t0, s1\n"
				"    mul r2.w, r7.y, c4.x\n"
				"    frc r3.w, r2.x\n"
				"    mad r3.w, r3.w, c1.x, r2.w\n"
				"    mul r10.w, r7.w, r3.w\n"
				"    frc r3.w, r10.w\n"
				"    mul r10.w, r3.w, c1.x\n"
				"    add r10.w, r10.w, -c2.x\n"
				"    frc r3.w, r10.w\n"
				"    add r10.w, r10.w, -r3.w\n"
				"    abs r3.w, r10.w\n"
				"    cmp_pp r3.w, -r3.w, c6.w, c6.y\n"
				"    add r10.w, r10.w, -c1.x\n"
				"    abs r10.w, r10.w\n"
				"    cmp_pp r10.w, -r10.w, c6.w, c6.y\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r7.x, -r3.w, r10.x, r3.x\n"
				"    mov r7.yzw, c6.y\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:input0\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:1:oldoutput\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine1_ps20 = &__floatstreamCombine1_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine1_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.offset : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._tex_oldoutput : TEXUNIT1\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var float modulus : C1 :  : 2 : 1\n"
				"#var float offset : C2 :  : 3 : 1\n"
				"#var float length : C3 :  : 4 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 5 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT1 : texunit 1 : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 9 : 1\n"
				"#var float4 __workspace : C6 :  : 11 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX1, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, length.x;\n"
				"MULR R1.x, R2.w, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |length.x|;\n"
				"RCPR R1.y, modulus.x;\n"
				"MULR R1.y, R3.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |modulus.x|;\n"
				"MOVR R1.z, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.x;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, -offset.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SEQR H0.x, R1.x, modulus.x;\n"
				"SEQR H0.y, R1.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR o[COLR].x, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine1_fp30 = &__floatstreamCombine1_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine1_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c5.x, c5.z;\n"
				"MAD r7.y, t1.y, c5.y, c5.w;\n"
				"RCP r7.w, c1.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c0.x, c0.z;\n"
				"MAD r8.y, r9.y, c0.y, c0.w;\n"
				"TEX r3, r8, texture[0], RECT;\n"
				"TEX r10, t0, texture[1], RECT;\n"
				"MUL r2.w, r7.y, c4.x;\n"
				"FRC r3.w, r2.x;\n"
				"MAD r3.w, r3.w, c1.x, r2.w;\n"
				"MUL r10.w, r7.w, r3.w;\n"
				"FRC r3.w, r10.w;\n"
				"MUL r10.w, r3.w, c1.x;\n"
				"ADD r10.w, r10.w, -c2.x;\n"
				"FRC r3.w, r10.w;\n"
				"ADD r10.w, r10.w, -r3.w;\n"
				"ABS r3.w, r10.w;\n"
				"CMP r3.w, -r3.w, c6.y, c6.w;\n"
				"ADD r10.w, r10.w, -c1.x;\n"
				"ABS r10.w, r10.w;\n"
				"CMP r10.w, -r10.w, c6.y, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r7.x, -r3.w, r3.x, r10.x;\n"
				"MOV r7.yzw, c6.y;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine1_arb = &__floatstreamCombine1_arb_desc;
}

void __floatstreamCombine1_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                       const __BrtFloat1  &modulus,
                                       const __BrtFloat1  &offset,
                                       const __BrtFloat1  &length,
                                       const __BrtFloat1  &lengthmodmodulus,
                                       const __BrtFloat1  &oldoutput,
                                       __BrtFloat1  &output,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = oldoutput;
  }

}
void  __floatstreamCombine1_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio5 = extents[6][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[6][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[6]);
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine1_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof6);
    i++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[6]);
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  floatstreamCombine1 (::brook::stream input0,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__floatstreamCombine1_fp[] = {
     "fp30", __floatstreamCombine1_fp30,
     "arb", __floatstreamCombine1_arb,
     "ps20", __floatstreamCombine1_ps20,
     "cpu", (void *) __floatstreamCombine1_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine1_fp);

  k->PushGatherStream(input0);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 1, 0, 0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t0.x, c5.x, c5.z\n"
				"    mad r7.y, t0.y, c5.y, c5.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r3.x, r9.x, c0.x, c0.z\n"
				"    mad r3.y, r9.y, c0.y, c0.w\n"
				"    mad r10.x, r9.x, c1.x, c1.z\n"
				"    mad r10.y, r9.y, c1.y, c1.w\n"
				"    texld r5, r3, s0\n"
				"    texld r0, r10, s1\n"
				"    mul r2.w, r7.y, c4.x\n"
				"    frc r5.w, r2.x\n"
				"    mad r5.w, r5.w, c2.x, r2.w\n"
				"    mul r0.w, r7.w, r5.w\n"
				"    frc r5.w, r0.w\n"
				"    mul r0.w, r5.w, c2.x\n"
				"    add r5.w, r0.w, c6.w\n"
				"    frc r0.w, r5.w\n"
				"    add r5.w, r5.w, -r0.w\n"
				"    abs r0.w, r5.w\n"
				"    cmp_pp r0.w, -r0.w, c6.y, c6.z\n"
				"    add r5.w, r5.w, -c2.x\n"
				"    abs r5.w, r5.w\n"
				"    cmp_pp r5.w, -r5.w, c6.y, c6.z\n"
				"    add_pp r0.w, r0.w, r5.w\n"
				"    cmp r11.x, -r0.w, r0.x, r5.x\n"
				"    mov r11.yzw, c6.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:6\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __floatstreamCombine2f_ps20 = &__floatstreamCombine2f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float length : C3 :  : 5 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 8 : 1\n"
				"#var float4 __workspace : C6 :  : 10 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, length.x;\n"
				"MULR R0.x, R1.w, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |length.x|;\n"
				"RCPR R0.y, modulus.x;\n"
				"MULR R0.y, R2.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |modulus.x|;\n"
				"MOVR R0.z, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.x;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, -{-0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SEQR H0.x, R0.x, modulus.x;\n"
				"SEQR H0.y, R0.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.x, R1.xyxx, TEX0, RECT;\n"
				"TEX R1.x, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __floatstreamCombine2f_fp30 = &__floatstreamCombine2f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c5.x, c5.z;\n"
				"MAD r7.y, t0.y, c5.y, c5.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r3.x, r9.x, c0.x, c0.z;\n"
				"MAD r3.y, r9.y, c0.y, c0.w;\n"
				"MAD r10.x, r9.x, c1.x, c1.z;\n"
				"MAD r10.y, r9.y, c1.y, c1.w;\n"
				"TEX r5, r3, texture[0], RECT;\n"
				"TEX r0, r10, texture[1], RECT;\n"
				"MUL r2.w, r7.y, c4.x;\n"
				"FRC r5.w, r2.x;\n"
				"MAD r5.w, r5.w, c2.x, r2.w;\n"
				"MUL r0.w, r7.w, r5.w;\n"
				"FRC r5.w, r0.w;\n"
				"MUL r0.w, r5.w, c2.x;\n"
				"ADD r5.w, r0.w, c6.w;\n"
				"FRC r0.w, r5.w;\n"
				"ADD r5.w, r5.w, -r0.w;\n"
				"ABS r0.w, r5.w;\n"
				"CMP r0.w, -r0.w, c6.z, c6.y;\n"
				"ADD r5.w, r5.w, -c2.x;\n"
				"ABS r5.w, r5.w;\n"
				"CMP r5.w, -r5.w, c6.z, c6.y;\n"
				"ADD r0.w, r0.w, r5.w;\n"
				"CMP r11.x, -r0.w, r5.x, r0.x;\n"
				"MOV r11.yzw, c6.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __floatstreamCombine2f_arb = &__floatstreamCombine2f_arb_desc;
}

void __floatstreamCombine2f_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                        const __BrtArray2d<__BrtFloat1  > &input1,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        __BrtFloat1  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = input1[newindex];
  }

}
void  __floatstreamCombine2f_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  unsigned int dim=dims[5];
  unsigned int newline=extents[5][dim-1];
  arg5+=mapbegin;
  ;
__BrtFloat4 indexof5 = computeIndexOf(mapbegin, extents[5], dims[5], extents[5]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine2f_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      indexof5);
    i++;
    ++arg5;
indexof5.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof5 = computeReferenceIndexOf(i+mapbegin, extents[5],dim);
    }
  }
}

void  floatstreamCombine2f (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__floatstreamCombine2f_fp[] = {
     "fp30", __floatstreamCombine2f_fp30,
     "arb", __floatstreamCombine2f_arb,
     "ps20", __floatstreamCombine2f_ps20,
     "cpu", (void *) __floatstreamCombine2f_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine2f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 0, -1, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t1.x, c6.x, c6.z\n"
				"    mad r0.y, t1.y, c6.y, c6.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r5.x, r8.x, c1.x, c1.z\n"
				"    mad r5.y, r8.y, c1.y, c1.w\n"
				"    mad r2.x, r8.x, c0.x, c0.z\n"
				"    mad r2.y, r8.y, c0.y, c0.w\n"
				"    texld r9, r5, s1\n"
				"    texld r4, t0, s2\n"
				"    texld r11, r2, s0\n"
				"    mul r9.w, r0.y, c5.x\n"
				"    frc r4.w, r7.x\n"
				"    mad r9.w, r4.w, c2.x, r9.w\n"
				"    mul r4.w, r7.w, r9.w\n"
				"    frc r9.w, r4.w\n"
				"    mul r4.w, r9.w, c2.x\n"
				"    add r9.w, r4.w, -c3.x\n"
				"    frc r4.w, r9.w\n"
				"    add r9.w, r9.w, -r4.w\n"
				"    add r4.w, r9.w, c7.z\n"
				"    abs r4.w, r4.w\n"
				"    cmp r11.w, -r4.w, r9.x, r4.x\n"
				"    abs r6.w, r9.w\n"
				"    cmp_pp r0.w, -r6.w, c7.w, c7.y\n"
				"    add r3.w, r9.w, -c2.x\n"
				"    abs r5.w, r3.w\n"
				"    cmp_pp r9.w, -r5.w, c7.w, c7.y\n"
				"    add_pp r4.w, r0.w, r9.w\n"
				"    cmp r11.x, -r4.w, r11.w, r11.x\n"
				"    mov r11.yzw, c7.y\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:1:oldoutput\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine2_ps20 = &__floatstreamCombine2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.offset : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._tex_oldoutput : TEXUNIT2\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float offset : C3 :  : 5 : 1\n"
				"#var float length : C4 :  : 6 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 7 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT2 : texunit 2 : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 11 : 1\n"
				"#var float4 __workspace : C7 :  : 13 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 10 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 12 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R1.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R2.x, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R1.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine2_fp30 = &__floatstreamCombine2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t1.x, c6.x, c6.z;\n"
				"MAD r0.y, t1.y, c6.y, c6.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r5.x, r8.x, c1.x, c1.z;\n"
				"MAD r5.y, r8.y, c1.y, c1.w;\n"
				"MAD r2.x, r8.x, c0.x, c0.z;\n"
				"MAD r2.y, r8.y, c0.y, c0.w;\n"
				"TEX r9, r5, texture[1], RECT;\n"
				"TEX r4, t0, texture[2], RECT;\n"
				"TEX r11, r2, texture[0], RECT;\n"
				"MUL r9.w, r0.y, c5.x;\n"
				"FRC r4.w, r7.x;\n"
				"MAD r9.w, r4.w, c2.x, r9.w;\n"
				"MUL r4.w, r7.w, r9.w;\n"
				"FRC r9.w, r4.w;\n"
				"MUL r4.w, r9.w, c2.x;\n"
				"ADD r9.w, r4.w, -c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"ADD r9.w, r9.w, -r4.w;\n"
				"ADD r4.w, r9.w, c7.z;\n"
				"ABS r4.w, r4.w;\n"
				"CMP r11.w, -r4.w, r4.x, r9.x;\n"
				"ABS r6.w, r9.w;\n"
				"CMP r0.w, -r6.w, c7.y, c7.w;\n"
				"ADD r3.w, r9.w, -c2.x;\n"
				"ABS r5.w, r3.w;\n"
				"CMP r9.w, -r5.w, c7.y, c7.w;\n"
				"ADD r4.w, r0.w, r9.w;\n"
				"CMP r11.x, -r4.w, r11.x, r11.w;\n"
				"MOV r11.yzw, c7.y;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine2_arb = &__floatstreamCombine2_arb_desc;
}

void __floatstreamCombine2_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                       const __BrtArray2d<__BrtFloat1  > &input1,
                                       const __BrtFloat1  &modulus,
                                       const __BrtFloat1  &offset,
                                       const __BrtFloat1  &length,
                                       const __BrtFloat1  &lengthmodmodulus,
                                       const __BrtFloat1  &oldoutput,
                                       __BrtFloat1  &output,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = oldoutput;
    }

}
void  __floatstreamCombine2_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  unsigned int ratio6 = extents[7][dim-1]/extents[6][dim-1];
  unsigned int scale6=extents[6][dim-1]/extents[7][dim-1];
  if (scale6<1) scale6 = 1;
  unsigned int ratioiter6 = 0;
  if (ratio6) ratioiter6 = mapbegin%ratio6;
  unsigned int iter6 = getIndexOf(mapbegin,extents[6], dim, extents[7]);
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine2_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *(arg6 + iter6),
      *arg7,
      indexof7);
    i++;
    if (++ratioiter6>=ratio6){
      ratioiter6=0;
      iter6+=scale6;
    }
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter6=getIndexOf(i+mapbegin,extents[6],dim, extents[7]);
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  floatstreamCombine2 (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__floatstreamCombine2_fp[] = {
     "fp30", __floatstreamCombine2_fp30,
     "arb", __floatstreamCombine2_arb,
     "ps20", __floatstreamCombine2_ps20,
     "cpu", (void *) __floatstreamCombine2_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine2_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 1, 0, 0.5\n"
				"    def c8, -1, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t0.x, c6.x, c6.z\n"
				"    mad r0.y, t0.y, c6.y, c6.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c1.x, c1.z\n"
				"    mad r10.y, r8.y, c1.y, c1.w\n"
				"    mad r9.x, r8.x, c2.x, c2.z\n"
				"    mad r9.y, r8.y, c2.y, c2.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s1\n"
				"    texld r6, r9, s2\n"
				"    texld r1, r4, s0\n"
				"    mul r11.w, r0.y, c5.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, c7.w\n"
				"    frc r6.w, r11.w\n"
				"    add r11.w, r11.w, -r6.w\n"
				"    add r6.w, r11.w, c8.x\n"
				"    abs r6.w, r6.w\n"
				"    cmp r1.w, -r6.w, r11.x, r6.x\n"
				"    abs r0.w, r11.w\n"
				"    cmp_pp r3.w, -r0.w, c7.y, c7.z\n"
				"    add r5.w, r11.w, -c3.x\n"
				"    abs r9.w, r5.w\n"
				"    cmp_pp r11.w, -r9.w, c7.y, c7.z\n"
				"    add_pp r6.w, r3.w, r11.w\n"
				"    cmp r1.x, -r6.w, r1.w, r1.x\n"
				"    mov r1.yzw, c7.z\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine3f_ps20 = &__floatstreamCombine3f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float length : C4 :  : 7 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R0.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.x, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.x, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"TEX R0.x, R1.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine3f_fp30 = &__floatstreamCombine3f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c8 = {-1, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t0.x, c6.x, c6.z;\n"
				"MAD r0.y, t0.y, c6.y, c6.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c1.x, c1.z;\n"
				"MAD r10.y, r8.y, c1.y, c1.w;\n"
				"MAD r9.x, r8.x, c2.x, c2.z;\n"
				"MAD r9.y, r8.y, c2.y, c2.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[1], RECT;\n"
				"TEX r6, r9, texture[2], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c5.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, c7.w;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r11.w, r11.w, -r6.w;\n"
				"ADD r6.w, r11.w, c8.x;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r1.w, -r6.w, r6.x, r11.x;\n"
				"ABS r0.w, r11.w;\n"
				"CMP r3.w, -r0.w, c7.z, c7.y;\n"
				"ADD r5.w, r11.w, -c3.x;\n"
				"ABS r9.w, r5.w;\n"
				"CMP r11.w, -r9.w, c7.z, c7.y;\n"
				"ADD r6.w, r3.w, r11.w;\n"
				"CMP r1.x, -r6.w, r1.x, r1.w;\n"
				"MOV r1.yzw, c7.z;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __floatstreamCombine3f_arb = &__floatstreamCombine3f_arb_desc;
}

void __floatstreamCombine3f_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                        const __BrtArray2d<__BrtFloat1  > &input1,
                                        const __BrtArray2d<__BrtFloat1  > &input2,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        __BrtFloat1  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = input2[newindex];
    }

}
void  __floatstreamCombine3f_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine3f_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof6);
    i++;
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  floatstreamCombine3f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__floatstreamCombine3f_fp[] = {
     "fp30", __floatstreamCombine3f_fp30,
     "arb", __floatstreamCombine3f_arb,
     "ps20", __floatstreamCombine3f_ps20,
     "cpu", (void *) __floatstreamCombine3f_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine3f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 0, -1, 1\n"
				"    def c9, -2, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    rcp r0.w, c5.x\n"
				"    mad r0.x, t1.x, c7.x, c7.z\n"
				"    mad r0.y, t1.y, c7.y, c7.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c5.x, r7.x\n"
				"    add r11.w, r4.w, c8.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c5.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c8.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c2.x, c2.z\n"
				"    mad r10.y, r8.y, c2.y, c2.w\n"
				"    mad r9.x, r8.x, c1.x, c1.z\n"
				"    mad r9.y, r8.y, c1.y, c1.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s2\n"
				"    texld r6, t0, s3\n"
				"    texld r1, r9, s1\n"
				"    texld r8, r4, s0\n"
				"    mul r11.w, r0.y, c6.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, -c4.x\n"
				"    frc r6.w, r11.w\n"
				"    add r1.w, r11.w, -r6.w\n"
				"    add r11.w, r1.w, c9.x\n"
				"    abs r11.w, r11.w\n"
				"    cmp r8.w, -r11.w, r11.x, r6.x\n"
				"    add r7.w, r1.w, c8.z\n"
				"    abs r3.w, r7.w\n"
				"    cmp r8.w, -r3.w, r1.x, r8.w\n"
				"    abs r2.w, r1.w\n"
				"    cmp_pp r4.w, -r2.w, c8.w, c8.y\n"
				"    add r1.w, r1.w, -c3.x\n"
				"    abs r7.w, r1.w\n"
				"    cmp_pp r3.w, -r7.w, c8.w, c8.y\n"
				"    add_pp r10.w, r4.w, r3.w\n"
				"    cmp r8.x, -r10.w, r8.w, r8.x\n"
				"    mov r8.yzw, c8.y\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:1:oldoutput\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine3_ps20 = &__floatstreamCombine3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.offset : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._tex_oldoutput : TEXUNIT3\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float offset : C4 :  : 7 : 1\n"
				"#var float length : C5 :  : 8 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 9 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT3 : texunit 3 : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 13 : 1\n"
				"#var float4 __workspace : C8 :  : 15 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 12 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 14 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX3, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"SEQR H0.w, R1.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.x, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R3.x;\n"
				"TEX R1.x, R2.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine3_fp30 = &__floatstreamCombine3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 0, -1, 1};\n"
				"PARAM c9 = {-2, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c5.x;\n"
				"MAD r0.x, t1.x, c7.x, c7.z;\n"
				"MAD r0.y, t1.y, c7.y, c7.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c5.x, r7.x;\n"
				"ADD r11.w, r4.w, c8.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c5.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c8.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c2.x, c2.z;\n"
				"MAD r10.y, r8.y, c2.y, c2.w;\n"
				"MAD r9.x, r8.x, c1.x, c1.z;\n"
				"MAD r9.y, r8.y, c1.y, c1.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[2], RECT;\n"
				"TEX r6, t0, texture[3], RECT;\n"
				"TEX r1, r9, texture[1], RECT;\n"
				"TEX r8, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c6.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, -c4.x;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r1.w, r11.w, -r6.w;\n"
				"ADD r11.w, r1.w, c9.x;\n"
				"ABS r11.w, r11.w;\n"
				"CMP r8.w, -r11.w, r6.x, r11.x;\n"
				"ADD r7.w, r1.w, c8.z;\n"
				"ABS r3.w, r7.w;\n"
				"CMP r8.w, -r3.w, r8.w, r1.x;\n"
				"ABS r2.w, r1.w;\n"
				"CMP r4.w, -r2.w, c8.y, c8.w;\n"
				"ADD r1.w, r1.w, -c3.x;\n"
				"ABS r7.w, r1.w;\n"
				"CMP r3.w, -r7.w, c8.y, c8.w;\n"
				"ADD r10.w, r4.w, r3.w;\n"
				"CMP r8.x, -r10.w, r8.x, r8.w;\n"
				"MOV r8.yzw, c8.y;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine3_arb = &__floatstreamCombine3_arb_desc;
}

void __floatstreamCombine3_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                       const __BrtArray2d<__BrtFloat1  > &input1,
                                       const __BrtArray2d<__BrtFloat1  > &input2,
                                       const __BrtFloat1  &modulus,
                                       const __BrtFloat1  &offset,
                                       const __BrtFloat1  &length,
                                       const __BrtFloat1  &lengthmodmodulus,
                                       const __BrtFloat1  &oldoutput,
                                       __BrtFloat1  &output,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = oldoutput;
      }

}
void  __floatstreamCombine3_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat1 *arg8 = (__BrtFloat1 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  unsigned int ratio7 = extents[8][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[8][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[8]);
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine3_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *(arg7 + iter7),
      *arg8,
      indexof8);
    i++;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[8]);
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  floatstreamCombine3 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__floatstreamCombine3_fp[] = {
     "fp30", __floatstreamCombine3_fp30,
     "arb", __floatstreamCombine3_arb,
     "ps20", __floatstreamCombine3_ps20,
     "cpu", (void *) __floatstreamCombine3_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine3_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 1, 0, 0.5\n"
				"    def c9, -1, 0, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    mad r7.x, t0.x, c7.x, c7.z\n"
				"    mad r7.y, t0.y, c7.y, c7.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c5.x, r2.x\n"
				"    add r9.w, r2.y, c8.x\n"
				"    add r2.w, r2.w, c8.x\n"
				"    rcp r4.w, c5.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c5.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c2.x, c2.z\n"
				"    mad r8.y, r9.y, c2.y, c2.w\n"
				"    mad r10.x, r9.x, c3.x, c3.z\n"
				"    mad r10.y, r9.y, c3.y, c3.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s2\n"
				"    texld r9, r10, s3\n"
				"    texld r1, r4, s1\n"
				"    texld r8, r11, s0\n"
				"    mul r2.w, r7.y, c6.x\n"
				"    frc r6.w, r2.x\n"
				"    mad r6.w, r6.w, c4.x, r2.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r6.w, r9.w, c8.w\n"
				"    frc r9.w, r6.w\n"
				"    add r1.w, r6.w, -r9.w\n"
				"    add r6.w, r1.w, c9.w\n"
				"    abs r6.w, r6.w\n"
				"    cmp r8.w, -r6.w, r6.x, r9.x\n"
				"    add r7.w, r1.w, c9.x\n"
				"    abs r10.w, r7.w\n"
				"    cmp r8.w, -r10.w, r1.x, r8.w\n"
				"    abs r4.w, r1.w\n"
				"    cmp_pp r2.w, -r4.w, c8.y, c8.z\n"
				"    add r1.w, r1.w, -c4.x\n"
				"    abs r7.w, r1.w\n"
				"    cmp_pp r10.w, -r7.w, c8.y, c8.z\n"
				"    add_pp r5.w, r2.w, r10.w\n"
				"    cmp r8.x, -r5.w, r8.w, r8.x\n"
				"    mov r8.yzw, c8.z\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//c:1:input3\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine4f_ps20 = &__floatstreamCombine4f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float length : C5 :  : 9 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 12 : 1\n"
				"#var float4 __workspace : C8 :  : 14 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 11 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"SEQR H0.w, R0.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.x, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.x, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"TEX R0.x, R1.xyxx, TEX2, RECT;\n"
				"TEX R1.x, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine4f_fp30 = &__floatstreamCombine4f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c9 = {-1, 0, 0, -2};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c7.x, c7.z;\n"
				"MAD r7.y, t0.y, c7.y, c7.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c5.x, r2.x;\n"
				"ADD r9.w, r2.y, c8.x;\n"
				"ADD r2.w, r2.w, c8.x;\n"
				"RCP r4.w, c5.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c5.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c2.x, c2.z;\n"
				"MAD r8.y, r9.y, c2.y, c2.w;\n"
				"MAD r10.x, r9.x, c3.x, c3.z;\n"
				"MAD r10.y, r9.y, c3.y, c3.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[2], RECT;\n"
				"TEX r9, r10, texture[3], RECT;\n"
				"TEX r1, r4, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c6.x;\n"
				"FRC r6.w, r2.x;\n"
				"MAD r6.w, r6.w, c4.x, r2.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r6.w, r9.w, c8.w;\n"
				"FRC r9.w, r6.w;\n"
				"ADD r1.w, r6.w, -r9.w;\n"
				"ADD r6.w, r1.w, c9.w;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r8.w, -r6.w, r9.x, r6.x;\n"
				"ADD r7.w, r1.w, c9.x;\n"
				"ABS r10.w, r7.w;\n"
				"CMP r8.w, -r10.w, r8.w, r1.x;\n"
				"ABS r4.w, r1.w;\n"
				"CMP r2.w, -r4.w, c8.z, c8.y;\n"
				"ADD r1.w, r1.w, -c4.x;\n"
				"ABS r7.w, r1.w;\n"
				"CMP r10.w, -r7.w, c8.z, c8.y;\n"
				"ADD r5.w, r2.w, r10.w;\n"
				"CMP r8.x, -r5.w, r8.x, r8.w;\n"
				"MOV r8.yzw, c8.z;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __floatstreamCombine4f_arb = &__floatstreamCombine4f_arb_desc;
}

void __floatstreamCombine4f_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                        const __BrtArray2d<__BrtFloat1  > &input1,
                                        const __BrtArray2d<__BrtFloat1  > &input2,
                                        const __BrtArray2d<__BrtFloat1  > &input3,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        __BrtFloat1  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = input3[newindex];
      }

}
void  __floatstreamCombine4f_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat1  > arg3(
      (__BrtFloat1  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine4f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      indexof7);
    i++;
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  floatstreamCombine4f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__floatstreamCombine4f_fp[] = {
     "fp30", __floatstreamCombine4f_fp30,
     "arb", __floatstreamCombine4f_arb,
     "ps20", __floatstreamCombine4f_ps20,
     "cpu", (void *) __floatstreamCombine4f_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine4f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 0, -1, 1\n"
				"    def c10, -2, 0, 0, -3\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t1.x, c8.x, c8.z\n"
				"    mad r7.y, t1.y, c8.y, c8.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c2.x, c2.z\n"
				"    mad r10.y, r9.y, c2.y, c2.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s3\n"
				"    texld r9, t0, s4\n"
				"    texld r1, r10, s2\n"
				"    texld r8, r4, s1\n"
				"    texld r3, r11, s0\n"
				"    mul r2.w, r7.y, c7.x\n"
				"    frc r6.w, r2.x\n"
				"    mad r6.w, r6.w, c4.x, r2.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r9.w, r9.w, -c5.x\n"
				"    frc r6.w, r9.w\n"
				"    add r8.w, r9.w, -r6.w\n"
				"    add r9.w, r8.w, c10.w\n"
				"    abs r9.w, r9.w\n"
				"    cmp r1.w, -r9.w, r6.x, r9.x\n"
				"    add r3.w, r8.w, c10.x\n"
				"    abs r3.w, r3.w\n"
				"    cmp r3.w, -r3.w, r1.x, r1.w\n"
				"    add r10.w, r8.w, c9.z\n"
				"    abs r0.w, r10.w\n"
				"    cmp r3.w, -r0.w, r8.x, r3.w\n"
				"    abs r2.w, r8.w\n"
				"    cmp_pp r6.w, -r2.w, c9.w, c9.y\n"
				"    add r8.w, r8.w, -c4.x\n"
				"    abs r10.w, r8.w\n"
				"    cmp_pp r0.w, -r10.w, c9.w, c9.y\n"
				"    add_pp r4.w, r6.w, r0.w\n"
				"    cmp r3.x, -r4.w, r3.w, r3.x\n"
				"    mov r3.yzw, c9.y\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:10\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//c:1:input3\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:1:oldoutput\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __floatstreamCombine4_ps20 = &__floatstreamCombine4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.offset : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._tex_oldoutput : TEXUNIT4\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float offset : C5 :  : 9 : 1\n"
				"#var float length : C6 :  : 10 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 11 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT4 : texunit 4 : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 15 : 1\n"
				"#var float4 __workspace : C9 :  : 17 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 14 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 16 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX4, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R1.y, {2}.x;\n"
				"SEQR H0.w, R1.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.x, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R3.x;\n"
				"TEX R1.x, R2.xyxx, TEX2, RECT;\n"
				"TEX R2.x, R2.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __floatstreamCombine4_fp30 = &__floatstreamCombine4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-2, 0, 0, -3};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c8.x, c8.z;\n"
				"MAD r7.y, t1.y, c8.y, c8.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c2.x, c2.z;\n"
				"MAD r10.y, r9.y, c2.y, c2.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[3], RECT;\n"
				"TEX r9, t0, texture[4], RECT;\n"
				"TEX r1, r10, texture[2], RECT;\n"
				"TEX r8, r4, texture[1], RECT;\n"
				"TEX r3, r11, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c7.x;\n"
				"FRC r6.w, r2.x;\n"
				"MAD r6.w, r6.w, c4.x, r2.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r9.w, r9.w, -c5.x;\n"
				"FRC r6.w, r9.w;\n"
				"ADD r8.w, r9.w, -r6.w;\n"
				"ADD r9.w, r8.w, c10.w;\n"
				"ABS r9.w, r9.w;\n"
				"CMP r1.w, -r9.w, r9.x, r6.x;\n"
				"ADD r3.w, r8.w, c10.x;\n"
				"ABS r3.w, r3.w;\n"
				"CMP r3.w, -r3.w, r1.w, r1.x;\n"
				"ADD r10.w, r8.w, c9.z;\n"
				"ABS r0.w, r10.w;\n"
				"CMP r3.w, -r0.w, r3.w, r8.x;\n"
				"ABS r2.w, r8.w;\n"
				"CMP r6.w, -r2.w, c9.y, c9.w;\n"
				"ADD r8.w, r8.w, -c4.x;\n"
				"ABS r10.w, r8.w;\n"
				"CMP r0.w, -r10.w, c9.y, c9.w;\n"
				"ADD r4.w, r6.w, r0.w;\n"
				"CMP r3.x, -r4.w, r3.x, r3.w;\n"
				"MOV r3.yzw, c9.y;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:1:oldoutput\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __floatstreamCombine4_arb = &__floatstreamCombine4_arb_desc;
}

void __floatstreamCombine4_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                       const __BrtArray2d<__BrtFloat1  > &input1,
                                       const __BrtArray2d<__BrtFloat1  > &input2,
                                       const __BrtArray2d<__BrtFloat1  > &input3,
                                       const __BrtFloat1  &modulus,
                                       const __BrtFloat1  &offset,
                                       const __BrtFloat1  &length,
                                       const __BrtFloat1  &lengthmodmodulus,
                                       const __BrtFloat1  &oldoutput,
                                       __BrtFloat1  &output,
                                       const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = oldoutput;
        }

}
void  __floatstreamCombine4_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat1  > arg3(
      (__BrtFloat1  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat1 *arg8 = (__BrtFloat1 *)args[8];
  __BrtFloat1 *arg9 = (__BrtFloat1 *)args[9];
  unsigned int dim=dims[9];
  unsigned int newline=extents[9][dim-1];
  unsigned int ratio8 = extents[9][dim-1]/extents[8][dim-1];
  unsigned int scale8=extents[8][dim-1]/extents[9][dim-1];
  if (scale8<1) scale8 = 1;
  unsigned int ratioiter8 = 0;
  if (ratio8) ratioiter8 = mapbegin%ratio8;
  unsigned int iter8 = getIndexOf(mapbegin,extents[8], dim, extents[9]);
  arg9+=mapbegin;
  ;
__BrtFloat4 indexof9 = computeIndexOf(mapbegin, extents[9], dims[9], extents[9]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine4_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      *(arg8 + iter8),
      *arg9,
      indexof9);
    i++;
    if (++ratioiter8>=ratio8){
      ratioiter8=0;
      iter8+=scale8;
    }
    ++arg9;
indexof9.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter8=getIndexOf(i+mapbegin,extents[8],dim, extents[9]);
      indexof9 = computeReferenceIndexOf(i+mapbegin, extents[9],dim);
    }
  }
}

void  floatstreamCombine4 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__floatstreamCombine4_fp[] = {
     "fp30", __floatstreamCombine4_fp30,
     "arb", __floatstreamCombine4_arb,
     "ps20", __floatstreamCombine4_ps20,
     "cpu", (void *) __floatstreamCombine4_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine4_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine5f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 1, 0, 0.5\n"
				"    def c10, -1, -3, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t0.x, c8.x, c8.z\n"
				"    mad r7.y, t0.y, c8.y, c8.w\n"
				"    rcp r7.w, c5.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c4.x, c4.z\n"
				"    mad r10.y, r9.y, c4.y, c4.w\n"
				"    mad r0.x, r9.x, c2.x, c2.z\n"
				"    mad r0.y, r9.y, c2.y, c2.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    mov r4.xy, r9\n"
				"    mad r9.x, r4.x, c0.x, c0.z\n"
				"    mad r9.y, r4.y, c0.y, c0.w\n"
				"    texld r1, r8, s3\n"
				"    texld r8, r10, s4\n"
				"    texld r3, r0, s2\n"
				"    texld r10, r6, s1\n"
				"    texld r5, r9, s0\n"
				"    mul r2.w, r7.y, c7.x\n"
				"    frc r1.w, r2.x\n"
				"    mad r1.w, r1.w, c5.x, r2.w\n"
				"    mul r8.w, r7.w, r1.w\n"
				"    frc r1.w, r8.w\n"
				"    mul r8.w, r1.w, c5.x\n"
				"    add r1.w, r8.w, c9.w\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    add r1.w, r10.w, c10.y\n"
				"    abs r1.w, r1.w\n"
				"    cmp r3.w, -r1.w, r1.x, r8.x\n"
				"    add r5.w, r10.w, c10.w\n"
				"    abs r5.w, r5.w\n"
				"    cmp r5.w, -r5.w, r3.x, r3.w\n"
				"    add r0.w, r10.w, c10.x\n"
				"    abs r11.w, r0.w\n"
				"    cmp r5.w, -r11.w, r10.x, r5.w\n"
				"    abs r2.w, r10.w\n"
				"    cmp_pp r8.w, -r2.w, c9.y, c9.z\n"
				"    add r10.w, r10.w, -c5.x\n"
				"    abs r0.w, r10.w\n"
				"    cmp_pp r11.w, -r0.w, c9.y, c9.z\n"
				"    add_pp r6.w, r8.w, r11.w\n"
				"    cmp r5.x, -r6.w, r5.w, r5.x\n"
				"    mov r5.yzw, c9.z\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:1:input0\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//c:1:input3\n"
				"//c:1:input4\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:1:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine5f_ps20 = &__floatstreamCombine5f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine5f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.input4 : TEXUNIT4\n"
				"#semantic main.__gatherconst_input4 : C4\n"
				"#semantic main.modulus : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var samplerRECT input4[0] : TEXUNIT4 : texunit 4 : 8 : 1\n"
				"#var float4 __gatherconst_input4 : C4 :  : 9 : 1\n"
				"#var float modulus : C5 :  : 10 : 1\n"
				"#var float length : C6 :  : 11 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 14 : 1\n"
				"#var float4 __workspace : C9 :  : 16 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 13 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 15 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE __gatherconst_input4;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R0.y, {2}.x;\n"
				"SEQR H0.w, R0.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.x, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.x, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"TEX R0.x, R1.xyxx, TEX2, RECT;\n"
				"TEX R2.x, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].x(GT.x), R2.x;\n"
				"TEX R0.x, R1.xyxx, TEX4, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine5f_fp30 = &__floatstreamCombine5f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __floatstreamCombine5f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-1, -3, 0, -2};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c8.x, c8.z;\n"
				"MAD r7.y, t0.y, c8.y, c8.w;\n"
				"RCP r7.w, c5.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c4.x, c4.z;\n"
				"MAD r10.y, r9.y, c4.y, c4.w;\n"
				"MAD r0.x, r9.x, c2.x, c2.z;\n"
				"MAD r0.y, r9.y, c2.y, c2.w;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"MOV r4.xy, r9;\n"
				"MAD r9.x, r4.x, c0.x, c0.z;\n"
				"MAD r9.y, r4.y, c0.y, c0.w;\n"
				"TEX r1, r8, texture[3], RECT;\n"
				"TEX r8, r10, texture[4], RECT;\n"
				"TEX r3, r0, texture[2], RECT;\n"
				"TEX r10, r6, texture[1], RECT;\n"
				"TEX r5, r9, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c7.x;\n"
				"FRC r1.w, r2.x;\n"
				"MAD r1.w, r1.w, c5.x, r2.w;\n"
				"MUL r8.w, r7.w, r1.w;\n"
				"FRC r1.w, r8.w;\n"
				"MUL r8.w, r1.w, c5.x;\n"
				"ADD r1.w, r8.w, c9.w;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"ADD r1.w, r10.w, c10.y;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r3.w, -r1.w, r8.x, r1.x;\n"
				"ADD r5.w, r10.w, c10.w;\n"
				"ABS r5.w, r5.w;\n"
				"CMP r5.w, -r5.w, r3.w, r3.x;\n"
				"ADD r0.w, r10.w, c10.x;\n"
				"ABS r11.w, r0.w;\n"
				"CMP r5.w, -r11.w, r5.w, r10.x;\n"
				"ABS r2.w, r10.w;\n"
				"CMP r8.w, -r2.w, c9.z, c9.y;\n"
				"ADD r10.w, r10.w, -c5.x;\n"
				"ABS r0.w, r10.w;\n"
				"CMP r11.w, -r0.w, c9.z, c9.y;\n"
				"ADD r6.w, r8.w, r11.w;\n"
				"CMP r5.x, -r6.w, r5.x, r5.w;\n"
				"MOV r5.yzw, c9.z;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:1:input0\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##c:1:input3\n"
				"##c:1:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __floatstreamCombine5f_arb = &__floatstreamCombine5f_arb_desc;
}

void __floatstreamCombine5f_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input0,
                                        const __BrtArray2d<__BrtFloat1  > &input1,
                                        const __BrtArray2d<__BrtFloat1  > &input2,
                                        const __BrtArray2d<__BrtFloat1  > &input3,
                                        const __BrtArray2d<__BrtFloat1  > &input4,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        __BrtFloat1  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = input4[newindex];
        }

}
void  __floatstreamCombine5f_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat1  > arg2(
      (__BrtFloat1  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat1  > arg3(
      (__BrtFloat1  *)args[3], extents[3]);
  __BrtArray2d<__BrtFloat1  > arg4(
      (__BrtFloat1  *)args[4], extents[4]);
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat1 *arg8 = (__BrtFloat1 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __floatstreamCombine5f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      *arg5,
      *arg6,
      *arg7,
      *arg8,
      indexof8);
    i++;
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  floatstreamCombine5f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		::brook::stream input4,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__floatstreamCombine5f_fp[] = {
     "fp30", __floatstreamCombine5f_fp30,
     "arb", __floatstreamCombine5f_arb,
     "ps20", __floatstreamCombine5f_ps20,
     "cpu", (void *) __floatstreamCombine5f_cpu,
     NULL, NULL };
  static __BRTKernel k(__floatstreamCombine5f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushGatherStream(input4);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}


void  combineStreamsHelperfloat(::brook::stream (**streams), unsigned int  num, ::brook::stream output, float  modulus, float  offset, float  length, float  lengthmodmodulus)
{
  switch (num)
  {
  case 1:
    floatstreamCombine1(*streams[0],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 2:
    floatstreamCombine2(*streams[0],*streams[1],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 3:
    floatstreamCombine3(*streams[0],*streams[1],*streams[2],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 4:
  default:
    floatstreamCombine4(*streams[0],*streams[1],*streams[2],*streams[3],modulus,offset,length,lengthmodmodulus,output,output);
    if (num > 4)
    {
      combineStreamsHelperfloat(streams + 4,num - 4,output,modulus,4 + offset,length,lengthmodmodulus);
    }

  }

}

void  combineStreamsfloat(::brook::stream (**streams), unsigned int  num, unsigned int  width, unsigned int  length, ::brook::stream (*output))
{
  unsigned int  lengthmodmodulus = (num != 0) ? (length % num) : (0);
  ::brook::stream tmp=quickAllocStream(::brook::getStreamType(( float  *)0), num * width , length,-1);

  streamSwap(tmp,*output);
  switch (num)
  {
  case 0:
    return;
  case 1:
    streamSwap(*output,*streams[0]);
    break;
  case 2:
    floatstreamCombine2f(*streams[0],*streams[1],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 3:
    floatstreamCombine3f(*streams[0],*streams[1],*streams[2],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 4:
    floatstreamCombine4f(*streams[0],*streams[1],*streams[2],*streams[3],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 5:
  default:
    floatstreamCombine5f(*streams[0],*streams[1],*streams[2],*streams[3],*streams[4],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    if (num > MAX_VOUT_STREAMS)
    {
      fprintf(stderr,"vout stream not reconstituted properly. %s%d streams","Too little precision for more than ",MAX_VOUT_STREAMS);
    }

    if (num > 5)
    {
      combineStreamsHelperfloat(streams + 5,num - 5,*output,(float ) (num),(float ) (5 - 0.500000f),(float ) (length),(float ) (lengthmodmodulus));
    }

  }

}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0, 0.5, -0.5, 1\n"
				"    def c8, 0.25, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r0.x, t0.x, c2.x, c2.z\n"
				"    mad r0.y, t0.y, c2.y, c2.w\n"
				"    add r0.w, -c3.x, r0.x\n"
				"    add r7.w, r0.w, c7.y\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c5.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r1.w, r7.w, r11.w\n"
				"    frc r8.w, r6.w\n"
				"    mul r3.w, r8.w, c5.x\n"
				"    add r10.w, r3.w, c7.y\n"
				"    frc r5.w, r10.w\n"
				"    add r2.w, r10.w, -r5.w\n"
				"    add r4.w, -r2.w, c7.z\n"
				"    add r11.w, r2.w, c5.x\n"
				"    cmp r6.w, r4.w, r11.w, r2.w\n"
				"    add r8.w, r6.w, c8.x\n"
				"    add r10.w, r8.w, -c5.x\n"
				"    cmp r1.x, r10.w, c7.x, r6.w\n"
				"    frc r5.w, r1.w\n"
				"    add r1.w, r1.w, -r5.w\n"
				"    add r9.w, r0.y, -c3.y\n"
				"    add r1.y, r1.w, r9.w\n"
				"    mad r9.x, r1.x, c1.x, c1.z\n"
				"    mad r9.y, r1.y, c1.y, c1.w\n"
				"    mad r11.x, r0.x, c0.x, c0.z\n"
				"    mad r11.y, r0.y, c0.y, c0.w\n"
				"    texld r6, r9, s1\n"
				"    texld r8, r11, s0\n"
				"    cmp_pp r1.w, r0.w, c7.w, c7.x\n"
				"    add r6.w, r1.x, -c4.x\n"
				"    cmp_pp r6.w, r6.w, c7.w, c7.x\n"
				"    add r0.w, r1.y, -c4.y\n"
				"    abs r0.w, r0.w\n"
				"    cmp_pp r0.w, -r0.w, c7.w, c7.x\n"
				"    mul r6.w, r6.w, r0.w\n"
				"    add r0.w, -r1.y, c4.y\n"
				"    cmp_pp r0.w, r0.w, c7.x, c7.w\n"
				"    add_pp r6.w, r6.w, r0.w\n"
				"    cmp r8.w, -r6.w, r6.x, c6.x\n"
				"    abs r0.w, r9.w\n"
				"    cmp_pp r0.w, -r0.w, c7.w, c7.x\n"
				"    mul r0.w, r1.w, r0.w\n"
				"    add r10.w, -r0.y, c3.y\n"
				"    cmp_pp r5.w, r10.w, c7.x, c7.w\n"
				"    add_pp r7.w, r0.w, r5.w\n"
				"    cmp r9.x, -r7.w, r8.x, r8.w\n"
				"    mov r9.yzw, c7.x\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:input1\n"
				"//c:1:input2\n"
				"//oi:1:output\n"
				"//c:2:startsecond\n"
				"//c:2:endsecond\n"
				"//c:2:maxinput2value\n"
				"//c:1:inf\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat_ps20 = &__combinefloat_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input1 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input1 : C0\n"
				"#semantic main.input2 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input2 : C1\n"
				"#semantic main._const_output_invscalebias : C2\n"
				"#semantic main.startsecond : C3\n"
				"#semantic main.endsecond : C4\n"
				"#semantic main.maxinput2value : C5\n"
				"#semantic main.inf : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input1[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input1 : C0 :  : 1 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input2 : C1 :  : 3 : 1\n"
				"#var float4 _const_output_invscalebias : C2 :  : 5 : 1\n"
				"#var float2 startsecond : C3 :  : 7 : 1\n"
				"#var float2 endsecond : C4 :  : 8 : 1\n"
				"#var float2 maxinput2value : C5 :  : 9 : 1\n"
				"#var float inf : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 6 : 1\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE startsecond;\n"
				"DECLARE endsecond;\n"
				"DECLARE maxinput2value;\n"
				"DECLARE inf;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SGTR H0.x, R0.y, startsecond.y;\n"
				"SGER H0.y, R0.x, startsecond.x;\n"
				"SEQR H0.z, R0.y, startsecond.y;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDR R0.w, R0.y, -startsecond.y;\n"
				"MOVR R1.y, R0.w;\n"
				"MOVR R1.x, R0.x;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.w, R1.x, -startsecond.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxinput2value.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.z, R1.x, {0}.x;\n"
				"RCPR R1.y, maxinput2value.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxinput2value.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.z, R1.x, {-0.5}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxinput2value.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.z, R1.x, maxinput2value.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SGTR H0.z, R3.y, endsecond.y;\n"
				"SGER H0.w, R3.x, endsecond.x;\n"
				"SEQR H1.x, R3.y, endsecond.y;\n"
				"MADX H0.z, H1.x, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"TEX R1.x, R3.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].x, inf.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].x(GT.x), R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##oi:1:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat_fp30 = &__combinefloat_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0, 0.5, -0.5, 1};\n"
				"PARAM c8 = {0.25, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r0.x, t0.x, c2.x, c2.z;\n"
				"MAD r0.y, t0.y, c2.y, c2.w;\n"
				"ADD r0.w, -c3.x, r0.x;\n"
				"ADD r7.w, r0.w, c7.y;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c5.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r1.w, r7.w, r11.w;\n"
				"FRC r8.w, r6.w;\n"
				"MUL r3.w, r8.w, c5.x;\n"
				"ADD r10.w, r3.w, c7.y;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r2.w, r10.w, -r5.w;\n"
				"ADD r4.w, -r2.w, c7.z;\n"
				"ADD r11.w, r2.w, c5.x;\n"
				"CMP r6.w, r4.w, r2.w, r11.w;\n"
				"ADD r8.w, r6.w, c8.x;\n"
				"ADD r10.w, r8.w, -c5.x;\n"
				"CMP r1.x, r10.w, r6.w, c7.x;\n"
				"FRC r5.w, r1.w;\n"
				"ADD r1.w, r1.w, -r5.w;\n"
				"ADD r9.w, r0.y, -c3.y;\n"
				"ADD r1.y, r1.w, r9.w;\n"
				"MAD r9.x, r1.x, c1.x, c1.z;\n"
				"MAD r9.y, r1.y, c1.y, c1.w;\n"
				"MAD r11.x, r0.x, c0.x, c0.z;\n"
				"MAD r11.y, r0.y, c0.y, c0.w;\n"
				"TEX r6, r9, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"CMP r1.w, r0.w, c7.x, c7.w;\n"
				"ADD r6.w, r1.x, -c4.x;\n"
				"CMP r6.w, r6.w, c7.x, c7.w;\n"
				"ADD r0.w, r1.y, -c4.y;\n"
				"ABS r0.w, r0.w;\n"
				"CMP r0.w, -r0.w, c7.x, c7.w;\n"
				"MUL r6.w, r6.w, r0.w;\n"
				"ADD r0.w, -r1.y, c4.y;\n"
				"CMP r0.w, r0.w, c7.w, c7.x;\n"
				"ADD r6.w, r6.w, r0.w;\n"
				"CMP r8.w, -r6.w, c6.x, r6.x;\n"
				"ABS r0.w, r9.w;\n"
				"CMP r0.w, -r0.w, c7.x, c7.w;\n"
				"MUL r0.w, r1.w, r0.w;\n"
				"ADD r10.w, -r0.y, c3.y;\n"
				"CMP r5.w, r10.w, c7.w, c7.x;\n"
				"ADD r7.w, r0.w, r5.w;\n"
				"CMP r9.x, -r7.w, r8.w, r8.x;\n"
				"MOV r9.yzw, c7.x;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:input1\n"
				"##c:1:input2\n"
				"##oi:1:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat_arb = &__combinefloat_arb_desc;
}

void __combinefloat_cpu_inner (const __BrtArray2d<__BrtFloat1  > &input1,
                                const __BrtArray2d<__BrtFloat1  > &input2,
                                __BrtFloat1  &output,
                                const __BrtFloat2  &startsecond,
                                const __BrtFloat2  &endsecond,
                                const __BrtFloat2  &maxinput2value,
                                const __BrtFloat1  &inf,
                                const __BrtFloat4 &__indexof_output){
  if ((__indexof_output).swizzle1(maskY) > startsecond.swizzle1(maskY) || (__indexof_output).swizzle1(maskY) == startsecond.swizzle1(maskY) && (__indexof_output).swizzle1(maskX) >= startsecond.swizzle1(maskX))
  {
    __BrtFloat2  secondindex;

    __getIndexAt_cpu_inner(__BrtFloat4 ((__indexof_output).swizzle1(maskX),(__indexof_output).swizzle1(maskY) - startsecond.swizzle1(maskY),__BrtFloat1((float)0),__BrtFloat1((float)0)),-startsecond.swizzle1(maskX),maxinput2value,secondindex);
    if (secondindex.swizzle1(maskY) > endsecond.swizzle1(maskY) || secondindex.swizzle1(maskY) == endsecond.swizzle1(maskY) && secondindex.swizzle1(maskX) >= endsecond.swizzle1(maskX))
    {
      output = inf;
    }

    else
    {
      output = input2[secondindex];
    }

  }

  else
  {
    output = input1[__indexof_output];
  }

}
void  __combinefloat_cpu (const std::vector<void *>&args,
                          const std::vector<const unsigned int *>&extents,
                          const std::vector<unsigned int>&dims,
                          unsigned int mapbegin, 
                          unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  ;
__BrtFloat4 indexof2 = computeIndexOf(mapbegin, extents[2], dims[2], extents[2]);
  unsigned int i=0; 
  while (i<mapextent) {
    __combinefloat_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof2);
    i++;
    ++arg2;
indexof2.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof2 = computeReferenceIndexOf(i+mapbegin, extents[2],dim);
    }
  }
}

void  combinefloat (::brook::stream input1,
		::brook::stream input2,
		::brook::stream output,
		const float2  startsecond,
		const float2  endsecond,
		const float2  maxinput2value,
		const float  inf) {
  static const void *__combinefloat_fp[] = {
     "fp30", __combinefloat_fp30,
     "arb", __combinefloat_arb,
     "ps20", __combinefloat_ps20,
     "cpu", (void *) __combinefloat_cpu,
     NULL, NULL };
  static __BRTKernel k(__combinefloat_fp);

  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushOutput(output);
  k->PushConstant(startsecond);
  k->PushConstant(endsecond);
  k->PushConstant(maxinput2value);
  k->PushConstant(inf);
  k->Map();

}


unsigned int  voutCombinefloat(::brook::stream outleft_stream, float  maxshiftleft, unsigned int  LEFTWIDTH, ::brook::stream outright_stream, float  maxshiftright, unsigned int  RIGHTWIDTH, unsigned int  LENGTH, ::brook::stream (*output))
{
  unsigned int  totalsize;
  float2  maxleftvalue;
  float2  maxrightvalue;

  maxleftvalue.x = (float ) (LENGTH);
  maxleftvalue.y = (float ) (LEFTWIDTH);
  maxrightvalue.x = (float ) (LENGTH);
  maxrightvalue.y = (float ) (RIGHTWIDTH);
  totalsize = LEFTWIDTH * LENGTH + RIGHTWIDTH * LENGTH - (unsigned int ) (maxshiftleft) - (unsigned int ) (maxshiftright);
  if (1)
  {
    unsigned int  length = LENGTH;
    unsigned int  width = totalsize / length + ((totalsize % length != 0) ? (1) : (0));
    ::brook::stream output_stream=quickAllocStream(::brook::getStreamType(( float  *)0), width , length,-1);
    float2  startsecond;
    float2  endsecond;

    cpuGetIndexAt(float2 (maxleftvalue.x,maxleftvalue.y - 1),-maxshiftleft,maxleftvalue,&startsecond);
    cpuGetIndexAt(float2 (maxrightvalue.x,maxrightvalue.y - 1),-maxshiftright,maxrightvalue,&endsecond);
    combinefloat(outleft_stream,outright_stream,output_stream,startsecond,endsecond,maxrightvalue,1.000000f / (float ) (floor(0.500000f)));
    streamSwap(*output,output_stream);
  }

  return totalsize;
}

unsigned int  totalCombineVoutfloat(::brook::stream list_stream, unsigned int  WIDTH, ::brook::stream list2_stream, unsigned int  WIDTH2, unsigned int  LENGTH, ::brook::stream (*output))
{
  ::brook::stream outleft_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream outright_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH2 , LENGTH,-1);
  float  maxshiftleft = shiftValuesfloat(list_stream,&outleft_stream,WIDTH,LENGTH,-1);
  float  maxshiftright = shiftValuesfloat(list2_stream,&outright_stream,WIDTH2,LENGTH,-1);

  return voutCombinefloat(outleft_stream,maxshiftleft,WIDTH,outright_stream,maxshiftright,WIDTH2,LENGTH,output);
}

#undef VECTOR_TEMPLATIZED_FUNCTIONS

#define VECTOR_TEMPLATIZED_FUNCTIONS


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r9.xy, -r0.w, r7, r0\n"
				"    mov r9.zw, c0.x\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r9.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r9.x\n"
				"    add r4.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r4.w, -r2.w, r2.w\n"
				"    cmp r11.xy, -r2.w, r2, r9\n"
				"    mov r11.zw, c0.x\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r4.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r4.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r11.xy, -r2.w, r2, r4\n"
				"    rcp r9.w, r11.x\n"
				"    add r6.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r6.w, -r9.w, r9.w\n"
				"    cmp r1.xy, -r9.w, r9, r11\n"
				"    mov r1.zw, c0.x\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r11.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r11.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r6.xy, -r2.w, r2, r11\n"
				"    rcp r9.w, r6.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r1.xy, -r9.w, r9, r6\n"
				"    rcp r4.w, r1.x\n"
				"    add r8.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r8.w, -r4.w, r4.w\n"
				"    cmp r3.xy, -r4.w, r4, r1\n"
				"    mov r3.zw, c0.x\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r6.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r6.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r1.xy, -r2.w, r2, r6\n"
				"    rcp r9.w, r1.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r8.xy, -r9.w, r9, r1\n"
				"    rcp r4.w, r8.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r3.xy, -r4.w, r4, r8\n"
				"    rcp r11.w, r3.x\n"
				"    add r10.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r10.w, -r11.w, r11.w\n"
				"    cmp r5.xy, -r11.w, r11, r3\n"
				"    mov r5.zw, c0.x\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r1.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r1.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r8.xy, -r2.w, r2, r1\n"
				"    rcp r9.w, r8.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r3.xy, -r9.w, r9, r8\n"
				"    rcp r4.w, r3.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r10.xy, -r4.w, r4, r3\n"
				"    rcp r11.w, r10.x\n"
				"    add r6.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r6.w, -r11.w, r11.w\n"
				"    cmp r5.xy, -r11.w, r11, r10\n"
				"    rcp r6.w, r5.x\n"
				"    add r0.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r0.w, -r6.w, r6.w\n"
				"    cmp r7.xy, -r6.w, r6, r5\n"
				"    mov r7.zw, c0.x\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl t7.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s0\n"
				"    texld r1, t7, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r8.xy, -r0.w, r7, r0\n"
				"    rcp r2.w, r8.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r3.xy, -r2.w, r2, r8\n"
				"    rcp r9.w, r3.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r10.xy, -r9.w, r9, r3\n"
				"    rcp r4.w, r10.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r5.xy, -r4.w, r4, r10\n"
				"    rcp r11.w, r5.x\n"
				"    add r6.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r6.w, -r11.w, r11.w\n"
				"    cmp r0.xy, -r11.w, r11, r5\n"
				"    rcp r6.w, r0.x\n"
				"    add r1.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r1.w, -r6.w, r6.w\n"
				"    cmp r7.xy, -r6.w, r6, r0\n"
				"    rcp r1.w, r7.x\n"
				"    add r2.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r2.w, -r1.w, r1.w\n"
				"    cmp r8.xy, -r1.w, r1, r7\n"
				"    mov r8.zw, c0.x\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:input\n"
				"//s:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat2_ps20 = &__valueProducedfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 5 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX1, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVR o[COLR].xy, R0.xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 6 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 7 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX3].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 8 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX4].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 9 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX5].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 10 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX6].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex___reduce7_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD7 : TEX7 : 10 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xy, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xy, f[TEX6].xyxx, TEX0, RECT;\n"
				"TEX R2.xy, f[TEX7].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R1.xyxx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xy(GT.x), R2.xyxx;\n"
				"MOVR R0.zw, {0, 0, 0, 0}.zzzw;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat2_fp30 = &__valueProducedfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r2;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r9.xy, -r0.w, r0, r7;\n"
				"MOV r9.zw, c0.x;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r9.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r9.x;\n"
				"ADD r4.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r4.w, r2.w, -r2.w;\n"
				"CMP r11.xy, -r2.w, r9, r2;\n"
				"MOV r11.zw, c0.x;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r4.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r4.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r11.xy, -r2.w, r4, r2;\n"
				"RCP r9.w, r11.x;\n"
				"ADD r6.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r6.w, r9.w, -r9.w;\n"
				"CMP r1.xy, -r9.w, r11, r9;\n"
				"MOV r1.zw, c0.x;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r11.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r11.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r6.xy, -r2.w, r11, r2;\n"
				"RCP r9.w, r6.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r1.xy, -r9.w, r6, r9;\n"
				"RCP r4.w, r1.x;\n"
				"ADD r8.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r8.w, r4.w, -r4.w;\n"
				"CMP r3.xy, -r4.w, r1, r4;\n"
				"MOV r3.zw, c0.x;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r6.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r6.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r1.xy, -r2.w, r6, r2;\n"
				"RCP r9.w, r1.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r8.xy, -r9.w, r1, r9;\n"
				"RCP r4.w, r8.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r3.xy, -r4.w, r8, r4;\n"
				"RCP r11.w, r3.x;\n"
				"ADD r10.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r10.w, r11.w, -r11.w;\n"
				"CMP r5.xy, -r11.w, r3, r11;\n"
				"MOV r5.zw, c0.x;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r1.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r1.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r8.xy, -r2.w, r1, r2;\n"
				"RCP r9.w, r8.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r3.xy, -r9.w, r8, r9;\n"
				"RCP r4.w, r3.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r10.xy, -r4.w, r3, r4;\n"
				"RCP r11.w, r10.x;\n"
				"ADD r6.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r6.w, r11.w, -r11.w;\n"
				"CMP r5.xy, -r11.w, r10, r11;\n"
				"RCP r6.w, r5.x;\n"
				"ADD r0.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r0.w, r6.w, -r6.w;\n"
				"CMP r7.xy, -r6.w, r5, r6;\n"
				"MOV r7.zw, c0.x;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"ATTRIB t7 = fragment.texcoord[7];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[0], RECT;\n"
				"TEX r1, t7, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r8.xy, -r0.w, r0, r7;\n"
				"RCP r2.w, r8.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r3.xy, -r2.w, r8, r2;\n"
				"RCP r9.w, r3.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r10.xy, -r9.w, r3, r9;\n"
				"RCP r4.w, r10.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r5.xy, -r4.w, r10, r4;\n"
				"RCP r11.w, r5.x;\n"
				"ADD r6.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r6.w, r11.w, -r11.w;\n"
				"CMP r0.xy, -r11.w, r5, r11;\n"
				"RCP r6.w, r0.x;\n"
				"ADD r1.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r1.w, r6.w, -r6.w;\n"
				"CMP r7.xy, -r6.w, r0, r6;\n"
				"RCP r1.w, r7.x;\n"
				"ADD r2.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r2.w, r1.w, -r1.w;\n"
				"CMP r8.xy, -r1.w, r7, r1;\n"
				"MOV r8.zw, c0.x;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:input\n"
				"##s:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat2_arb = &__valueProducedfloat2_arb_desc;
}

void __valueProducedfloat2_cpu_inner (const __BrtFloat2  &input,
                                       __BrtFloat2  &output){
  output = __isinf_cpu_inner(input.swizzle1(maskX)).questioncolon(output,input);
}
void  __valueProducedfloat2__base_cpu_inner (const __BrtFloat2  &input,
                                             __BrtFloat2  &output) {
  output = input;
}
void  __valueProducedfloat2__combine_cpu_inner (const __BrtFloat2  &input,
                                                __BrtFloat2  &output,
                                                __BrtFloat2  &__combiner) {
  __valueProducedfloat2_cpu_inner (__combiner, output);
}
void  __valueProducedfloat2_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtFloat2 *arg0 = (__BrtFloat2 *)args[0];
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int i=0; 
  if (mapextent) {
    __valueProducedfloat2__base_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
  while (i<mapextent) {
    __valueProducedfloat2_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
}
void  __valueProducedfloat2_ndcpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   const unsigned int *mapbegin, 
                                   const unsigned int *mapextents) {
  __BrtFloat2 *arg0 = (__BrtFloat2 *)args[0];
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=mapextents[dim-1];
  unsigned int mapextent = mapextents[0], i=1;
  for (;i<dim;++i) mapextent*=mapextents[i];

  unsigned int iter0 = getIndexOf(0, mapbegin, mapextents, extents[0], dim, extents[0]);
  i=0; 
  if (mapextent) {
    __valueProducedfloat2__base_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
  while (i<mapextent) {
    __valueProducedfloat2_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
}
void  __valueProducedfloat2__combine_cpu (const std::vector<void *>&args,
                                          const std::vector<const unsigned int *>&extents,
                                          const std::vector<unsigned int>&dims,
                                          unsigned int mapbegin) {
    __BrtFloat2 *arg0 = (__BrtFloat2 *)args[0];
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat2 *arg2 = (__BrtFloat2 *)args[2];
    arg0+=mapbegin;
    __valueProducedfloat2__combine_cpu_inner (
      *arg0,
      *arg1,
      *arg2);
}

class __valueProducedfloat2_scatterclass{ public:
  void operator () (__BrtFloat2  &output, 
                    const __BrtFloat2  &input) const {
    __valueProducedfloat2_cpu_inner (input, output);
  }
}__valueProducedfloat2_scatter;
void  valueProducedfloat2 (::brook::stream input,
		::brook::stream output) {
  static const void *__valueProducedfloat2_fp[] = {
     "fp30", __valueProducedfloat2_fp30,
     "arb", __valueProducedfloat2_arb,
     "ps20", __valueProducedfloat2_ps20,
     "cpu", (void *) __valueProducedfloat2_cpu,
     "ndcpu", (void *) __valueProducedfloat2_ndcpu,
     "combine", (void *) __valueProducedfloat2__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat2_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}

void  valueProducedfloat2 (::brook::stream input,
		float2  & output) {
  static const void *__valueProducedfloat2_fp[] = {
     "fp30", __valueProducedfloat2_fp30,
     "arb", __valueProducedfloat2_arb,
     "ps20", __valueProducedfloat2_ps20,
     "cpu", (void *) __valueProducedfloat2_cpu,
     "ndcpu", (void *) __valueProducedfloat2_ndcpu,
     "combine", (void *) __valueProducedfloat2__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat2_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    texld r0, t0, s0\n"
				"    rcp r7.w, r0.x\n"
				"    max r4.w, -r7.w, r7.w\n"
				"    cmp_pp r6.x, -r4.w, c0.x, c0.w\n"
				"    mov r6.yzw, c0.x\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:2:inp\n"
				"//o:1:outp\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat2_ps20 = &__isFiniteKernelfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_inp : TEXUNIT0\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_inp : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __workspace : C0 :  : 3 : 1\n"
				"#var float2 _tex_inp_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVX o[COLR].x, H0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat2_fp30 = &__isFiniteKernelfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r4.w, -r7.w, r7.w;\n"
				"CMP r6.x, -r4.w, c0.w, c0.x;\n"
				"MOV r6.yzw, c0.x;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:2:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat2_arb = &__isFiniteKernelfloat2_arb_desc;
}

void __isFiniteKernelfloat2_cpu_inner (const __BrtFloat2  &inp,
                                        __BrtFloat1  &outp){
  outp = !__isinf_cpu_inner(inp.swizzle1(maskX));
}
void  __isFiniteKernelfloat2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat2 *arg0 = (__BrtFloat2 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  unsigned int ratio0 = extents[1][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[1][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[1]);
  arg1+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __isFiniteKernelfloat2_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    ++arg1;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[1]);
    }
  }
}

void  isFiniteKernelfloat2 (::brook::stream inp,
		::brook::stream outp) {
  static const void *__isFiniteKernelfloat2_fp[] = {
     "fp30", __isFiniteKernelfloat2_fp30,
     "arb", __isFiniteKernelfloat2_arb,
     "ps20", __isFiniteKernelfloat2_ps20,
     "cpu", (void *) __isFiniteKernelfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__isFiniteKernelfloat2_fp);

  k->PushStream(inp);
  k->PushOutput(outp);
  k->Map();

}


int  finiteValueProducedfloat2(::brook::stream input)
{
  static  ::brook::stream output(::brook::getStreamType(( float2  *)0), 1 , 1,-1);
  static ::brook::stream finiteout(::brook::getStreamType(( float  *)0), 1 , 1,-1);
  float2  rettype;
  float  ret;

  debugStreamPrint(input,"Finite Values in...");
  valueProducedfloat2(input,output);
  streamWrite(output,&rettype);
  isFiniteKernelfloat2(output,finiteout);
  streamWrite(finiteout,&ret);
  return (int ) (ret);
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0.1, 0, 0\n"
				"    dcl_2d s0\n"
				"    mov r1.xy, c1\n"
				"    mad r7.x, c0.x, r1.x, c0.z\n"
				"    mad r7.y, c0.y, r1.y, c0.w\n"
				"    texld r2, r7, s0\n"
				"    mov r2.w, -c2.y\n"
				"    add r2.w, r2.w, c1.y\n"
				"    cmp_pp r2.w, r2.w, c4.x, c4.w\n"
				"    mov r1.w, c1.y\n"
				"    add r9.w, c4.y, r1.w\n"
				"    cmp_pp r4.w, r9.w, c4.w, c4.x\n"
				"    add_pp r2.w, r2.w, r4.w\n"
				"    cmp r11.xy, -r2.w, r2, c3.x\n"
				"    mov r11.zw, c4.w\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//c:2:value\n"
				"//c:2:index\n"
				"//o:2:output\n"
				"//c:2:maxvalue\n"
				"//c:1:nothing\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat2_ps20 = &__valueAtfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main.index : C1\n"
				"#semantic main.maxvalue : C2\n"
				"#semantic main.nothing : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float2 index : C1 :  : 2 : 1\n"
				"#var float2 maxvalue : C2 :  : 4 : 1\n"
				"#var float nothing : C3 :  : 5 : 1\n"
				"#var float4 __workspace : C4 :  : 6 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE index;\n"
				"DECLARE maxvalue;\n"
				"DECLARE nothing;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, index.xyxx, TEX0, RECT;\n"
				"MOVR R1.y, maxvalue.y;\n"
				"SGER H0.x, index.y, R1.y;\n"
				"MOVR R1.x, {-0.1}.x;\n"
				"SLTR H0.y, index.y, R1.x;\n"
				"ADDX H0.y, H0.x, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MOVR o[COLR].xy, nothing.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:2:value\n"
				"##c:2:index\n"
				"##o:2:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat2_fp30 = &__valueAtfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0.1, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"MOV r1.xy, c1;\n"
				"MAD r7.x, c0.x, r1.x, c0.z;\n"
				"MAD r7.y, c0.y, r1.y, c0.w;\n"
				"TEX r2, r7, texture[0], RECT;\n"
				"MOV r2.w, -c2.y;\n"
				"ADD r2.w, r2.w, c1.y;\n"
				"CMP r2.w, r2.w, c4.w, c4.x;\n"
				"MOV r1.w, c1.y;\n"
				"ADD r9.w, c4.y, r1.w;\n"
				"CMP r4.w, r9.w, c4.x, c4.w;\n"
				"ADD r2.w, r2.w, r4.w;\n"
				"CMP r11.xy, -r2.w, c3.x, r2;\n"
				"MOV r11.zw, c4.w;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:2:value\n"
				"##c:2:index\n"
				"##o:2:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat2_arb = &__valueAtfloat2_arb_desc;
}

void __valueAtfloat2_cpu_inner (const __BrtArray2d<__BrtFloat2  > &value,
                                 const __BrtFloat2  &index,
                                 __BrtFloat2  &output,
                                 const __BrtFloat2  &maxvalue,
                                 const __BrtFloat1  &nothing){
  if (index.swizzle1(maskY) >= maxvalue.swizzle1(maskY) || index.swizzle1(maskY) < -__BrtFloat1(0.100000f))
    output = nothing;
  else
    output = value[index];
}
void  __valueAtfloat2_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat2 *arg2 = (__BrtFloat2 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __valueAtfloat2_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4);
    i++;
    ++arg2;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  valueAtfloat2 (::brook::stream value,
		const float2  index,
		::brook::stream output,
		const float2  maxvalue,
		const float  nothing) {
  static const void *__valueAtfloat2_fp[] = {
     "fp30", __valueAtfloat2_fp30,
     "arb", __valueAtfloat2_arb,
     "ps20", __valueAtfloat2_ps20,
     "cpu", (void *) __valueAtfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueAtfloat2_fp);

  k->PushGatherStream(value);
  k->PushConstant(index);
  k->PushOutput(output);
  k->PushConstant(maxvalue);
  k->PushConstant(nothing);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 0.5, 0.25, 0, -0.5\n"
				"    def c5, 1, 0, 0, 0.1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c4.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c4.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c4.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c4.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c4.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c5.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, r3.w, c5.x, r2.w\n"
				"    mov r2.w, c5.x\n"
				"    cmp_pp r9.w, r9.w, c4.z, r2.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c4.z\n"
				"    rcp r4.w, r4.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, -r4.w, c5.x, r2.w\n"
				"    rcp r1.w, r4.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp_pp r0.w, -r10.w, c5.x, r2.w\n"
				"    add_pp r2.x, r4.w, r0.w\n"
				"    mov r2.yzw, c4.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:2:value\n"
				"//oi:1:output\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat2_ps20 = &__NanToBoolRightfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.sign : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float sign : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, sign.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.y, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.y, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0, 0}.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.xyxx;\n"
				"SNER H0.y, R2.x, {0}.x;\n"
				"MULR R1.x, R2.x, {2}.x;\n"
				"SEQR H0.z, R2.x, R1.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.z, R0.x, R1.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {1}.x;\n"
				"ADDR o[COLR].x, R0.x, R0.y;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:2:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat2_fp30 = &__NanToBoolRightfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {0.5, 0.25, 0, -0.5};\n"
				"PARAM c5 = {1, 0, 0, 0.1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c4.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c4.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c4.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c4.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c4.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c5.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, r3.w, r2.w, c5.x;\n"
				"MOV r2.w, c5.x;\n"
				"CMP r9.w, r9.w, r2.w, c4.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c4.z, r9.x;\n"
				"RCP r4.w, r4.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, -r4.w, r2.w, c5.x;\n"
				"RCP r1.w, r4.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r0.w, -r10.w, r2.w, c5.x;\n"
				"ADD r2.x, r4.w, r0.w;\n"
				"MOV r2.yzw, c4.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:2:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat2_arb = &__NanToBoolRightfloat2_arb_desc;
}

void __NanToBoolRightfloat2_cpu_inner (const __BrtArray2d<__BrtFloat2  > &value,
                                        __BrtFloat1  &output,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,sign,maxvalue,nextPlaceToLook);
  __valueAtfloat2_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = (__isinf_cpu_inner(value[__indexof_output].swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0))) + (__isinf_cpu_inner(neighbor.swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0)));
}
void  __NanToBoolRightfloat2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToBoolRightfloat2_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToBoolRightfloat2 (::brook::stream value,
		::brook::stream output,
		const float  sign,
		const float2  maxvalue) {
  static const void *__NanToBoolRightfloat2_fp[] = {
     "fp30", __NanToBoolRightfloat2_fp30,
     "arb", __NanToBoolRightfloat2_arb,
     "ps20", __NanToBoolRightfloat2_ps20,
     "cpu", (void *) __NanToBoolRightfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToBoolRightfloat2_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r4.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r9.w, r9.w, c5.z, r0.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c5.z\n"
				"    add r11.w, r4.x, r4.w\n"
				"    add r6.w, r11.w, c5.x\n"
				"    frc r1.w, r6.w\n"
				"    add r7.x, r6.w, -r1.w\n"
				"    mov r7.yzw, c5.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat2_ps20 = &__NanToRightfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R2.x, R0.x, R2.x;\n"
				"ADDR R2.x, R2.x, {0.5}.x;\n"
				"FLRR o[COLR].x, R2.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat2_fp30 = &__NanToRightfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r4.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r9.w, r9.w, r0.w, c5.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c5.z, r9.x;\n"
				"ADD r11.w, r4.x, r4.w;\n"
				"ADD r6.w, r11.w, c5.x;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r7.x, r6.w, -r1.w;\n"
				"MOV r7.yzw, c5.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat2_arb = &__NanToRightfloat2_arb_desc;
}

void __NanToRightfloat2_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                    __BrtFloat1  &output,
                                    const __BrtFloat1  &twotoi,
                                    const __BrtFloat2  &maxvalue,
                                    const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = __round_cpu_inner(value[__indexof_output] + neighbor);
}
void  __NanToRightfloat2_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToRightfloat2_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToRightfloat2 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__NanToRightfloat2_fp[] = {
     "fp30", __NanToRightfloat2_fp30,
     "arb", __NanToRightfloat2_arb,
     "ps20", __NanToRightfloat2_ps20,
     "cpu", (void *) __NanToRightfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToRightfloat2_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r9.w, r3.y, -c3.y\n"
				"    add r4.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r9.w, r9.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r4.w, r4.w, c5.z, r0.w\n"
				"    add_pp r9.w, r9.w, r4.w\n"
				"    cmp r11.xy, -r9.w, r9, c5.z\n"
				"    add r6.xy, r4, r11\n"
				"    mov r6.zw, c5.z\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:2:value\n"
				"//oi:2:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat2_ps20 = &__CountToRightfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.xy, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.xy, {0, 0}.xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.xy(GT.x), R1.xyxx;\n"
				"ADDR o[COLR].xy, R0.xyxx, R2.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:2:value\n"
				"##oi:2:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat2_fp30 = &__CountToRightfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r9.w, r3.y, -c3.y;\n"
				"ADD r4.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r9.w, r9.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r4.w, r4.w, r0.w, c5.z;\n"
				"ADD r9.w, r9.w, r4.w;\n"
				"CMP r11.xy, -r9.w, c5.z, r9;\n"
				"ADD r6.xy, r4, r11;\n"
				"MOV r6.zw, c5.z;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:2:value\n"
				"##oi:2:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat2_arb = &__CountToRightfloat2_arb_desc;
}

void __CountToRightfloat2_cpu_inner (const __BrtArray2d<__BrtFloat2  > &value,
                                      __BrtFloat2  &output,
                                      const __BrtFloat1  &twotoi,
                                      const __BrtFloat2  &maxvalue,
                                      const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat2_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = value[__indexof_output] + neighbor;
}
void  __CountToRightfloat2_cpu (const std::vector<void *>&args,
                                const std::vector<const unsigned int *>&extents,
                                const std::vector<unsigned int>&dims,
                                unsigned int mapbegin, 
                                unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __CountToRightfloat2_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  CountToRightfloat2 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__CountToRightfloat2_fp[] = {
     "fp30", __CountToRightfloat2_fp30,
     "arb", __CountToRightfloat2_arb,
     "ps20", __CountToRightfloat2_ps20,
     "cpu", (void *) __CountToRightfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__CountToRightfloat2_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r3.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r3.w\n"
				"    mad r5.x, r3.x, c2.x, c2.z\n"
				"    mad r5.y, r3.y, c2.y, c2.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    texld r2, r5, s1\n"
				"    texld r9, r0, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r2.w, r3.y, c7.w\n"
				"    mov r0.w, c8.z\n"
				"    cmp_pp r9.w, r3.w, c7.x, r0.w\n"
				"    mov r0.w, c7.x\n"
				"    cmp_pp r2.w, r2.w, c8.z, r0.w\n"
				"    add_pp r2.w, r9.w, r2.w\n"
				"    cmp r4.w, -r2.w, r2.x, c8.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp_pp r10.w, -r8.w, c8.z, r0.w\n"
				"    cmp r5.w, -r2.w, r9.x, c8.z\n"
				"    add r3.w, r5.w, -c5.x\n"
				"    mov r2.w, -r5.w\n"
				"    abs r4.w, r3.w\n"
				"    mov r11.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r11.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r10.w, r6.w\n"
				"    mov r7.w, -c3.x\n"
				"    add r10.w, r7.w, c5.x\n"
				"    cmp r5.w, -r1.w, r10.w, c5.x\n"
				"    add r0.w, r2.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r3.w, c3.x, r4.w\n"
				"    cmp r2.x, r0.w, r5.w, r3.w\n"
				"    mov r2.yzw, c8.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:2:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat2_ps20 = &__GatherGuessfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.x, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.xy, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.x, R2.x, halfk.x;\n"
				"SEQR H0.z, R2.x, halfk.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R0.x, {0, 0}.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), R1.xyxx;\n"
				"SNER H0.y, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR o[COLR].x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), halfk.x;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, -R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat2_fp30 = &__GatherGuessfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r3.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r3.w;\n"
				"MAD r5.x, r3.x, c2.x, c2.z;\n"
				"MAD r5.y, r3.y, c2.y, c2.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"TEX r2, r5, texture[1], RECT;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r2.w, r3.y, c7.w;\n"
				"MOV r0.w, c8.z;\n"
				"CMP r9.w, r3.w, r0.w, c7.x;\n"
				"MOV r0.w, c7.x;\n"
				"CMP r2.w, r2.w, r0.w, c8.z;\n"
				"ADD r2.w, r9.w, r2.w;\n"
				"CMP r4.w, -r2.w, c8.z, r2.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r10.w, -r8.w, r0.w, c8.z;\n"
				"CMP r5.w, -r2.w, c8.z, r9.x;\n"
				"ADD r3.w, r5.w, -c5.x;\n"
				"MOV r2.w, -r5.w;\n"
				"ABS r4.w, r3.w;\n"
				"MOV r11.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r11.w, r4.w, c7.x;\n"
				"MUL r1.w, r10.w, r6.w;\n"
				"MOV r7.w, -c3.x;\n"
				"ADD r10.w, r7.w, c5.x;\n"
				"CMP r5.w, -r1.w, c5.x, r10.w;\n"
				"ADD r0.w, r2.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r3.w, c3.x, r4.w;\n"
				"CMP r2.x, r0.w, r3.w, r5.w;\n"
				"MOV r2.yzw, c8.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat2_arb = &__GatherGuessfloat2_arb_desc;
}

void __GatherGuessfloat2_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat2  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &halfk,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __BrtFloat1  neighbor;
  __BrtFloat2  nextPlaceToLook;

  __getIndexAt_cpu_inner(__indexof_output,-sign * halfk,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(scatterindex,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  if (neighbor > halfk)
  {
    output = halfk + twotologkminusi;
  }

  else
  {
    __BrtFloat2  actualValue;

    __valueAtfloat2_cpu_inner(value,nextPlaceToLook,actualValue,maxvalue,__BrtFloat1((float)0));
    if (neighbor == halfk && !__isinf_cpu_inner(actualValue.swizzle1(maskX)))
    {
      output = halfk;
    }

    else
    {
      output = halfk - twotologkminusi;
    }

  }

}
void  __GatherGuessfloat2_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __GatherGuessfloat2_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  GatherGuessfloat2 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__GatherGuessfloat2_fp[] = {
     "fp30", __GatherGuessfloat2_fp30,
     "arb", __GatherGuessfloat2_arb,
     "ps20", __GatherGuessfloat2_ps20,
     "cpu", (void *) __GatherGuessfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__GatherGuessfloat2_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r2.x, r3.x, c2.x, c2.z\n"
				"    mad r2.y, r3.y, c2.y, c2.w\n"
				"    mad r9.x, r3.x, c0.x, c0.z\n"
				"    mad r9.y, r3.y, c0.y, c0.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    texld r11, r2, s1\n"
				"    texld r6, r9, s0\n"
				"    texld r1, r4, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r11.w, r3.y, c7.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r3.w, c7.x, r4.w\n"
				"    mov r4.w, c7.x\n"
				"    cmp_pp r11.w, r11.w, c8.z, r4.w\n"
				"    add_pp r11.w, r6.w, r11.w\n"
				"    cmp r1.w, -r11.w, r11.x, c8.z\n"
				"    rcp r1.w, r1.w\n"
				"    add r7.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r7.w, -r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.z, r4.w\n"
				"    cmp r10.w, -r11.w, r6.x, c8.z\n"
				"    add r0.w, r10.w, -c5.x\n"
				"    abs r4.w, r0.w\n"
				"    mov r3.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r11.w, r3.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r1.w, r11.w\n"
				"    mov r6.w, -c3.x\n"
				"    add r8.w, r6.w, c5.x\n"
				"    cmp r1.w, -r1.w, r8.w, c5.x\n"
				"    add r7.w, -r10.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r10.w, c3.x, r4.w\n"
				"    cmp r1.w, r7.w, r1.w, r10.w\n"
				"    abs r0.w, r1.x\n"
				"    cmp r9.x, -r0.w, c8.z, r1.w\n"
				"    mov r9.yzw, c8.z\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:2:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat2_ps20 = &__EstablishGuessfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SEQR H0.x, R0.x, {0}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H1.x, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H1.y, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H1.y, R0.x, {-0.5}.x;\n"
				"MULX H1.y, H0.y, H1.y;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"SLTR H0.z, R2.y, {-0.1}.x;\n"
				"SGER H0.w, R2.y, maxvalue.y;\n"
				"ADDX H0.z, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.xy, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.y, R2.x, halfk.x;\n"
				"SEQR H0.w, R2.x, halfk.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H1.x, H0.y;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, {0, 0}.xyxx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R1.xyxx;\n"
				"SNER H0.z, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.z, -H1.x, H0.z, {1}.x;\n"
				"MULX H1.x, H0.w, H0.z;\n"
				"MADX H0.z, -H0.w, H0.z, {1}.x;\n"
				"MULX H1.x, H0.y, H1.x;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R0.x(GT.x), halfk.x;\n"
				"MOVR R0.y, twotologkminusi.x;\n"
				"ADDR R0.y, halfk.x, -R0.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R0.y;\n"
				"MOVR o[COLR].x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat2_fp30 = &__EstablishGuessfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r2.x, r3.x, c2.x, c2.z;\n"
				"MAD r2.y, r3.y, c2.y, c2.w;\n"
				"MAD r9.x, r3.x, c0.x, c0.z;\n"
				"MAD r9.y, r3.y, c0.y, c0.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"TEX r11, r2, texture[1], RECT;\n"
				"TEX r6, r9, texture[0], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r11.w, r3.y, c7.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r3.w, r4.w, c7.x;\n"
				"MOV r4.w, c7.x;\n"
				"CMP r11.w, r11.w, r4.w, c8.z;\n"
				"ADD r11.w, r6.w, r11.w;\n"
				"CMP r1.w, -r11.w, c8.z, r11.x;\n"
				"RCP r1.w, r1.w;\n"
				"ADD r7.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r7.w, r1.w, -r1.w;\n"
				"CMP r1.w, -r1.w, r4.w, c8.z;\n"
				"CMP r10.w, -r11.w, c8.z, r6.x;\n"
				"ADD r0.w, r10.w, -c5.x;\n"
				"ABS r4.w, r0.w;\n"
				"MOV r3.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r11.w, r3.w, r4.w, c7.x;\n"
				"MUL r1.w, r1.w, r11.w;\n"
				"MOV r6.w, -c3.x;\n"
				"ADD r8.w, r6.w, c5.x;\n"
				"CMP r1.w, -r1.w, c5.x, r8.w;\n"
				"ADD r7.w, -r10.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r10.w, c3.x, r4.w;\n"
				"CMP r1.w, r7.w, r10.w, r1.w;\n"
				"ABS r0.w, r1.x;\n"
				"CMP r9.x, -r0.w, r1.w, c8.z;\n"
				"MOV r9.yzw, c8.z;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat2_arb = &__EstablishGuessfloat2_arb_desc;
}

void __EstablishGuessfloat2_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                        __BrtFloat1  &output,
                                        const __BrtArray2d<__BrtFloat2  > &value,
                                        const __BrtFloat1  &twotologkminusi,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &halfk,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat4 &__indexof_output){
  if (scatterindex[__indexof_output] == __BrtFloat1((float)0))
  {
    output = __BrtFloat1((float)0);
  }

  else
  {
    __GatherGuessfloat2_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,halfk,sign,__indexof_output);
  }

}
void  __EstablishGuessfloat2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __EstablishGuessfloat2_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  EstablishGuessfloat2 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__EstablishGuessfloat2_fp[] = {
     "fp30", __EstablishGuessfloat2_fp30,
     "arb", __EstablishGuessfloat2_arb,
     "ps20", __EstablishGuessfloat2_ps20,
     "cpu", (void *) __EstablishGuessfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__EstablishGuessfloat2_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 1, 0, 0, 0.1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    texld r0, t1, s2\n"
				"    mad r2.x, t0.x, c1.x, c1.z\n"
				"    mad r2.y, t0.y, c1.y, c1.w\n"
				"    mad r2.w, r0.x, -c5.x, r2.x\n"
				"    add r2.w, r2.w, c7.x\n"
				"    frc r0.w, r2.w\n"
				"    add r0.w, r2.w, -r0.w\n"
				"    rcp r9.w, c4.x\n"
				"    mul r0.w, r0.w, r9.w\n"
				"    mul r2.w, r2.w, r9.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    add r0.w, r0.w, c7.x\n"
				"    frc r4.w, r0.w\n"
				"    add r0.w, r0.w, -r4.w\n"
				"    add r1.w, -r0.w, c7.w\n"
				"    add r8.w, r0.w, c4.x\n"
				"    cmp r0.w, r1.w, r8.w, r0.w\n"
				"    add r3.w, r0.w, c7.y\n"
				"    add r5.w, r3.w, -c4.x\n"
				"    cmp r7.x, r5.w, c7.z, r0.w\n"
				"    frc r7.w, r2.w\n"
				"    add r7.w, r2.w, -r7.w\n"
				"    add r7.y, r2.y, r7.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    mad r11.x, r7.x, c2.x, c2.z\n"
				"    mad r11.y, r7.y, c2.y, c2.w\n"
				"    texld r6, r4, s0\n"
				"    texld r1, r11, s1\n"
				"    add r7.w, r7.y, -c4.y\n"
				"    add r6.w, r7.y, c6.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r1.w, r7.w, c6.x, r11.w\n"
				"    mov r11.w, c6.x\n"
				"    cmp_pp r6.w, r6.w, c7.z, r11.w\n"
				"    add_pp r6.w, r1.w, r6.w\n"
				"    cmp r0.w, -r6.w, r6.x, c7.z\n"
				"    add r3.w, r0.w, -r0.x\n"
				"    abs r5.w, r3.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r2.w, -r5.w, c6.x, r11.w\n"
				"    cmp r4.w, -r6.w, r1.x, c7.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r1.w, -r11.w, r11.w\n"
				"    mov r8.w, -r1.w\n"
				"    mov r1.w, c6.x\n"
				"    cmp_pp r3.w, r8.w, c7.z, r1.w\n"
				"    mul_pp r10.w, r2.w, r3.w\n"
				"    add r2.w, r0.x, -c3.x\n"
				"    cmp r4.w, -r10.w, r2.w, r0.x\n"
				"    add r0.w, r0.x, -r0.w\n"
				"    add r11.w, r0.x, c3.x\n"
				"    cmp r7.x, r0.w, r4.w, r11.w\n"
				"    mov r7.yzw, c7.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:2:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//s:1:lastguess\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat2_ps20 = &__UpdateGuessfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main._tex_lastguess : TEXUNIT2\n"
				"#semantic main.sign : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var samplerRECT _tex_lastguess : TEXUNIT2 : texunit 2 : 9 : 1\n"
				"#var float sign : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"#var float2 _tex_lastguess_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"MADR R1.w, -sign.x, R0.x, R1.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxvalue.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R3.y, {-0.1}.x;\n"
				"SGER H0.y, R3.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R3.y, {-0.1}.x;\n"
				"SGER H0.z, R3.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.x, R3.xyxx, TEX0, RECT;\n"
				"TEX R2.xy, R3.xyxx, TEX1, RECT;\n"
				"MOVR R3.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"SGTR H0.x, R3.x, R0.x;\n"
				"SEQR H0.z, R3.x, R0.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, {0, 0}.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), R2.xyxx;\n"
				"SNER H0.y, R1.x, {0}.x;\n"
				"MULR R1.y, R1.x, {2}.x;\n"
				"SEQR H1.x, R1.x, R1.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"ADDR o[COLR].x, R0.x, twotologkminusi.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"ADDR R0.x, R0.x, -twotologkminusi.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat2_fp30 = &__UpdateGuessfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {1, 0, 0, 0.1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[2], RECT;\n"
				"MAD r2.x, t0.x, c1.x, c1.z;\n"
				"MAD r2.y, t0.y, c1.y, c1.w;\n"
				"MAD r2.w, r0.x, -c5.x, r2.x;\n"
				"ADD r2.w, r2.w, c7.x;\n"
				"FRC r0.w, r2.w;\n"
				"ADD r0.w, r2.w, -r0.w;\n"
				"RCP r9.w, c4.x;\n"
				"MUL r0.w, r0.w, r9.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"ADD r0.w, r0.w, c7.x;\n"
				"FRC r4.w, r0.w;\n"
				"ADD r0.w, r0.w, -r4.w;\n"
				"ADD r1.w, -r0.w, c7.w;\n"
				"ADD r8.w, r0.w, c4.x;\n"
				"CMP r0.w, r1.w, r0.w, r8.w;\n"
				"ADD r3.w, r0.w, c7.y;\n"
				"ADD r5.w, r3.w, -c4.x;\n"
				"CMP r7.x, r5.w, r0.w, c7.z;\n"
				"FRC r7.w, r2.w;\n"
				"ADD r7.w, r2.w, -r7.w;\n"
				"ADD r7.y, r2.y, r7.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"MAD r11.x, r7.x, c2.x, c2.z;\n"
				"MAD r11.y, r7.y, c2.y, c2.w;\n"
				"TEX r6, r4, texture[0], RECT;\n"
				"TEX r1, r11, texture[1], RECT;\n"
				"ADD r7.w, r7.y, -c4.y;\n"
				"ADD r6.w, r7.y, c6.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r1.w, r7.w, r11.w, c6.x;\n"
				"MOV r11.w, c6.x;\n"
				"CMP r6.w, r6.w, r11.w, c7.z;\n"
				"ADD r6.w, r1.w, r6.w;\n"
				"CMP r0.w, -r6.w, c7.z, r6.x;\n"
				"ADD r3.w, r0.w, -r0.x;\n"
				"ABS r5.w, r3.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r2.w, -r5.w, r11.w, c6.x;\n"
				"CMP r4.w, -r6.w, c7.z, r1.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r1.w, -r11.w, r11.w;\n"
				"MOV r8.w, -r1.w;\n"
				"MOV r1.w, c6.x;\n"
				"CMP r3.w, r8.w, r1.w, c7.z;\n"
				"MUL r10.w, r2.w, r3.w;\n"
				"ADD r2.w, r0.x, -c3.x;\n"
				"CMP r4.w, -r10.w, r0.x, r2.w;\n"
				"ADD r0.w, r0.x, -r0.w;\n"
				"ADD r11.w, r0.x, c3.x;\n"
				"CMP r7.x, r0.w, r11.w, r4.w;\n"
				"MOV r7.yzw, c7.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:2:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat2_arb = &__UpdateGuessfloat2_arb_desc;
}

void __UpdateGuessfloat2_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat2  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &lastguess,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __GatherGuessfloat2_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,lastguess,sign,__indexof_output);
}
void  __UpdateGuessfloat2_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  unsigned int ratio5 = extents[1][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[1][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[1]);
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __UpdateGuessfloat2_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[1]);
    }
  }
}

void  UpdateGuessfloat2 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		::brook::stream lastguess,
		const float  sign) {
  static const void *__UpdateGuessfloat2_fp[] = {
     "fp30", __UpdateGuessfloat2_fp30,
     "arb", __UpdateGuessfloat2_arb,
     "ps20", __UpdateGuessfloat2_ps20,
     "cpu", (void *) __UpdateGuessfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__UpdateGuessfloat2_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushStream(lastguess);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.0625, 1.0625, 0, 1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    mad r7.x, t0.x, c0.x, c0.z\n"
				"    mad r7.y, t0.y, c0.y, c0.w\n"
				"    mad r9.x, r7.x, c1.x, c1.z\n"
				"    mad r9.y, r7.y, c1.y, c1.w\n"
				"    texld r4, r9, s0\n"
				"    mov r7.w, -c3.x\n"
				"    mad r6.w, r4.x, r7.w, r7.x\n"
				"    add r1.w, r6.w, c7.x\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    rcp r5.w, c4.x\n"
				"    mul r0.w, r10.w, r5.w\n"
				"    frc r2.w, r0.w\n"
				"    mul r9.w, r2.w, c4.x\n"
				"    add r4.w, r9.w, c7.x\n"
				"    frc r11.w, r4.w\n"
				"    add r8.w, r4.w, -r11.w\n"
				"    add r10.w, -r8.w, c7.w\n"
				"    add r0.w, r8.w, c4.x\n"
				"    cmp r2.w, r10.w, r0.w, r8.w\n"
				"    add r9.w, r2.w, c7.y\n"
				"    add r11.w, r9.w, -c4.x\n"
				"    cmp r1.x, r11.w, c7.z, r2.w\n"
				"    mul r1.w, r1.w, r5.w\n"
				"    frc r6.w, r1.w\n"
				"    add r1.w, r1.w, -r6.w\n"
				"    add r1.y, r7.y, r1.w\n"
				"    mad r5.x, r1.x, c2.x, c2.z\n"
				"    mad r5.y, r1.y, c2.y, c2.w\n"
				"    texld r3, r5, s1\n"
				"    texld r10, t1, s2\n"
				"    mad r3.w, r7.w, c5.x, r7.x\n"
				"    add r3.w, r3.w, c7.x\n"
				"    mul r7.w, r5.w, r3.w\n"
				"    frc r10.w, r7.w\n"
				"    add r7.w, r7.w, -r10.w\n"
				"    add r4.y, r7.y, r7.w\n"
				"    frc r10.w, r3.w\n"
				"    add r3.w, r3.w, -r10.w\n"
				"    mul r3.w, r3.w, r5.w\n"
				"    frc r3.w, r3.w\n"
				"    mul r3.w, r3.w, c4.x\n"
				"    add r3.w, r3.w, c7.x\n"
				"    frc r10.w, r3.w\n"
				"    add r3.w, r3.w, -r10.w\n"
				"    add r10.w, -r3.w, c7.w\n"
				"    add r0.w, r3.w, c4.x\n"
				"    cmp r3.w, r10.w, r0.w, r3.w\n"
				"    add r4.w, -c4.x, r3.w\n"
				"    add r4.w, r4.w, c7.y\n"
				"    cmp r4.x, r4.w, c7.z, r3.w\n"
				"    add r9.xy, r4, -c4\n"
				"    add r9.w, r9.y, c6.y\n"
				"    mov r0.w, c7.z\n"
				"    cmp_pp r9.w, r9.w, c6.w, r0.w\n"
				"    add r3.w, r9.x, c6.x\n"
				"    add r10.w, r9.y, c6.x\n"
				"    cmp_pp r3.w, r3.w, c6.w, r0.w\n"
				"    mul r3.w, r9.w, r3.w\n"
				"    cmp_pp r10.w, r10.w, c6.w, r0.w\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r11.xy, -r3.w, r3, r10.x\n"
				"    mov r11.zw, c7.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:2:output\n"
				"//c:1:gatherindex\n"
				"//c:2:value\n"
				"//s:1:inf\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//c:1:maxshift\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat2_ps20 = &__RelativeGatherfloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_output_invscalebias : C0\n"
				"#semantic main.gatherindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_gatherindex : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main._tex_inf : TEXUNIT2\n"
				"#semantic main.sign : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.maxshift : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var float4 _const_output_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT gatherindex[0] : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var float4 __gatherconst_gatherindex : C1 :  : 4 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var samplerRECT _tex_inf : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float sign : C3 :  : 9 : 1\n"
				"#var float2 maxvalue : C4 :  : 10 : 1\n"
				"#var float maxshift : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_inf_pos : $vin.TEXCOORD1 : TEX1 : 8 : 1\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_gatherindex;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE maxshift;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR o[COLR].xy, R0.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, maxshift.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R1.x, R0.xyxx, TEX0, RECT;\n"
				"MADR R0.w, -sign.x, R1.x, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R3.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R3.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"ADDR R0.x, R3.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.y, R0.x, {0}.x;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"ADDR R0.z, R0.z, {0.5}.x;\n"
				"FLRR R0.z, R0.z;\n"
				"SLER H0.x, R0.z, {-0.5}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.y, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.z;\n"
				"ADDR R0.z, R0.z, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.z;\n"
				"ADDR R0.y, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.y, maxvalue.x;\n"
				"MOVR R3.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"ADDR R2.xy, R2.xyxx, -maxvalue.xyxx;\n"
				"SGER H0.x, R2.y, {-0.0625}.x;\n"
				"SGER H0.y, R2.x, {-0.0625}.x;\n"
				"SGER H0.z, R2.y, {-1.0625}.x;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R3.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"TEX R0.xy, R3.xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:2:output\n"
				"##c:1:gatherindex\n"
				"##c:2:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat2_fp30 = &__RelativeGatherfloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.0625, 1.0625, 0, 1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, r7.x, c1.x, c1.z;\n"
				"MAD r9.y, r7.y, c1.y, c1.w;\n"
				"TEX r4, r9, texture[0], RECT;\n"
				"MOV r7.w, -c3.x;\n"
				"MAD r6.w, r4.x, r7.w, r7.x;\n"
				"ADD r1.w, r6.w, c7.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"RCP r5.w, c4.x;\n"
				"MUL r0.w, r10.w, r5.w;\n"
				"FRC r2.w, r0.w;\n"
				"MUL r9.w, r2.w, c4.x;\n"
				"ADD r4.w, r9.w, c7.x;\n"
				"FRC r11.w, r4.w;\n"
				"ADD r8.w, r4.w, -r11.w;\n"
				"ADD r10.w, -r8.w, c7.w;\n"
				"ADD r0.w, r8.w, c4.x;\n"
				"CMP r2.w, r10.w, r8.w, r0.w;\n"
				"ADD r9.w, r2.w, c7.y;\n"
				"ADD r11.w, r9.w, -c4.x;\n"
				"CMP r1.x, r11.w, r2.w, c7.z;\n"
				"MUL r1.w, r1.w, r5.w;\n"
				"FRC r6.w, r1.w;\n"
				"ADD r1.w, r1.w, -r6.w;\n"
				"ADD r1.y, r7.y, r1.w;\n"
				"MAD r5.x, r1.x, c2.x, c2.z;\n"
				"MAD r5.y, r1.y, c2.y, c2.w;\n"
				"TEX r3, r5, texture[1], RECT;\n"
				"TEX r10, t1, texture[2], RECT;\n"
				"MAD r3.w, r7.w, c5.x, r7.x;\n"
				"ADD r3.w, r3.w, c7.x;\n"
				"MUL r7.w, r5.w, r3.w;\n"
				"FRC r10.w, r7.w;\n"
				"ADD r7.w, r7.w, -r10.w;\n"
				"ADD r4.y, r7.y, r7.w;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r3.w, r3.w, -r10.w;\n"
				"MUL r3.w, r3.w, r5.w;\n"
				"FRC r3.w, r3.w;\n"
				"MUL r3.w, r3.w, c4.x;\n"
				"ADD r3.w, r3.w, c7.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r3.w, r3.w, -r10.w;\n"
				"ADD r10.w, -r3.w, c7.w;\n"
				"ADD r0.w, r3.w, c4.x;\n"
				"CMP r3.w, r10.w, r3.w, r0.w;\n"
				"ADD r4.w, -c4.x, r3.w;\n"
				"ADD r4.w, r4.w, c7.y;\n"
				"CMP r4.x, r4.w, r3.w, c7.z;\n"
				"ADD r9.xy, r4, -c4;\n"
				"ADD r9.w, r9.y, c6.y;\n"
				"MOV r0.w, c7.z;\n"
				"CMP r9.w, r9.w, r0.w, c6.w;\n"
				"ADD r3.w, r9.x, c6.x;\n"
				"ADD r10.w, r9.y, c6.x;\n"
				"CMP r3.w, r3.w, r0.w, c6.w;\n"
				"MUL r3.w, r9.w, r3.w;\n"
				"CMP r10.w, r10.w, r0.w, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r11.xy, -r3.w, r10.x, r3;\n"
				"MOV r11.zw, c7.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:2:output\n"
				"##c:1:gatherindex\n"
				"##c:2:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat2_arb = &__RelativeGatherfloat2_arb_desc;
}

void __RelativeGatherfloat2_cpu_inner (__BrtFloat2  &output,
                                        const __BrtArray2d<__BrtFloat1  > &gatherindex,
                                        const __BrtArray2d<__BrtFloat2  > &value,
                                        const __BrtFloat1  &inf,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &maxshift,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  isoffedge;

  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * gatherindex[__indexof_output],maxvalue,nextPlaceToLook);
  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * maxshift,maxvalue,isoffedge);
  isoffedge -= maxvalue;
  if (isoffedge.swizzle1(maskY) >= -__BrtFloat1(0.062500f) || isoffedge.swizzle1(maskY) >= -__BrtFloat1(1.062500f) && isoffedge.swizzle1(maskX) >= -__BrtFloat1(0.062500f))
  {
    output = inf;
  }

  else
  {
    output = value[nextPlaceToLook];
  }

}
void  __RelativeGatherfloat2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat2 *arg0 = (__BrtFloat2 *)args[0];
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio3 = extents[0][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[0][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __RelativeGatherfloat2_cpu_inner (
      *arg0,
      arg1,
      arg2,
      *(arg3 + iter3),
      *arg4,
      *arg5,
      *arg6,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[0]);
    }
  }
}

void  RelativeGatherfloat2 (::brook::stream output,
		::brook::stream gatherindex,
		::brook::stream value,
		::brook::stream inf,
		const float  sign,
		const float2  maxvalue,
		const float  maxshift) {
  static const void *__RelativeGatherfloat2_fp[] = {
     "fp30", __RelativeGatherfloat2_fp30,
     "arb", __RelativeGatherfloat2_arb,
     "ps20", __RelativeGatherfloat2_ps20,
     "cpu", (void *) __RelativeGatherfloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__RelativeGatherfloat2_fp);

  k->PushOutput(output);
  k->PushGatherStream(gatherindex);
  k->PushGatherStream(value);
  k->PushStream(inf);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->PushConstant(maxshift);
  k->Map();

}


float  shiftValuesfloat2(::brook::stream list_stream, ::brook::stream (*output_stream), int  WIDTH, int  LENGTH, int  sign)
{
  ::brook::stream tmp_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream ret_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream guess_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  unsigned int  i;
  float2  maxvalue;
  unsigned int  logN;
  unsigned int  LogNMinusK;
  float  maxshift;

  maxvalue.x = (float ) (LENGTH);
  maxvalue.y = (float ) (WIDTH);
  logN = (unsigned int ) (ceil(log((float ) (LENGTH) * WIDTH) / log(2.000000f)));
  debugStreamPrint(list_stream,"Combined...");
  NanToBoolRightfloat2(list_stream,ret_stream,(float ) (sign),maxvalue);
  for (i = 1; i < logN; ++i)
  {
    streamSwap(ret_stream,tmp_stream);
    NanToRightfloat2(tmp_stream,ret_stream,(float ) (sign) * (1 << i),maxvalue);
  }

  debugStreamPrint(ret_stream,"scattering...");
  {
    static ::brook::stream item(::brook::getStreamType(( float  *)0), 1,-1);
    float2  index;

    if (sign == -1)
    {
      index.y = (float ) (WIDTH - 1);
      index.x = (float ) (LENGTH - 1);
    }

    else
    {
      index.y = index.x = 0;
    }

    kernelReadItem(ret_stream,index,item);
    streamWrite(item,&maxshift);
  }

  LogNMinusK = logN - 2;
  i = logN - 1;
  EstablishGuessfloat2(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,(float ) (1 << i),(float ) (sign));
  for (i = 1; i < logN; ++i)
  {
    LogNMinusK = logN - 1 - i;
    streamSwap(tmp_stream,guess_stream);
    UpdateGuessfloat2(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,tmp_stream,(float ) (sign));
  }

  debugStreamPrint(guess_stream,"Gather Value");
  if (1)
  {
    unsigned int  size;
    unsigned int  width;

    size = (unsigned int ) (LENGTH) * (unsigned int ) (WIDTH) - (unsigned int ) (maxshift);
    width = size / LENGTH + ((size % LENGTH) ? (1) : (0));
    if (1)
    {
      ::brook::stream proper_output_stream=quickAllocStream(::brook::getStreamType(( float2  *)0), width , LENGTH,-1);

      if (width)
      {
        RelativeGatherfloat2(proper_output_stream,guess_stream,list_stream,*sentinelStream(2),(float ) (sign),maxvalue,maxshift);
      }

      streamSwap(*output_stream,proper_output_stream);
    }

    debugStreamPrint(*output_stream,"Final Value");
  }

  return maxshift;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine1_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t1.x, c5.x, c5.z\n"
				"    mad r7.y, t1.y, c5.y, c5.w\n"
				"    rcp r7.w, c1.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c0.x, c0.z\n"
				"    mad r8.y, r9.y, c0.y, c0.w\n"
				"    texld r3, r8, s0\n"
				"    texld r10, t0, s1\n"
				"    mul r3.w, r7.y, c4.x\n"
				"    frc r10.w, r2.x\n"
				"    mad r3.w, r10.w, c1.x, r3.w\n"
				"    mul r10.w, r7.w, r3.w\n"
				"    frc r3.w, r10.w\n"
				"    mul r10.w, r3.w, c1.x\n"
				"    add r10.w, r10.w, -c2.x\n"
				"    frc r3.w, r10.w\n"
				"    add r10.w, r10.w, -r3.w\n"
				"    abs r3.w, r10.w\n"
				"    cmp_pp r3.w, -r3.w, c6.w, c6.y\n"
				"    add r10.w, r10.w, -c1.x\n"
				"    abs r10.w, r10.w\n"
				"    cmp_pp r10.w, -r10.w, c6.w, c6.y\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r7.xy, -r3.w, r10, r3\n"
				"    mov r7.zw, c6.y\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:2:input0\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:2:oldoutput\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine1_ps20 = &__float2streamCombine1_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine1_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.offset : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._tex_oldoutput : TEXUNIT1\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var float modulus : C1 :  : 2 : 1\n"
				"#var float offset : C2 :  : 3 : 1\n"
				"#var float length : C3 :  : 4 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 5 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT1 : texunit 1 : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 9 : 1\n"
				"#var float4 __workspace : C6 :  : 11 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX1, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, length.x;\n"
				"MULR R1.x, R2.w, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |length.x|;\n"
				"RCPR R1.y, modulus.x;\n"
				"MULR R1.y, R3.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |modulus.x|;\n"
				"MOVR R1.z, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.x;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, -offset.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SEQR H0.x, R1.x, modulus.x;\n"
				"SEQR H0.y, R1.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"MOVR o[COLR].xy, R1.xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine1_fp30 = &__float2streamCombine1_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine1_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c5.x, c5.z;\n"
				"MAD r7.y, t1.y, c5.y, c5.w;\n"
				"RCP r7.w, c1.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c0.x, c0.z;\n"
				"MAD r8.y, r9.y, c0.y, c0.w;\n"
				"TEX r3, r8, texture[0], RECT;\n"
				"TEX r10, t0, texture[1], RECT;\n"
				"MUL r3.w, r7.y, c4.x;\n"
				"FRC r10.w, r2.x;\n"
				"MAD r3.w, r10.w, c1.x, r3.w;\n"
				"MUL r10.w, r7.w, r3.w;\n"
				"FRC r3.w, r10.w;\n"
				"MUL r10.w, r3.w, c1.x;\n"
				"ADD r10.w, r10.w, -c2.x;\n"
				"FRC r3.w, r10.w;\n"
				"ADD r10.w, r10.w, -r3.w;\n"
				"ABS r3.w, r10.w;\n"
				"CMP r3.w, -r3.w, c6.y, c6.w;\n"
				"ADD r10.w, r10.w, -c1.x;\n"
				"ABS r10.w, r10.w;\n"
				"CMP r10.w, -r10.w, c6.y, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r7.xy, -r3.w, r3, r10;\n"
				"MOV r7.zw, c6.y;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine1_arb = &__float2streamCombine1_arb_desc;
}

void __float2streamCombine1_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat2  &oldoutput,
                                        __BrtFloat2  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = oldoutput;
  }

}
void  __float2streamCombine1_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat2 *arg6 = (__BrtFloat2 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio5 = extents[6][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[6][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[6]);
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine1_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof6);
    i++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[6]);
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float2streamCombine1 (::brook::stream input0,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float2streamCombine1_fp[] = {
     "fp30", __float2streamCombine1_fp30,
     "arb", __float2streamCombine1_arb,
     "ps20", __float2streamCombine1_ps20,
     "cpu", (void *) __float2streamCombine1_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine1_fp);

  k->PushGatherStream(input0);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 1, 0, 0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t0.x, c5.x, c5.z\n"
				"    mad r7.y, t0.y, c5.y, c5.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r3.x, r9.x, c0.x, c0.z\n"
				"    mad r3.y, r9.y, c0.y, c0.w\n"
				"    mad r10.x, r9.x, c1.x, c1.z\n"
				"    mad r10.y, r9.y, c1.y, c1.w\n"
				"    texld r5, r3, s0\n"
				"    texld r0, r10, s1\n"
				"    mul r5.w, r7.y, c4.x\n"
				"    frc r0.w, r2.x\n"
				"    mad r5.w, r0.w, c2.x, r5.w\n"
				"    mul r0.w, r7.w, r5.w\n"
				"    frc r5.w, r0.w\n"
				"    mul r0.w, r5.w, c2.x\n"
				"    add r5.w, r0.w, c6.w\n"
				"    frc r0.w, r5.w\n"
				"    add r5.w, r5.w, -r0.w\n"
				"    abs r0.w, r5.w\n"
				"    cmp_pp r0.w, -r0.w, c6.y, c6.z\n"
				"    add r5.w, r5.w, -c2.x\n"
				"    abs r5.w, r5.w\n"
				"    cmp_pp r5.w, -r5.w, c6.y, c6.z\n"
				"    add_pp r0.w, r0.w, r5.w\n"
				"    cmp r11.xy, -r0.w, r0, r5\n"
				"    mov r11.zw, c6.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:6\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float2streamCombine2f_ps20 = &__float2streamCombine2f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float length : C3 :  : 5 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 8 : 1\n"
				"#var float4 __workspace : C6 :  : 10 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, length.x;\n"
				"MULR R0.x, R1.w, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |length.x|;\n"
				"RCPR R0.y, modulus.x;\n"
				"MULR R0.y, R2.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |modulus.x|;\n"
				"MOVR R0.z, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.x;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, -{-0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SEQR H0.x, R0.x, modulus.x;\n"
				"SEQR H0.y, R0.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xy, R1.xyxx, TEX0, RECT;\n"
				"TEX R1.xy, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R0.xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float2streamCombine2f_fp30 = &__float2streamCombine2f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c5.x, c5.z;\n"
				"MAD r7.y, t0.y, c5.y, c5.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r3.x, r9.x, c0.x, c0.z;\n"
				"MAD r3.y, r9.y, c0.y, c0.w;\n"
				"MAD r10.x, r9.x, c1.x, c1.z;\n"
				"MAD r10.y, r9.y, c1.y, c1.w;\n"
				"TEX r5, r3, texture[0], RECT;\n"
				"TEX r0, r10, texture[1], RECT;\n"
				"MUL r5.w, r7.y, c4.x;\n"
				"FRC r0.w, r2.x;\n"
				"MAD r5.w, r0.w, c2.x, r5.w;\n"
				"MUL r0.w, r7.w, r5.w;\n"
				"FRC r5.w, r0.w;\n"
				"MUL r0.w, r5.w, c2.x;\n"
				"ADD r5.w, r0.w, c6.w;\n"
				"FRC r0.w, r5.w;\n"
				"ADD r5.w, r5.w, -r0.w;\n"
				"ABS r0.w, r5.w;\n"
				"CMP r0.w, -r0.w, c6.z, c6.y;\n"
				"ADD r5.w, r5.w, -c2.x;\n"
				"ABS r5.w, r5.w;\n"
				"CMP r5.w, -r5.w, c6.z, c6.y;\n"
				"ADD r0.w, r0.w, r5.w;\n"
				"CMP r11.xy, -r0.w, r5, r0;\n"
				"MOV r11.zw, c6.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float2streamCombine2f_arb = &__float2streamCombine2f_arb_desc;
}

void __float2streamCombine2f_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                         const __BrtArray2d<__BrtFloat2  > &input1,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat2  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = input1[newindex];
  }

}
void  __float2streamCombine2f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  unsigned int dim=dims[5];
  unsigned int newline=extents[5][dim-1];
  arg5+=mapbegin;
  ;
__BrtFloat4 indexof5 = computeIndexOf(mapbegin, extents[5], dims[5], extents[5]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine2f_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      indexof5);
    i++;
    ++arg5;
indexof5.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof5 = computeReferenceIndexOf(i+mapbegin, extents[5],dim);
    }
  }
}

void  float2streamCombine2f (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float2streamCombine2f_fp[] = {
     "fp30", __float2streamCombine2f_fp30,
     "arb", __float2streamCombine2f_arb,
     "ps20", __float2streamCombine2f_ps20,
     "cpu", (void *) __float2streamCombine2f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine2f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 0, -1, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t1.x, c6.x, c6.z\n"
				"    mad r0.y, t1.y, c6.y, c6.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r5.x, r8.x, c1.x, c1.z\n"
				"    mad r5.y, r8.y, c1.y, c1.w\n"
				"    mad r2.x, r8.x, c0.x, c0.z\n"
				"    mad r2.y, r8.y, c0.y, c0.w\n"
				"    texld r9, r5, s1\n"
				"    texld r4, t0, s2\n"
				"    texld r11, r2, s0\n"
				"    mul r9.w, r0.y, c5.x\n"
				"    frc r4.w, r7.x\n"
				"    mad r9.w, r4.w, c2.x, r9.w\n"
				"    mul r4.w, r7.w, r9.w\n"
				"    frc r9.w, r4.w\n"
				"    mul r4.w, r9.w, c2.x\n"
				"    add r9.w, r4.w, -c3.x\n"
				"    frc r4.w, r9.w\n"
				"    add r9.w, r9.w, -r4.w\n"
				"    add r4.w, r9.w, c7.z\n"
				"    abs r4.w, r4.w\n"
				"    cmp r9.xy, -r4.w, r9, r4\n"
				"    abs r11.w, r9.w\n"
				"    cmp_pp r11.w, -r11.w, c7.w, c7.y\n"
				"    add r9.w, r9.w, -c2.x\n"
				"    abs r9.w, r9.w\n"
				"    cmp_pp r9.w, -r9.w, c7.w, c7.y\n"
				"    add_pp r11.w, r11.w, r9.w\n"
				"    cmp r1.xy, -r11.w, r9, r11\n"
				"    mov r1.zw, c7.y\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:2:oldoutput\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine2_ps20 = &__float2streamCombine2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.offset : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._tex_oldoutput : TEXUNIT2\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float offset : C3 :  : 5 : 1\n"
				"#var float length : C4 :  : 6 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 7 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT2 : texunit 2 : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 11 : 1\n"
				"#var float4 __workspace : C7 :  : 13 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 10 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 12 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R1.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"TEX R2.xy, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R1.xyxx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine2_fp30 = &__float2streamCombine2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t1.x, c6.x, c6.z;\n"
				"MAD r0.y, t1.y, c6.y, c6.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r5.x, r8.x, c1.x, c1.z;\n"
				"MAD r5.y, r8.y, c1.y, c1.w;\n"
				"MAD r2.x, r8.x, c0.x, c0.z;\n"
				"MAD r2.y, r8.y, c0.y, c0.w;\n"
				"TEX r9, r5, texture[1], RECT;\n"
				"TEX r4, t0, texture[2], RECT;\n"
				"TEX r11, r2, texture[0], RECT;\n"
				"MUL r9.w, r0.y, c5.x;\n"
				"FRC r4.w, r7.x;\n"
				"MAD r9.w, r4.w, c2.x, r9.w;\n"
				"MUL r4.w, r7.w, r9.w;\n"
				"FRC r9.w, r4.w;\n"
				"MUL r4.w, r9.w, c2.x;\n"
				"ADD r9.w, r4.w, -c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"ADD r9.w, r9.w, -r4.w;\n"
				"ADD r4.w, r9.w, c7.z;\n"
				"ABS r4.w, r4.w;\n"
				"CMP r9.xy, -r4.w, r4, r9;\n"
				"ABS r11.w, r9.w;\n"
				"CMP r11.w, -r11.w, c7.y, c7.w;\n"
				"ADD r9.w, r9.w, -c2.x;\n"
				"ABS r9.w, r9.w;\n"
				"CMP r9.w, -r9.w, c7.y, c7.w;\n"
				"ADD r11.w, r11.w, r9.w;\n"
				"CMP r1.xy, -r11.w, r11, r9;\n"
				"MOV r1.zw, c7.y;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine2_arb = &__float2streamCombine2_arb_desc;
}

void __float2streamCombine2_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                        const __BrtArray2d<__BrtFloat2  > &input1,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat2  &oldoutput,
                                        __BrtFloat2  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = oldoutput;
    }

}
void  __float2streamCombine2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat2 *arg6 = (__BrtFloat2 *)args[6];
  __BrtFloat2 *arg7 = (__BrtFloat2 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  unsigned int ratio6 = extents[7][dim-1]/extents[6][dim-1];
  unsigned int scale6=extents[6][dim-1]/extents[7][dim-1];
  if (scale6<1) scale6 = 1;
  unsigned int ratioiter6 = 0;
  if (ratio6) ratioiter6 = mapbegin%ratio6;
  unsigned int iter6 = getIndexOf(mapbegin,extents[6], dim, extents[7]);
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine2_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *(arg6 + iter6),
      *arg7,
      indexof7);
    i++;
    if (++ratioiter6>=ratio6){
      ratioiter6=0;
      iter6+=scale6;
    }
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter6=getIndexOf(i+mapbegin,extents[6],dim, extents[7]);
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float2streamCombine2 (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float2streamCombine2_fp[] = {
     "fp30", __float2streamCombine2_fp30,
     "arb", __float2streamCombine2_arb,
     "ps20", __float2streamCombine2_ps20,
     "cpu", (void *) __float2streamCombine2_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine2_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 1, 0, 0.5\n"
				"    def c8, -1, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t0.x, c6.x, c6.z\n"
				"    mad r0.y, t0.y, c6.y, c6.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c1.x, c1.z\n"
				"    mad r10.y, r8.y, c1.y, c1.w\n"
				"    mad r9.x, r8.x, c2.x, c2.z\n"
				"    mad r9.y, r8.y, c2.y, c2.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s1\n"
				"    texld r6, r9, s2\n"
				"    texld r1, r4, s0\n"
				"    mul r11.w, r0.y, c5.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, c7.w\n"
				"    frc r6.w, r11.w\n"
				"    add r11.w, r11.w, -r6.w\n"
				"    add r6.w, r11.w, c8.x\n"
				"    abs r6.w, r6.w\n"
				"    cmp r11.xy, -r6.w, r11, r6\n"
				"    abs r1.w, r11.w\n"
				"    cmp_pp r1.w, -r1.w, c7.y, c7.z\n"
				"    add r11.w, r11.w, -c3.x\n"
				"    abs r11.w, r11.w\n"
				"    cmp_pp r11.w, -r11.w, c7.y, c7.z\n"
				"    add_pp r1.w, r1.w, r11.w\n"
				"    cmp r8.xy, -r1.w, r11, r1\n"
				"    mov r8.zw, c7.z\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine3f_ps20 = &__float2streamCombine3f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float length : C4 :  : 7 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R0.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xy, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xy, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R0.xyxx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"TEX R0.xy, R1.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine3f_fp30 = &__float2streamCombine3f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c8 = {-1, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t0.x, c6.x, c6.z;\n"
				"MAD r0.y, t0.y, c6.y, c6.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c1.x, c1.z;\n"
				"MAD r10.y, r8.y, c1.y, c1.w;\n"
				"MAD r9.x, r8.x, c2.x, c2.z;\n"
				"MAD r9.y, r8.y, c2.y, c2.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[1], RECT;\n"
				"TEX r6, r9, texture[2], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c5.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, c7.w;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r11.w, r11.w, -r6.w;\n"
				"ADD r6.w, r11.w, c8.x;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r11.xy, -r6.w, r6, r11;\n"
				"ABS r1.w, r11.w;\n"
				"CMP r1.w, -r1.w, c7.z, c7.y;\n"
				"ADD r11.w, r11.w, -c3.x;\n"
				"ABS r11.w, r11.w;\n"
				"CMP r11.w, -r11.w, c7.z, c7.y;\n"
				"ADD r1.w, r1.w, r11.w;\n"
				"CMP r8.xy, -r1.w, r1, r11;\n"
				"MOV r8.zw, c7.z;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float2streamCombine3f_arb = &__float2streamCombine3f_arb_desc;
}

void __float2streamCombine3f_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                         const __BrtArray2d<__BrtFloat2  > &input1,
                                         const __BrtArray2d<__BrtFloat2  > &input2,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat2  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = input2[newindex];
    }

}
void  __float2streamCombine3f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat2 *arg6 = (__BrtFloat2 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine3f_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof6);
    i++;
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float2streamCombine3f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float2streamCombine3f_fp[] = {
     "fp30", __float2streamCombine3f_fp30,
     "arb", __float2streamCombine3f_arb,
     "ps20", __float2streamCombine3f_ps20,
     "cpu", (void *) __float2streamCombine3f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine3f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 0, -1, 1\n"
				"    def c9, -2, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    rcp r0.w, c5.x\n"
				"    mad r0.x, t1.x, c7.x, c7.z\n"
				"    mad r0.y, t1.y, c7.y, c7.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c5.x, r7.x\n"
				"    add r11.w, r4.w, c8.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c5.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c8.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c2.x, c2.z\n"
				"    mad r10.y, r8.y, c2.y, c2.w\n"
				"    mad r9.x, r8.x, c1.x, c1.z\n"
				"    mad r9.y, r8.y, c1.y, c1.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s2\n"
				"    texld r6, t0, s3\n"
				"    texld r1, r9, s1\n"
				"    texld r8, r4, s0\n"
				"    mul r11.w, r0.y, c6.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, -c4.x\n"
				"    frc r6.w, r11.w\n"
				"    add r1.w, r11.w, -r6.w\n"
				"    add r11.w, r1.w, c9.x\n"
				"    abs r11.w, r11.w\n"
				"    cmp r7.xy, -r11.w, r11, r6\n"
				"    add r7.w, r1.w, c8.z\n"
				"    abs r7.w, r7.w\n"
				"    cmp r1.xy, -r7.w, r1, r7\n"
				"    abs r8.w, r1.w\n"
				"    cmp_pp r8.w, -r8.w, c8.w, c8.y\n"
				"    add r1.w, r1.w, -c3.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.w, c8.y\n"
				"    add_pp r8.w, r8.w, r1.w\n"
				"    cmp r10.xy, -r8.w, r1, r8\n"
				"    mov r10.zw, c8.y\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:2:oldoutput\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine3_ps20 = &__float2streamCombine3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.offset : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._tex_oldoutput : TEXUNIT3\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float offset : C4 :  : 7 : 1\n"
				"#var float length : C5 :  : 8 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 9 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT3 : texunit 3 : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 13 : 1\n"
				"#var float4 __workspace : C8 :  : 15 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 12 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 14 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX3, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"SEQR H0.w, R1.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.xy, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R1.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R3.xyxx;\n"
				"TEX R1.xy, R2.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine3_fp30 = &__float2streamCombine3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 0, -1, 1};\n"
				"PARAM c9 = {-2, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c5.x;\n"
				"MAD r0.x, t1.x, c7.x, c7.z;\n"
				"MAD r0.y, t1.y, c7.y, c7.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c5.x, r7.x;\n"
				"ADD r11.w, r4.w, c8.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c5.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c8.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c2.x, c2.z;\n"
				"MAD r10.y, r8.y, c2.y, c2.w;\n"
				"MAD r9.x, r8.x, c1.x, c1.z;\n"
				"MAD r9.y, r8.y, c1.y, c1.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[2], RECT;\n"
				"TEX r6, t0, texture[3], RECT;\n"
				"TEX r1, r9, texture[1], RECT;\n"
				"TEX r8, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c6.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, -c4.x;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r1.w, r11.w, -r6.w;\n"
				"ADD r11.w, r1.w, c9.x;\n"
				"ABS r11.w, r11.w;\n"
				"CMP r7.xy, -r11.w, r6, r11;\n"
				"ADD r7.w, r1.w, c8.z;\n"
				"ABS r7.w, r7.w;\n"
				"CMP r1.xy, -r7.w, r7, r1;\n"
				"ABS r8.w, r1.w;\n"
				"CMP r8.w, -r8.w, c8.y, c8.w;\n"
				"ADD r1.w, r1.w, -c3.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c8.y, c8.w;\n"
				"ADD r8.w, r8.w, r1.w;\n"
				"CMP r10.xy, -r8.w, r8, r1;\n"
				"MOV r10.zw, c8.y;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine3_arb = &__float2streamCombine3_arb_desc;
}

void __float2streamCombine3_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                        const __BrtArray2d<__BrtFloat2  > &input1,
                                        const __BrtArray2d<__BrtFloat2  > &input2,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat2  &oldoutput,
                                        __BrtFloat2  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = oldoutput;
      }

}
void  __float2streamCombine3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat2 *arg7 = (__BrtFloat2 *)args[7];
  __BrtFloat2 *arg8 = (__BrtFloat2 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  unsigned int ratio7 = extents[8][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[8][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[8]);
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine3_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *(arg7 + iter7),
      *arg8,
      indexof8);
    i++;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[8]);
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float2streamCombine3 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float2streamCombine3_fp[] = {
     "fp30", __float2streamCombine3_fp30,
     "arb", __float2streamCombine3_arb,
     "ps20", __float2streamCombine3_ps20,
     "cpu", (void *) __float2streamCombine3_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine3_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 1, 0, 0.5\n"
				"    def c9, -1, 0, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    mad r7.x, t0.x, c7.x, c7.z\n"
				"    mad r7.y, t0.y, c7.y, c7.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c5.x, r2.x\n"
				"    add r9.w, r2.y, c8.x\n"
				"    add r2.w, r2.w, c8.x\n"
				"    rcp r4.w, c5.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c5.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c2.x, c2.z\n"
				"    mad r8.y, r9.y, c2.y, c2.w\n"
				"    mad r10.x, r9.x, c3.x, c3.z\n"
				"    mad r10.y, r9.y, c3.y, c3.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s2\n"
				"    texld r9, r10, s3\n"
				"    texld r1, r4, s1\n"
				"    texld r8, r11, s0\n"
				"    mul r6.w, r7.y, c6.x\n"
				"    frc r9.w, r2.x\n"
				"    mad r6.w, r9.w, c4.x, r6.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r6.w, r9.w, c8.w\n"
				"    frc r9.w, r6.w\n"
				"    add r1.w, r6.w, -r9.w\n"
				"    add r6.w, r1.w, c9.w\n"
				"    abs r6.w, r6.w\n"
				"    cmp r7.xy, -r6.w, r6, r9\n"
				"    add r7.w, r1.w, c9.x\n"
				"    abs r7.w, r7.w\n"
				"    cmp r1.xy, -r7.w, r1, r7\n"
				"    abs r8.w, r1.w\n"
				"    cmp_pp r8.w, -r8.w, c8.y, c8.z\n"
				"    add r1.w, r1.w, -c4.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.y, c8.z\n"
				"    add_pp r8.w, r8.w, r1.w\n"
				"    cmp r10.xy, -r8.w, r1, r8\n"
				"    mov r10.zw, c8.z\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//c:2:input3\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine4f_ps20 = &__float2streamCombine4f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float length : C5 :  : 9 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 12 : 1\n"
				"#var float4 __workspace : C8 :  : 14 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 11 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"SEQR H0.w, R0.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xy, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xy, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R0.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"TEX R0.xy, R1.xyxx, TEX2, RECT;\n"
				"TEX R1.xy, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine4f_fp30 = &__float2streamCombine4f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c9 = {-1, 0, 0, -2};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c7.x, c7.z;\n"
				"MAD r7.y, t0.y, c7.y, c7.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c5.x, r2.x;\n"
				"ADD r9.w, r2.y, c8.x;\n"
				"ADD r2.w, r2.w, c8.x;\n"
				"RCP r4.w, c5.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c5.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c2.x, c2.z;\n"
				"MAD r8.y, r9.y, c2.y, c2.w;\n"
				"MAD r10.x, r9.x, c3.x, c3.z;\n"
				"MAD r10.y, r9.y, c3.y, c3.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[2], RECT;\n"
				"TEX r9, r10, texture[3], RECT;\n"
				"TEX r1, r4, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"MUL r6.w, r7.y, c6.x;\n"
				"FRC r9.w, r2.x;\n"
				"MAD r6.w, r9.w, c4.x, r6.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r6.w, r9.w, c8.w;\n"
				"FRC r9.w, r6.w;\n"
				"ADD r1.w, r6.w, -r9.w;\n"
				"ADD r6.w, r1.w, c9.w;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r7.xy, -r6.w, r9, r6;\n"
				"ADD r7.w, r1.w, c9.x;\n"
				"ABS r7.w, r7.w;\n"
				"CMP r1.xy, -r7.w, r7, r1;\n"
				"ABS r8.w, r1.w;\n"
				"CMP r8.w, -r8.w, c8.z, c8.y;\n"
				"ADD r1.w, r1.w, -c4.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c8.z, c8.y;\n"
				"ADD r8.w, r8.w, r1.w;\n"
				"CMP r10.xy, -r8.w, r8, r1;\n"
				"MOV r10.zw, c8.z;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float2streamCombine4f_arb = &__float2streamCombine4f_arb_desc;
}

void __float2streamCombine4f_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                         const __BrtArray2d<__BrtFloat2  > &input1,
                                         const __BrtArray2d<__BrtFloat2  > &input2,
                                         const __BrtArray2d<__BrtFloat2  > &input3,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat2  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = input3[newindex];
      }

}
void  __float2streamCombine4f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat2  > arg3(
      (__BrtFloat2  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat2 *arg7 = (__BrtFloat2 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine4f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      indexof7);
    i++;
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float2streamCombine4f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float2streamCombine4f_fp[] = {
     "fp30", __float2streamCombine4f_fp30,
     "arb", __float2streamCombine4f_arb,
     "ps20", __float2streamCombine4f_ps20,
     "cpu", (void *) __float2streamCombine4f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine4f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 0, -1, 1\n"
				"    def c10, -2, 0, 0, -3\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t1.x, c8.x, c8.z\n"
				"    mad r7.y, t1.y, c8.y, c8.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c2.x, c2.z\n"
				"    mad r10.y, r9.y, c2.y, c2.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s3\n"
				"    texld r9, t0, s4\n"
				"    texld r1, r10, s2\n"
				"    texld r8, r4, s1\n"
				"    texld r3, r11, s0\n"
				"    mul r6.w, r7.y, c7.x\n"
				"    frc r9.w, r2.x\n"
				"    mad r6.w, r9.w, c4.x, r6.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r9.w, r9.w, -c5.x\n"
				"    frc r6.w, r9.w\n"
				"    add r8.w, r9.w, -r6.w\n"
				"    add r9.w, r8.w, c10.w\n"
				"    abs r9.w, r9.w\n"
				"    cmp r7.xy, -r9.w, r6, r9\n"
				"    add r1.w, r8.w, c10.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp r2.xy, -r1.w, r1, r7\n"
				"    add r2.w, r8.w, c9.z\n"
				"    abs r2.w, r2.w\n"
				"    cmp r8.xy, -r2.w, r8, r2\n"
				"    abs r3.w, r8.w\n"
				"    cmp_pp r3.w, -r3.w, c9.w, c9.y\n"
				"    add r8.w, r8.w, -c4.x\n"
				"    abs r8.w, r8.w\n"
				"    cmp_pp r8.w, -r8.w, c9.w, c9.y\n"
				"    add_pp r3.w, r3.w, r8.w\n"
				"    cmp r0.xy, -r3.w, r8, r3\n"
				"    mov r0.zw, c9.y\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:10\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//c:2:input3\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:2:oldoutput\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float2streamCombine4_ps20 = &__float2streamCombine4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.offset : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._tex_oldoutput : TEXUNIT4\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float offset : C5 :  : 9 : 1\n"
				"#var float length : C6 :  : 10 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 11 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT4 : texunit 4 : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 15 : 1\n"
				"#var float4 __workspace : C9 :  : 17 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 14 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 16 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xy, f[TEX0].xyxx, TEX4, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R1.y, {2}.x;\n"
				"SEQR H0.w, R1.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xy, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.xy, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R1.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R3.xyxx;\n"
				"TEX R1.xy, R2.xyxx, TEX2, RECT;\n"
				"TEX R2.xy, R2.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float2streamCombine4_fp30 = &__float2streamCombine4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-2, 0, 0, -3};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c8.x, c8.z;\n"
				"MAD r7.y, t1.y, c8.y, c8.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c2.x, c2.z;\n"
				"MAD r10.y, r9.y, c2.y, c2.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[3], RECT;\n"
				"TEX r9, t0, texture[4], RECT;\n"
				"TEX r1, r10, texture[2], RECT;\n"
				"TEX r8, r4, texture[1], RECT;\n"
				"TEX r3, r11, texture[0], RECT;\n"
				"MUL r6.w, r7.y, c7.x;\n"
				"FRC r9.w, r2.x;\n"
				"MAD r6.w, r9.w, c4.x, r6.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r9.w, r9.w, -c5.x;\n"
				"FRC r6.w, r9.w;\n"
				"ADD r8.w, r9.w, -r6.w;\n"
				"ADD r9.w, r8.w, c10.w;\n"
				"ABS r9.w, r9.w;\n"
				"CMP r7.xy, -r9.w, r9, r6;\n"
				"ADD r1.w, r8.w, c10.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r2.xy, -r1.w, r7, r1;\n"
				"ADD r2.w, r8.w, c9.z;\n"
				"ABS r2.w, r2.w;\n"
				"CMP r8.xy, -r2.w, r2, r8;\n"
				"ABS r3.w, r8.w;\n"
				"CMP r3.w, -r3.w, c9.y, c9.w;\n"
				"ADD r8.w, r8.w, -c4.x;\n"
				"ABS r8.w, r8.w;\n"
				"CMP r8.w, -r8.w, c9.y, c9.w;\n"
				"ADD r3.w, r3.w, r8.w;\n"
				"CMP r0.xy, -r3.w, r3, r8;\n"
				"MOV r0.zw, c9.y;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:2:oldoutput\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float2streamCombine4_arb = &__float2streamCombine4_arb_desc;
}

void __float2streamCombine4_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                        const __BrtArray2d<__BrtFloat2  > &input1,
                                        const __BrtArray2d<__BrtFloat2  > &input2,
                                        const __BrtArray2d<__BrtFloat2  > &input3,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat2  &oldoutput,
                                        __BrtFloat2  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = oldoutput;
        }

}
void  __float2streamCombine4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat2  > arg3(
      (__BrtFloat2  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat2 *arg8 = (__BrtFloat2 *)args[8];
  __BrtFloat2 *arg9 = (__BrtFloat2 *)args[9];
  unsigned int dim=dims[9];
  unsigned int newline=extents[9][dim-1];
  unsigned int ratio8 = extents[9][dim-1]/extents[8][dim-1];
  unsigned int scale8=extents[8][dim-1]/extents[9][dim-1];
  if (scale8<1) scale8 = 1;
  unsigned int ratioiter8 = 0;
  if (ratio8) ratioiter8 = mapbegin%ratio8;
  unsigned int iter8 = getIndexOf(mapbegin,extents[8], dim, extents[9]);
  arg9+=mapbegin;
  ;
__BrtFloat4 indexof9 = computeIndexOf(mapbegin, extents[9], dims[9], extents[9]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine4_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      *(arg8 + iter8),
      *arg9,
      indexof9);
    i++;
    if (++ratioiter8>=ratio8){
      ratioiter8=0;
      iter8+=scale8;
    }
    ++arg9;
indexof9.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter8=getIndexOf(i+mapbegin,extents[8],dim, extents[9]);
      indexof9 = computeReferenceIndexOf(i+mapbegin, extents[9],dim);
    }
  }
}

void  float2streamCombine4 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float2streamCombine4_fp[] = {
     "fp30", __float2streamCombine4_fp30,
     "arb", __float2streamCombine4_arb,
     "ps20", __float2streamCombine4_ps20,
     "cpu", (void *) __float2streamCombine4_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine4_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine5f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 1, 0, 0.5\n"
				"    def c10, -1, -3, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t0.x, c8.x, c8.z\n"
				"    mad r7.y, t0.y, c8.y, c8.w\n"
				"    rcp r7.w, c5.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c4.x, c4.z\n"
				"    mad r10.y, r9.y, c4.y, c4.w\n"
				"    mad r0.x, r9.x, c2.x, c2.z\n"
				"    mad r0.y, r9.y, c2.y, c2.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    mov r4.xy, r9\n"
				"    mad r9.x, r4.x, c0.x, c0.z\n"
				"    mad r9.y, r4.y, c0.y, c0.w\n"
				"    texld r1, r8, s3\n"
				"    texld r8, r10, s4\n"
				"    texld r3, r0, s2\n"
				"    texld r10, r6, s1\n"
				"    texld r5, r9, s0\n"
				"    mul r1.w, r7.y, c7.x\n"
				"    frc r8.w, r2.x\n"
				"    mad r1.w, r8.w, c5.x, r1.w\n"
				"    mul r8.w, r7.w, r1.w\n"
				"    frc r1.w, r8.w\n"
				"    mul r8.w, r1.w, c5.x\n"
				"    add r1.w, r8.w, c9.w\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    add r1.w, r10.w, c10.y\n"
				"    abs r1.w, r1.w\n"
				"    cmp r7.xy, -r1.w, r1, r8\n"
				"    add r3.w, r10.w, c10.w\n"
				"    abs r3.w, r3.w\n"
				"    cmp r2.xy, -r3.w, r3, r7\n"
				"    add r2.w, r10.w, c10.x\n"
				"    abs r2.w, r2.w\n"
				"    cmp r10.xy, -r2.w, r10, r2\n"
				"    abs r5.w, r10.w\n"
				"    cmp_pp r5.w, -r5.w, c9.y, c9.z\n"
				"    add r10.w, r10.w, -c5.x\n"
				"    abs r10.w, r10.w\n"
				"    cmp_pp r10.w, -r10.w, c9.y, c9.z\n"
				"    add_pp r5.w, r5.w, r10.w\n"
				"    cmp r11.xy, -r5.w, r10, r5\n"
				"    mov r11.zw, c9.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:2:input0\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//c:2:input3\n"
				"//c:2:input4\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:2:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine5f_ps20 = &__float2streamCombine5f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine5f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.input4 : TEXUNIT4\n"
				"#semantic main.__gatherconst_input4 : C4\n"
				"#semantic main.modulus : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var samplerRECT input4[0] : TEXUNIT4 : texunit 4 : 8 : 1\n"
				"#var float4 __gatherconst_input4 : C4 :  : 9 : 1\n"
				"#var float modulus : C5 :  : 10 : 1\n"
				"#var float length : C6 :  : 11 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 14 : 1\n"
				"#var float4 __workspace : C9 :  : 16 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 13 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 15 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE __gatherconst_input4;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R0.y, {2}.x;\n"
				"SEQR H0.w, R0.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xy, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xy, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, R0.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"TEX R0.xy, R1.xyxx, TEX2, RECT;\n"
				"TEX R2.xy, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xy(GT.x), R2.xyxx;\n"
				"TEX R0.xy, R1.xyxx, TEX4, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:2:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine5f_fp30 = &__float2streamCombine5f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float2streamCombine5f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-1, -3, 0, -2};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c8.x, c8.z;\n"
				"MAD r7.y, t0.y, c8.y, c8.w;\n"
				"RCP r7.w, c5.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c4.x, c4.z;\n"
				"MAD r10.y, r9.y, c4.y, c4.w;\n"
				"MAD r0.x, r9.x, c2.x, c2.z;\n"
				"MAD r0.y, r9.y, c2.y, c2.w;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"MOV r4.xy, r9;\n"
				"MAD r9.x, r4.x, c0.x, c0.z;\n"
				"MAD r9.y, r4.y, c0.y, c0.w;\n"
				"TEX r1, r8, texture[3], RECT;\n"
				"TEX r8, r10, texture[4], RECT;\n"
				"TEX r3, r0, texture[2], RECT;\n"
				"TEX r10, r6, texture[1], RECT;\n"
				"TEX r5, r9, texture[0], RECT;\n"
				"MUL r1.w, r7.y, c7.x;\n"
				"FRC r8.w, r2.x;\n"
				"MAD r1.w, r8.w, c5.x, r1.w;\n"
				"MUL r8.w, r7.w, r1.w;\n"
				"FRC r1.w, r8.w;\n"
				"MUL r8.w, r1.w, c5.x;\n"
				"ADD r1.w, r8.w, c9.w;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"ADD r1.w, r10.w, c10.y;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r7.xy, -r1.w, r8, r1;\n"
				"ADD r3.w, r10.w, c10.w;\n"
				"ABS r3.w, r3.w;\n"
				"CMP r2.xy, -r3.w, r7, r3;\n"
				"ADD r2.w, r10.w, c10.x;\n"
				"ABS r2.w, r2.w;\n"
				"CMP r10.xy, -r2.w, r2, r10;\n"
				"ABS r5.w, r10.w;\n"
				"CMP r5.w, -r5.w, c9.z, c9.y;\n"
				"ADD r10.w, r10.w, -c5.x;\n"
				"ABS r10.w, r10.w;\n"
				"CMP r10.w, -r10.w, c9.z, c9.y;\n"
				"ADD r5.w, r5.w, r10.w;\n"
				"CMP r11.xy, -r5.w, r5, r10;\n"
				"MOV r11.zw, c9.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:2:input0\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##c:2:input3\n"
				"##c:2:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:2:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float2streamCombine5f_arb = &__float2streamCombine5f_arb_desc;
}

void __float2streamCombine5f_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input0,
                                         const __BrtArray2d<__BrtFloat2  > &input1,
                                         const __BrtArray2d<__BrtFloat2  > &input2,
                                         const __BrtArray2d<__BrtFloat2  > &input3,
                                         const __BrtArray2d<__BrtFloat2  > &input4,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat2  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = input4[newindex];
        }

}
void  __float2streamCombine5f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat2  > arg2(
      (__BrtFloat2  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat2  > arg3(
      (__BrtFloat2  *)args[3], extents[3]);
  __BrtArray2d<__BrtFloat2  > arg4(
      (__BrtFloat2  *)args[4], extents[4]);
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat2 *arg8 = (__BrtFloat2 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float2streamCombine5f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      *arg5,
      *arg6,
      *arg7,
      *arg8,
      indexof8);
    i++;
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float2streamCombine5f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		::brook::stream input4,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float2streamCombine5f_fp[] = {
     "fp30", __float2streamCombine5f_fp30,
     "arb", __float2streamCombine5f_arb,
     "ps20", __float2streamCombine5f_ps20,
     "cpu", (void *) __float2streamCombine5f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float2streamCombine5f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushGatherStream(input4);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}


void  combineStreamsHelperfloat2(::brook::stream (**streams), unsigned int  num, ::brook::stream output, float  modulus, float  offset, float  length, float  lengthmodmodulus)
{
  switch (num)
  {
  case 1:
    float2streamCombine1(*streams[0],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 2:
    float2streamCombine2(*streams[0],*streams[1],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 3:
    float2streamCombine3(*streams[0],*streams[1],*streams[2],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 4:
  default:
    float2streamCombine4(*streams[0],*streams[1],*streams[2],*streams[3],modulus,offset,length,lengthmodmodulus,output,output);
    if (num > 4)
    {
      combineStreamsHelperfloat2(streams + 4,num - 4,output,modulus,4 + offset,length,lengthmodmodulus);
    }

  }

}

void  combineStreamsfloat2(::brook::stream (**streams), unsigned int  num, unsigned int  width, unsigned int  length, ::brook::stream (*output))
{
  unsigned int  lengthmodmodulus = (num != 0) ? (length % num) : (0);
  ::brook::stream tmp=quickAllocStream(::brook::getStreamType(( float2  *)0), num * width , length,-1);

  streamSwap(tmp,*output);
  switch (num)
  {
  case 0:
    return;
  case 1:
    streamSwap(*output,*streams[0]);
    break;
  case 2:
    float2streamCombine2f(*streams[0],*streams[1],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 3:
    float2streamCombine3f(*streams[0],*streams[1],*streams[2],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 4:
    float2streamCombine4f(*streams[0],*streams[1],*streams[2],*streams[3],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 5:
  default:
    float2streamCombine5f(*streams[0],*streams[1],*streams[2],*streams[3],*streams[4],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    if (num > MAX_VOUT_STREAMS)
    {
      fprintf(stderr,"vout stream not reconstituted properly. %s%d streams","Too little precision for more than ",MAX_VOUT_STREAMS);
    }

    if (num > 5)
    {
      combineStreamsHelperfloat2(streams + 5,num - 5,*output,(float ) (num),(float ) (5 - 0.500000f),(float ) (length),(float ) (lengthmodmodulus));
    }

  }

}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0, 0.5, -0.5, 1\n"
				"    def c8, 0.25, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r0.x, t0.x, c2.x, c2.z\n"
				"    mad r0.y, t0.y, c2.y, c2.w\n"
				"    add r0.w, -c3.x, r0.x\n"
				"    add r7.w, r0.w, c7.y\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c5.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r1.w, r7.w, r11.w\n"
				"    frc r8.w, r6.w\n"
				"    mul r3.w, r8.w, c5.x\n"
				"    add r10.w, r3.w, c7.y\n"
				"    frc r5.w, r10.w\n"
				"    add r2.w, r10.w, -r5.w\n"
				"    add r4.w, -r2.w, c7.z\n"
				"    add r11.w, r2.w, c5.x\n"
				"    cmp r6.w, r4.w, r11.w, r2.w\n"
				"    add r8.w, r6.w, c8.x\n"
				"    add r10.w, r8.w, -c5.x\n"
				"    cmp r1.x, r10.w, c7.x, r6.w\n"
				"    frc r5.w, r1.w\n"
				"    add r1.w, r1.w, -r5.w\n"
				"    add r9.w, r0.y, -c3.y\n"
				"    add r1.y, r1.w, r9.w\n"
				"    mad r9.x, r1.x, c1.x, c1.z\n"
				"    mad r9.y, r1.y, c1.y, c1.w\n"
				"    mad r11.x, r0.x, c0.x, c0.z\n"
				"    mad r11.y, r0.y, c0.y, c0.w\n"
				"    texld r6, r9, s1\n"
				"    texld r8, r11, s0\n"
				"    cmp_pp r6.w, r0.w, c7.w, c7.x\n"
				"    add r8.w, r1.x, -c4.x\n"
				"    cmp_pp r8.w, r8.w, c7.w, c7.x\n"
				"    add r1.w, r1.y, -c4.y\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c7.w, c7.x\n"
				"    mul r8.w, r8.w, r1.w\n"
				"    add r0.w, -r1.y, c4.y\n"
				"    cmp_pp r0.w, r0.w, c7.x, c7.w\n"
				"    add_pp r8.w, r8.w, r0.w\n"
				"    cmp r6.xy, -r8.w, r6, c6.x\n"
				"    abs r8.w, r9.w\n"
				"    cmp_pp r8.w, -r8.w, c7.w, c7.x\n"
				"    mul r6.w, r6.w, r8.w\n"
				"    add r8.w, -r0.y, c3.y\n"
				"    cmp_pp r8.w, r8.w, c7.x, c7.w\n"
				"    add_pp r6.w, r6.w, r8.w\n"
				"    cmp r3.xy, -r6.w, r8, r6\n"
				"    mov r3.zw, c7.x\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:2:input1\n"
				"//c:2:input2\n"
				"//oi:2:output\n"
				"//c:2:startsecond\n"
				"//c:2:endsecond\n"
				"//c:2:maxinput2value\n"
				"//c:1:inf\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat2_ps20 = &__combinefloat2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input1 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input1 : C0\n"
				"#semantic main.input2 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input2 : C1\n"
				"#semantic main._const_output_invscalebias : C2\n"
				"#semantic main.startsecond : C3\n"
				"#semantic main.endsecond : C4\n"
				"#semantic main.maxinput2value : C5\n"
				"#semantic main.inf : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input1[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input1 : C0 :  : 1 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input2 : C1 :  : 3 : 1\n"
				"#var float4 _const_output_invscalebias : C2 :  : 5 : 1\n"
				"#var float2 startsecond : C3 :  : 7 : 1\n"
				"#var float2 endsecond : C4 :  : 8 : 1\n"
				"#var float2 maxinput2value : C5 :  : 9 : 1\n"
				"#var float inf : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 6 : 1\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE startsecond;\n"
				"DECLARE endsecond;\n"
				"DECLARE maxinput2value;\n"
				"DECLARE inf;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SGTR H0.x, R0.y, startsecond.y;\n"
				"SGER H0.y, R0.x, startsecond.x;\n"
				"SEQR H0.z, R0.y, startsecond.y;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDR R0.w, R0.y, -startsecond.y;\n"
				"MOVR R1.y, R0.w;\n"
				"MOVR R1.x, R0.x;\n"
				"TEX R0.xy, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.w, R1.x, -startsecond.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxinput2value.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.z, R1.x, {0}.x;\n"
				"RCPR R1.y, maxinput2value.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxinput2value.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.z, R1.x, {-0.5}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxinput2value.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.z, R1.x, maxinput2value.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SGTR H0.z, R3.y, endsecond.y;\n"
				"SGER H0.w, R3.x, endsecond.x;\n"
				"SEQR H1.x, R3.y, endsecond.y;\n"
				"MADX H0.z, H1.x, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"TEX R1.xy, R3.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xy, inf.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xy(GT.x), R1.xyxx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xy(GT.x), R0.xyxx;\n"
				"MOVR o[COLR].zw, {0, 0, 0, 0}.zzzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##oi:2:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat2_fp30 = &__combinefloat2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0, 0.5, -0.5, 1};\n"
				"PARAM c8 = {0.25, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r0.x, t0.x, c2.x, c2.z;\n"
				"MAD r0.y, t0.y, c2.y, c2.w;\n"
				"ADD r0.w, -c3.x, r0.x;\n"
				"ADD r7.w, r0.w, c7.y;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c5.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r1.w, r7.w, r11.w;\n"
				"FRC r8.w, r6.w;\n"
				"MUL r3.w, r8.w, c5.x;\n"
				"ADD r10.w, r3.w, c7.y;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r2.w, r10.w, -r5.w;\n"
				"ADD r4.w, -r2.w, c7.z;\n"
				"ADD r11.w, r2.w, c5.x;\n"
				"CMP r6.w, r4.w, r2.w, r11.w;\n"
				"ADD r8.w, r6.w, c8.x;\n"
				"ADD r10.w, r8.w, -c5.x;\n"
				"CMP r1.x, r10.w, r6.w, c7.x;\n"
				"FRC r5.w, r1.w;\n"
				"ADD r1.w, r1.w, -r5.w;\n"
				"ADD r9.w, r0.y, -c3.y;\n"
				"ADD r1.y, r1.w, r9.w;\n"
				"MAD r9.x, r1.x, c1.x, c1.z;\n"
				"MAD r9.y, r1.y, c1.y, c1.w;\n"
				"MAD r11.x, r0.x, c0.x, c0.z;\n"
				"MAD r11.y, r0.y, c0.y, c0.w;\n"
				"TEX r6, r9, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"CMP r6.w, r0.w, c7.x, c7.w;\n"
				"ADD r8.w, r1.x, -c4.x;\n"
				"CMP r8.w, r8.w, c7.x, c7.w;\n"
				"ADD r1.w, r1.y, -c4.y;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c7.x, c7.w;\n"
				"MUL r8.w, r8.w, r1.w;\n"
				"ADD r0.w, -r1.y, c4.y;\n"
				"CMP r0.w, r0.w, c7.w, c7.x;\n"
				"ADD r8.w, r8.w, r0.w;\n"
				"CMP r6.xy, -r8.w, c6.x, r6;\n"
				"ABS r8.w, r9.w;\n"
				"CMP r8.w, -r8.w, c7.x, c7.w;\n"
				"MUL r6.w, r6.w, r8.w;\n"
				"ADD r8.w, -r0.y, c3.y;\n"
				"CMP r8.w, r8.w, c7.w, c7.x;\n"
				"ADD r6.w, r6.w, r8.w;\n"
				"CMP r3.xy, -r6.w, r6, r8;\n"
				"MOV r3.zw, c7.x;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:2:input1\n"
				"##c:2:input2\n"
				"##oi:2:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat2_arb = &__combinefloat2_arb_desc;
}

void __combinefloat2_cpu_inner (const __BrtArray2d<__BrtFloat2  > &input1,
                                 const __BrtArray2d<__BrtFloat2  > &input2,
                                 __BrtFloat2  &output,
                                 const __BrtFloat2  &startsecond,
                                 const __BrtFloat2  &endsecond,
                                 const __BrtFloat2  &maxinput2value,
                                 const __BrtFloat1  &inf,
                                 const __BrtFloat4 &__indexof_output){
  if ((__indexof_output).swizzle1(maskY) > startsecond.swizzle1(maskY) || (__indexof_output).swizzle1(maskY) == startsecond.swizzle1(maskY) && (__indexof_output).swizzle1(maskX) >= startsecond.swizzle1(maskX))
  {
    __BrtFloat2  secondindex;

    __getIndexAt_cpu_inner(__BrtFloat4 ((__indexof_output).swizzle1(maskX),(__indexof_output).swizzle1(maskY) - startsecond.swizzle1(maskY),__BrtFloat1((float)0),__BrtFloat1((float)0)),-startsecond.swizzle1(maskX),maxinput2value,secondindex);
    if (secondindex.swizzle1(maskY) > endsecond.swizzle1(maskY) || secondindex.swizzle1(maskY) == endsecond.swizzle1(maskY) && secondindex.swizzle1(maskX) >= endsecond.swizzle1(maskX))
    {
      output = inf;
    }

    else
    {
      output = input2[secondindex];
    }

  }

  else
  {
    output = input1[__indexof_output];
  }

}
void  __combinefloat2_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat2  > arg0(
      (__BrtFloat2  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat2  > arg1(
      (__BrtFloat2  *)args[1], extents[1]);
  __BrtFloat2 *arg2 = (__BrtFloat2 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  ;
__BrtFloat4 indexof2 = computeIndexOf(mapbegin, extents[2], dims[2], extents[2]);
  unsigned int i=0; 
  while (i<mapextent) {
    __combinefloat2_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof2);
    i++;
    ++arg2;
indexof2.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof2 = computeReferenceIndexOf(i+mapbegin, extents[2],dim);
    }
  }
}

void  combinefloat2 (::brook::stream input1,
		::brook::stream input2,
		::brook::stream output,
		const float2  startsecond,
		const float2  endsecond,
		const float2  maxinput2value,
		const float  inf) {
  static const void *__combinefloat2_fp[] = {
     "fp30", __combinefloat2_fp30,
     "arb", __combinefloat2_arb,
     "ps20", __combinefloat2_ps20,
     "cpu", (void *) __combinefloat2_cpu,
     NULL, NULL };
  static __BRTKernel k(__combinefloat2_fp);

  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushOutput(output);
  k->PushConstant(startsecond);
  k->PushConstant(endsecond);
  k->PushConstant(maxinput2value);
  k->PushConstant(inf);
  k->Map();

}


unsigned int  voutCombinefloat2(::brook::stream outleft_stream, float  maxshiftleft, unsigned int  LEFTWIDTH, ::brook::stream outright_stream, float  maxshiftright, unsigned int  RIGHTWIDTH, unsigned int  LENGTH, ::brook::stream (*output))
{
  unsigned int  totalsize;
  float2  maxleftvalue;
  float2  maxrightvalue;

  maxleftvalue.x = (float ) (LENGTH);
  maxleftvalue.y = (float ) (LEFTWIDTH);
  maxrightvalue.x = (float ) (LENGTH);
  maxrightvalue.y = (float ) (RIGHTWIDTH);
  totalsize = LEFTWIDTH * LENGTH + RIGHTWIDTH * LENGTH - (unsigned int ) (maxshiftleft) - (unsigned int ) (maxshiftright);
  if (1)
  {
    unsigned int  length = LENGTH;
    unsigned int  width = totalsize / length + ((totalsize % length != 0) ? (1) : (0));
    ::brook::stream output_stream=quickAllocStream(::brook::getStreamType(( float2  *)0), width , length,-1);
    float2  startsecond;
    float2  endsecond;

    cpuGetIndexAt(float2 (maxleftvalue.x,maxleftvalue.y - 1),-maxshiftleft,maxleftvalue,&startsecond);
    cpuGetIndexAt(float2 (maxrightvalue.x,maxrightvalue.y - 1),-maxshiftright,maxrightvalue,&endsecond);
    combinefloat2(outleft_stream,outright_stream,output_stream,startsecond,endsecond,maxrightvalue,1.000000f / (float ) (floor(0.500000f)));
    streamSwap(*output,output_stream);
  }

  return totalsize;
}

unsigned int  totalCombineVoutfloat2(::brook::stream list_stream, unsigned int  WIDTH, ::brook::stream list2_stream, unsigned int  WIDTH2, unsigned int  LENGTH, ::brook::stream (*output))
{
  ::brook::stream outleft_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream outright_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH2 , LENGTH,-1);
  float  maxshiftleft = shiftValuesfloat2(list_stream,&outleft_stream,WIDTH,LENGTH,-1);
  float  maxshiftright = shiftValuesfloat2(list2_stream,&outright_stream,WIDTH2,LENGTH,-1);

  return voutCombinefloat2(outleft_stream,maxshiftleft,WIDTH,outright_stream,maxshiftright,WIDTH2,LENGTH,output);
}

#undef VECTOR_TEMPLATIZED_FUNCTIONS

#define VECTOR_TEMPLATIZED_FUNCTIONS


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r9.xyz, -r0.w, r7, r0\n"
				"    mov r9.w, c0.x\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r9.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r9.x\n"
				"    add r4.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r4.w, -r2.w, r2.w\n"
				"    cmp r11.xyz, -r2.w, r2, r9\n"
				"    mov r11.w, c0.x\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r4.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r4.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r11.xyz, -r2.w, r2, r4\n"
				"    rcp r9.w, r11.x\n"
				"    add r6.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r6.w, -r9.w, r9.w\n"
				"    cmp r1.xyz, -r9.w, r9, r11\n"
				"    mov r1.w, c0.x\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r11.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r11.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r6.xyz, -r2.w, r2, r11\n"
				"    rcp r9.w, r6.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r1.xyz, -r9.w, r9, r6\n"
				"    rcp r4.w, r1.x\n"
				"    add r8.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r8.w, -r4.w, r4.w\n"
				"    cmp r3.xyz, -r4.w, r4, r1\n"
				"    mov r3.w, c0.x\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r6.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r6.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r1.xyz, -r2.w, r2, r6\n"
				"    rcp r9.w, r1.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r8.xyz, -r9.w, r9, r1\n"
				"    rcp r4.w, r8.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r3.xyz, -r4.w, r4, r8\n"
				"    rcp r11.w, r3.x\n"
				"    add r10.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r10.w, -r11.w, r11.w\n"
				"    cmp r5.xyz, -r11.w, r11, r3\n"
				"    mov r5.w, c0.x\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r1.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r1.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r8.xyz, -r2.w, r2, r1\n"
				"    rcp r9.w, r8.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r3.xyz, -r9.w, r9, r8\n"
				"    rcp r4.w, r3.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r10.xyz, -r4.w, r4, r3\n"
				"    rcp r11.w, r10.x\n"
				"    add r6.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r6.w, -r11.w, r11.w\n"
				"    cmp r5.xyz, -r11.w, r11, r10\n"
				"    rcp r6.w, r5.x\n"
				"    add r0.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r0.w, -r6.w, r6.w\n"
				"    cmp r7.xyz, -r6.w, r6, r5\n"
				"    mov r7.w, c0.x\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl t7.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s0\n"
				"    texld r1, t7, s1\n"
				"    rcp r0.w, r0.x\n"
				"    add r2.w, -r0.w, -r0.w\n"
				"    cmp r0.w, r2.w, -r0.w, r0.w\n"
				"    cmp r8.xyz, -r0.w, r7, r0\n"
				"    rcp r2.w, r8.x\n"
				"    add r9.w, -r2.w, -r2.w\n"
				"    cmp r2.w, r9.w, -r2.w, r2.w\n"
				"    cmp r3.xyz, -r2.w, r2, r8\n"
				"    rcp r9.w, r3.x\n"
				"    add r4.w, -r9.w, -r9.w\n"
				"    cmp r9.w, r4.w, -r9.w, r9.w\n"
				"    cmp r10.xyz, -r9.w, r9, r3\n"
				"    rcp r4.w, r10.x\n"
				"    add r11.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r11.w, -r4.w, r4.w\n"
				"    cmp r5.xyz, -r4.w, r4, r10\n"
				"    rcp r11.w, r5.x\n"
				"    add r6.w, -r11.w, -r11.w\n"
				"    cmp r11.w, r6.w, -r11.w, r11.w\n"
				"    cmp r0.xyz, -r11.w, r11, r5\n"
				"    rcp r6.w, r0.x\n"
				"    add r1.w, -r6.w, -r6.w\n"
				"    cmp r6.w, r1.w, -r6.w, r6.w\n"
				"    cmp r7.xyz, -r6.w, r6, r0\n"
				"    rcp r1.w, r7.x\n"
				"    add r2.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r2.w, -r1.w, r1.w\n"
				"    cmp r8.xyz, -r1.w, r1, r7\n"
				"    mov r8.w, c0.x\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:input\n"
				"//s:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat3_ps20 = &__valueProducedfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 5 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX1, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVR o[COLR].xyz, R0.xyzx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 6 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 7 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX3].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 8 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX4].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 9 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX5].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 10 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX6].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex___reduce7_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD7 : TEX7 : 10 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1.xyz, f[TEX6].xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, f[TEX7].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R1.xyzx;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R0.w, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R0.w;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat3_fp30 = &__valueProducedfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r2;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r9.xyz, -r0.w, r0, r7;\n"
				"MOV r9.w, c0.x;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r9.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r9.x;\n"
				"ADD r4.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r4.w, r2.w, -r2.w;\n"
				"CMP r11.xyz, -r2.w, r9, r2;\n"
				"MOV r11.w, c0.x;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r4.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r4.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r11.xyz, -r2.w, r4, r2;\n"
				"RCP r9.w, r11.x;\n"
				"ADD r6.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r6.w, r9.w, -r9.w;\n"
				"CMP r1.xyz, -r9.w, r11, r9;\n"
				"MOV r1.w, c0.x;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r11.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r11.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r6.xyz, -r2.w, r11, r2;\n"
				"RCP r9.w, r6.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r1.xyz, -r9.w, r6, r9;\n"
				"RCP r4.w, r1.x;\n"
				"ADD r8.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r8.w, r4.w, -r4.w;\n"
				"CMP r3.xyz, -r4.w, r1, r4;\n"
				"MOV r3.w, c0.x;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r6.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r6.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r1.xyz, -r2.w, r6, r2;\n"
				"RCP r9.w, r1.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r8.xyz, -r9.w, r1, r9;\n"
				"RCP r4.w, r8.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r3.xyz, -r4.w, r8, r4;\n"
				"RCP r11.w, r3.x;\n"
				"ADD r10.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r10.w, r11.w, -r11.w;\n"
				"CMP r5.xyz, -r11.w, r3, r11;\n"
				"MOV r5.w, c0.x;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r1.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r1.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r8.xyz, -r2.w, r1, r2;\n"
				"RCP r9.w, r8.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r3.xyz, -r9.w, r8, r9;\n"
				"RCP r4.w, r3.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r10.xyz, -r4.w, r3, r4;\n"
				"RCP r11.w, r10.x;\n"
				"ADD r6.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r6.w, r11.w, -r11.w;\n"
				"CMP r5.xyz, -r11.w, r10, r11;\n"
				"RCP r6.w, r5.x;\n"
				"ADD r0.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r0.w, r6.w, -r6.w;\n"
				"CMP r7.xyz, -r6.w, r5, r6;\n"
				"MOV r7.w, c0.x;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"ATTRIB t7 = fragment.texcoord[7];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[0], RECT;\n"
				"TEX r1, t7, texture[1], RECT;\n"
				"RCP r0.w, r0.x;\n"
				"ADD r2.w, -r0.w, -r0.w;\n"
				"CMP r0.w, r2.w, r0.w, -r0.w;\n"
				"CMP r8.xyz, -r0.w, r0, r7;\n"
				"RCP r2.w, r8.x;\n"
				"ADD r9.w, -r2.w, -r2.w;\n"
				"CMP r2.w, r9.w, r2.w, -r2.w;\n"
				"CMP r3.xyz, -r2.w, r8, r2;\n"
				"RCP r9.w, r3.x;\n"
				"ADD r4.w, -r9.w, -r9.w;\n"
				"CMP r9.w, r4.w, r9.w, -r9.w;\n"
				"CMP r10.xyz, -r9.w, r3, r9;\n"
				"RCP r4.w, r10.x;\n"
				"ADD r11.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r11.w, r4.w, -r4.w;\n"
				"CMP r5.xyz, -r4.w, r10, r4;\n"
				"RCP r11.w, r5.x;\n"
				"ADD r6.w, -r11.w, -r11.w;\n"
				"CMP r11.w, r6.w, r11.w, -r11.w;\n"
				"CMP r0.xyz, -r11.w, r5, r11;\n"
				"RCP r6.w, r0.x;\n"
				"ADD r1.w, -r6.w, -r6.w;\n"
				"CMP r6.w, r1.w, r6.w, -r6.w;\n"
				"CMP r7.xyz, -r6.w, r0, r6;\n"
				"RCP r1.w, r7.x;\n"
				"ADD r2.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r2.w, r1.w, -r1.w;\n"
				"CMP r8.xyz, -r1.w, r7, r1;\n"
				"MOV r8.w, c0.x;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:input\n"
				"##s:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat3_arb = &__valueProducedfloat3_arb_desc;
}

void __valueProducedfloat3_cpu_inner (const __BrtFloat3  &input,
                                       __BrtFloat3  &output){
  output = __isinf_cpu_inner(input.swizzle1(maskX)).questioncolon(output,input);
}
void  __valueProducedfloat3__base_cpu_inner (const __BrtFloat3  &input,
                                             __BrtFloat3  &output) {
  output = input;
}
void  __valueProducedfloat3__combine_cpu_inner (const __BrtFloat3  &input,
                                                __BrtFloat3  &output,
                                                __BrtFloat3  &__combiner) {
  __valueProducedfloat3_cpu_inner (__combiner, output);
}
void  __valueProducedfloat3_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat3 *arg1 = (__BrtFloat3 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int i=0; 
  if (mapextent) {
    __valueProducedfloat3__base_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
  while (i<mapextent) {
    __valueProducedfloat3_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
}
void  __valueProducedfloat3_ndcpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   const unsigned int *mapbegin, 
                                   const unsigned int *mapextents) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat3 *arg1 = (__BrtFloat3 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=mapextents[dim-1];
  unsigned int mapextent = mapextents[0], i=1;
  for (;i<dim;++i) mapextent*=mapextents[i];

  unsigned int iter0 = getIndexOf(0, mapbegin, mapextents, extents[0], dim, extents[0]);
  i=0; 
  if (mapextent) {
    __valueProducedfloat3__base_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
  while (i<mapextent) {
    __valueProducedfloat3_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
}
void  __valueProducedfloat3__combine_cpu (const std::vector<void *>&args,
                                          const std::vector<const unsigned int *>&extents,
                                          const std::vector<unsigned int>&dims,
                                          unsigned int mapbegin) {
    __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat3 *arg1 = (__BrtFloat3 *)args[1];
  __BrtFloat3 *arg2 = (__BrtFloat3 *)args[2];
    arg0+=mapbegin;
    __valueProducedfloat3__combine_cpu_inner (
      *arg0,
      *arg1,
      *arg2);
}

class __valueProducedfloat3_scatterclass{ public:
  void operator () (__BrtFloat3  &output, 
                    const __BrtFloat3  &input) const {
    __valueProducedfloat3_cpu_inner (input, output);
  }
}__valueProducedfloat3_scatter;
void  valueProducedfloat3 (::brook::stream input,
		::brook::stream output) {
  static const void *__valueProducedfloat3_fp[] = {
     "fp30", __valueProducedfloat3_fp30,
     "arb", __valueProducedfloat3_arb,
     "ps20", __valueProducedfloat3_ps20,
     "cpu", (void *) __valueProducedfloat3_cpu,
     "ndcpu", (void *) __valueProducedfloat3_ndcpu,
     "combine", (void *) __valueProducedfloat3__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat3_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}

void  valueProducedfloat3 (::brook::stream input,
		float3  & output) {
  static const void *__valueProducedfloat3_fp[] = {
     "fp30", __valueProducedfloat3_fp30,
     "arb", __valueProducedfloat3_arb,
     "ps20", __valueProducedfloat3_ps20,
     "cpu", (void *) __valueProducedfloat3_cpu,
     "ndcpu", (void *) __valueProducedfloat3_ndcpu,
     "combine", (void *) __valueProducedfloat3__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat3_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    texld r0, t0, s0\n"
				"    rcp r7.w, r0.x\n"
				"    max r4.w, -r7.w, r7.w\n"
				"    cmp_pp r6.x, -r4.w, c0.x, c0.w\n"
				"    mov r6.yzw, c0.x\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:3:inp\n"
				"//o:1:outp\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat3_ps20 = &__isFiniteKernelfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_inp : TEXUNIT0\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_inp : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __workspace : C0 :  : 3 : 1\n"
				"#var float2 _tex_inp_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVX o[COLR].x, H0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat3_fp30 = &__isFiniteKernelfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r4.w, -r7.w, r7.w;\n"
				"CMP r6.x, -r4.w, c0.w, c0.x;\n"
				"MOV r6.yzw, c0.x;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:3:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat3_arb = &__isFiniteKernelfloat3_arb_desc;
}

void __isFiniteKernelfloat3_cpu_inner (const __BrtFloat3  &inp,
                                        __BrtFloat1  &outp){
  outp = !__isinf_cpu_inner(inp.swizzle1(maskX));
}
void  __isFiniteKernelfloat3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  unsigned int ratio0 = extents[1][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[1][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[1]);
  arg1+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __isFiniteKernelfloat3_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    ++arg1;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[1]);
    }
  }
}

void  isFiniteKernelfloat3 (::brook::stream inp,
		::brook::stream outp) {
  static const void *__isFiniteKernelfloat3_fp[] = {
     "fp30", __isFiniteKernelfloat3_fp30,
     "arb", __isFiniteKernelfloat3_arb,
     "ps20", __isFiniteKernelfloat3_ps20,
     "cpu", (void *) __isFiniteKernelfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__isFiniteKernelfloat3_fp);

  k->PushStream(inp);
  k->PushOutput(outp);
  k->Map();

}


int  finiteValueProducedfloat3(::brook::stream input)
{
   static ::brook::stream output(::brook::getStreamType(( float3  *)0), 1 , 1,-1);
   static ::brook::stream finiteout(::brook::getStreamType(( float  *)0), 1 , 1,-1);
  float3  rettype;
  float  ret;

  debugStreamPrint(input,"Finite Values in...");
  valueProducedfloat3(input,output);
  streamWrite(output,&rettype);
  isFiniteKernelfloat3(output,finiteout);
  streamWrite(finiteout,&ret);
  return (int ) (ret);
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0.1, 0, 0\n"
				"    dcl_2d s0\n"
				"    mov r1.xy, c1\n"
				"    mad r7.x, c0.x, r1.x, c0.z\n"
				"    mad r7.y, c0.y, r1.y, c0.w\n"
				"    texld r2, r7, s0\n"
				"    mov r2.w, -c2.y\n"
				"    add r2.w, r2.w, c1.y\n"
				"    cmp_pp r2.w, r2.w, c4.x, c4.w\n"
				"    mov r1.w, c1.y\n"
				"    add r9.w, c4.y, r1.w\n"
				"    cmp_pp r4.w, r9.w, c4.w, c4.x\n"
				"    add_pp r2.w, r2.w, r4.w\n"
				"    cmp r11.xyz, -r2.w, r2, c3.x\n"
				"    mov r11.w, c4.w\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//c:3:value\n"
				"//c:2:index\n"
				"//o:3:output\n"
				"//c:2:maxvalue\n"
				"//c:1:nothing\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat3_ps20 = &__valueAtfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main.index : C1\n"
				"#semantic main.maxvalue : C2\n"
				"#semantic main.nothing : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float2 index : C1 :  : 2 : 1\n"
				"#var float2 maxvalue : C2 :  : 4 : 1\n"
				"#var float nothing : C3 :  : 5 : 1\n"
				"#var float4 __workspace : C4 :  : 6 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE index;\n"
				"DECLARE maxvalue;\n"
				"DECLARE nothing;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, index.xyxx, TEX0, RECT;\n"
				"MOVR R1.y, maxvalue.y;\n"
				"SGER H0.x, index.y, R1.y;\n"
				"MOVR R1.x, {-0.1}.x;\n"
				"SLTR H0.y, index.y, R1.x;\n"
				"ADDX H0.y, H0.x, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MOVR o[COLR].xyz, nothing.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:3:value\n"
				"##c:2:index\n"
				"##o:3:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat3_fp30 = &__valueAtfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0.1, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"MOV r1.xy, c1;\n"
				"MAD r7.x, c0.x, r1.x, c0.z;\n"
				"MAD r7.y, c0.y, r1.y, c0.w;\n"
				"TEX r2, r7, texture[0], RECT;\n"
				"MOV r2.w, -c2.y;\n"
				"ADD r2.w, r2.w, c1.y;\n"
				"CMP r2.w, r2.w, c4.w, c4.x;\n"
				"MOV r1.w, c1.y;\n"
				"ADD r9.w, c4.y, r1.w;\n"
				"CMP r4.w, r9.w, c4.x, c4.w;\n"
				"ADD r2.w, r2.w, r4.w;\n"
				"CMP r11.xyz, -r2.w, c3.x, r2;\n"
				"MOV r11.w, c4.w;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:3:value\n"
				"##c:2:index\n"
				"##o:3:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat3_arb = &__valueAtfloat3_arb_desc;
}

void __valueAtfloat3_cpu_inner (const __BrtArray2d<__BrtFloat3  > &value,
                                 const __BrtFloat2  &index,
                                 __BrtFloat3  &output,
                                 const __BrtFloat2  &maxvalue,
                                 const __BrtFloat1  &nothing){
  if (index.swizzle1(maskY) >= maxvalue.swizzle1(maskY) || index.swizzle1(maskY) < -__BrtFloat1(0.100000f))
    output = nothing;
  else
    output = value[index];
}
void  __valueAtfloat3_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat3 *arg2 = (__BrtFloat3 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __valueAtfloat3_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4);
    i++;
    ++arg2;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  valueAtfloat3 (::brook::stream value,
		const float2  index,
		::brook::stream output,
		const float2  maxvalue,
		const float  nothing) {
  static const void *__valueAtfloat3_fp[] = {
     "fp30", __valueAtfloat3_fp30,
     "arb", __valueAtfloat3_arb,
     "ps20", __valueAtfloat3_ps20,
     "cpu", (void *) __valueAtfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueAtfloat3_fp);

  k->PushGatherStream(value);
  k->PushConstant(index);
  k->PushOutput(output);
  k->PushConstant(maxvalue);
  k->PushConstant(nothing);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 0.5, 0.25, 0, -0.5\n"
				"    def c5, 1, 0, 0, 0.1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c4.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c4.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c4.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c4.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c4.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c5.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, r3.w, c5.x, r2.w\n"
				"    mov r2.w, c5.x\n"
				"    cmp_pp r9.w, r9.w, c4.z, r2.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c4.z\n"
				"    rcp r4.w, r4.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, -r4.w, c5.x, r2.w\n"
				"    rcp r1.w, r4.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp_pp r0.w, -r10.w, c5.x, r2.w\n"
				"    add_pp r2.x, r4.w, r0.w\n"
				"    mov r2.yzw, c4.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:3:value\n"
				"//oi:1:output\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat3_ps20 = &__NanToBoolRightfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.sign : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float sign : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, sign.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.y, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.y, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.xyzx;\n"
				"SNER H0.y, R2.x, {0}.x;\n"
				"MULR R1.x, R2.x, {2}.x;\n"
				"SEQR H0.z, R2.x, R1.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.z, R0.x, R1.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {1}.x;\n"
				"ADDR o[COLR].x, R0.x, R0.y;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:3:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat3_fp30 = &__NanToBoolRightfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {0.5, 0.25, 0, -0.5};\n"
				"PARAM c5 = {1, 0, 0, 0.1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c4.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c4.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c4.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c4.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c4.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c5.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, r3.w, r2.w, c5.x;\n"
				"MOV r2.w, c5.x;\n"
				"CMP r9.w, r9.w, r2.w, c4.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c4.z, r9.x;\n"
				"RCP r4.w, r4.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, -r4.w, r2.w, c5.x;\n"
				"RCP r1.w, r4.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r0.w, -r10.w, r2.w, c5.x;\n"
				"ADD r2.x, r4.w, r0.w;\n"
				"MOV r2.yzw, c4.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:3:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat3_arb = &__NanToBoolRightfloat3_arb_desc;
}

void __NanToBoolRightfloat3_cpu_inner (const __BrtArray2d<__BrtFloat3  > &value,
                                        __BrtFloat1  &output,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat3  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,sign,maxvalue,nextPlaceToLook);
  __valueAtfloat3_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = (__isinf_cpu_inner(value[__indexof_output].swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0))) + (__isinf_cpu_inner(neighbor.swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0)));
}
void  __NanToBoolRightfloat3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToBoolRightfloat3_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToBoolRightfloat3 (::brook::stream value,
		::brook::stream output,
		const float  sign,
		const float2  maxvalue) {
  static const void *__NanToBoolRightfloat3_fp[] = {
     "fp30", __NanToBoolRightfloat3_fp30,
     "arb", __NanToBoolRightfloat3_arb,
     "ps20", __NanToBoolRightfloat3_ps20,
     "cpu", (void *) __NanToBoolRightfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToBoolRightfloat3_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r4.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r9.w, r9.w, c5.z, r0.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c5.z\n"
				"    add r11.w, r4.x, r4.w\n"
				"    add r6.w, r11.w, c5.x\n"
				"    frc r1.w, r6.w\n"
				"    add r7.x, r6.w, -r1.w\n"
				"    mov r7.yzw, c5.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat3_ps20 = &__NanToRightfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R2.x, R0.x, R2.x;\n"
				"ADDR R2.x, R2.x, {0.5}.x;\n"
				"FLRR o[COLR].x, R2.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat3_fp30 = &__NanToRightfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r4.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r9.w, r9.w, r0.w, c5.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c5.z, r9.x;\n"
				"ADD r11.w, r4.x, r4.w;\n"
				"ADD r6.w, r11.w, c5.x;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r7.x, r6.w, -r1.w;\n"
				"MOV r7.yzw, c5.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat3_arb = &__NanToRightfloat3_arb_desc;
}

void __NanToRightfloat3_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                    __BrtFloat1  &output,
                                    const __BrtFloat1  &twotoi,
                                    const __BrtFloat2  &maxvalue,
                                    const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = __round_cpu_inner(value[__indexof_output] + neighbor);
}
void  __NanToRightfloat3_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToRightfloat3_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToRightfloat3 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__NanToRightfloat3_fp[] = {
     "fp30", __NanToRightfloat3_fp30,
     "arb", __NanToRightfloat3_arb,
     "ps20", __NanToRightfloat3_ps20,
     "cpu", (void *) __NanToRightfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToRightfloat3_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r9.w, r3.y, -c3.y\n"
				"    add r4.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r9.w, r9.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r4.w, r4.w, c5.z, r0.w\n"
				"    add_pp r9.w, r9.w, r4.w\n"
				"    cmp r11.xyz, -r9.w, r9, c5.z\n"
				"    add r6.xyz, r4, r11\n"
				"    mov r6.w, c5.z\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:3:value\n"
				"//oi:3:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat3_ps20 = &__CountToRightfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.xyz, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.xyz, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.xyz(GT.x), R1.xyzx;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R2.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:3:value\n"
				"##oi:3:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat3_fp30 = &__CountToRightfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r9.w, r3.y, -c3.y;\n"
				"ADD r4.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r9.w, r9.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r4.w, r4.w, r0.w, c5.z;\n"
				"ADD r9.w, r9.w, r4.w;\n"
				"CMP r11.xyz, -r9.w, c5.z, r9;\n"
				"ADD r6.xyz, r4, r11;\n"
				"MOV r6.w, c5.z;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:3:value\n"
				"##oi:3:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat3_arb = &__CountToRightfloat3_arb_desc;
}

void __CountToRightfloat3_cpu_inner (const __BrtArray2d<__BrtFloat3  > &value,
                                      __BrtFloat3  &output,
                                      const __BrtFloat1  &twotoi,
                                      const __BrtFloat2  &maxvalue,
                                      const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat3  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat3_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = value[__indexof_output] + neighbor;
}
void  __CountToRightfloat3_cpu (const std::vector<void *>&args,
                                const std::vector<const unsigned int *>&extents,
                                const std::vector<unsigned int>&dims,
                                unsigned int mapbegin, 
                                unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtFloat3 *arg1 = (__BrtFloat3 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __CountToRightfloat3_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  CountToRightfloat3 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__CountToRightfloat3_fp[] = {
     "fp30", __CountToRightfloat3_fp30,
     "arb", __CountToRightfloat3_arb,
     "ps20", __CountToRightfloat3_ps20,
     "cpu", (void *) __CountToRightfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__CountToRightfloat3_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r3.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r3.w\n"
				"    mad r5.x, r3.x, c2.x, c2.z\n"
				"    mad r5.y, r3.y, c2.y, c2.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    texld r2, r5, s1\n"
				"    texld r9, r0, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r2.w, r3.y, c7.w\n"
				"    mov r0.w, c8.z\n"
				"    cmp_pp r9.w, r3.w, c7.x, r0.w\n"
				"    mov r0.w, c7.x\n"
				"    cmp_pp r2.w, r2.w, c8.z, r0.w\n"
				"    add_pp r2.w, r9.w, r2.w\n"
				"    cmp r4.w, -r2.w, r2.x, c8.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp_pp r10.w, -r8.w, c8.z, r0.w\n"
				"    cmp r5.w, -r2.w, r9.x, c8.z\n"
				"    add r3.w, r5.w, -c5.x\n"
				"    mov r2.w, -r5.w\n"
				"    abs r4.w, r3.w\n"
				"    mov r11.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r11.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r10.w, r6.w\n"
				"    mov r7.w, -c3.x\n"
				"    add r10.w, r7.w, c5.x\n"
				"    cmp r5.w, -r1.w, r10.w, c5.x\n"
				"    add r0.w, r2.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r3.w, c3.x, r4.w\n"
				"    cmp r2.x, r0.w, r5.w, r3.w\n"
				"    mov r2.yzw, c8.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:3:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat3_ps20 = &__GatherGuessfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.x, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.x, R2.x, halfk.x;\n"
				"SEQR H0.z, R2.x, halfk.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R0.x, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), R1.xyzx;\n"
				"SNER H0.y, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR o[COLR].x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), halfk.x;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, -R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat3_fp30 = &__GatherGuessfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r3.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r3.w;\n"
				"MAD r5.x, r3.x, c2.x, c2.z;\n"
				"MAD r5.y, r3.y, c2.y, c2.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"TEX r2, r5, texture[1], RECT;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r2.w, r3.y, c7.w;\n"
				"MOV r0.w, c8.z;\n"
				"CMP r9.w, r3.w, r0.w, c7.x;\n"
				"MOV r0.w, c7.x;\n"
				"CMP r2.w, r2.w, r0.w, c8.z;\n"
				"ADD r2.w, r9.w, r2.w;\n"
				"CMP r4.w, -r2.w, c8.z, r2.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r10.w, -r8.w, r0.w, c8.z;\n"
				"CMP r5.w, -r2.w, c8.z, r9.x;\n"
				"ADD r3.w, r5.w, -c5.x;\n"
				"MOV r2.w, -r5.w;\n"
				"ABS r4.w, r3.w;\n"
				"MOV r11.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r11.w, r4.w, c7.x;\n"
				"MUL r1.w, r10.w, r6.w;\n"
				"MOV r7.w, -c3.x;\n"
				"ADD r10.w, r7.w, c5.x;\n"
				"CMP r5.w, -r1.w, c5.x, r10.w;\n"
				"ADD r0.w, r2.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r3.w, c3.x, r4.w;\n"
				"CMP r2.x, r0.w, r3.w, r5.w;\n"
				"MOV r2.yzw, c8.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat3_arb = &__GatherGuessfloat3_arb_desc;
}

void __GatherGuessfloat3_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat3  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &halfk,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __BrtFloat1  neighbor;
  __BrtFloat2  nextPlaceToLook;

  __getIndexAt_cpu_inner(__indexof_output,-sign * halfk,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(scatterindex,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  if (neighbor > halfk)
  {
    output = halfk + twotologkminusi;
  }

  else
  {
    __BrtFloat3  actualValue;

    __valueAtfloat3_cpu_inner(value,nextPlaceToLook,actualValue,maxvalue,__BrtFloat1((float)0));
    if (neighbor == halfk && !__isinf_cpu_inner(actualValue.swizzle1(maskX)))
    {
      output = halfk;
    }

    else
    {
      output = halfk - twotologkminusi;
    }

  }

}
void  __GatherGuessfloat3_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __GatherGuessfloat3_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  GatherGuessfloat3 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__GatherGuessfloat3_fp[] = {
     "fp30", __GatherGuessfloat3_fp30,
     "arb", __GatherGuessfloat3_arb,
     "ps20", __GatherGuessfloat3_ps20,
     "cpu", (void *) __GatherGuessfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__GatherGuessfloat3_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r2.x, r3.x, c2.x, c2.z\n"
				"    mad r2.y, r3.y, c2.y, c2.w\n"
				"    mad r9.x, r3.x, c0.x, c0.z\n"
				"    mad r9.y, r3.y, c0.y, c0.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    texld r11, r2, s1\n"
				"    texld r6, r9, s0\n"
				"    texld r1, r4, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r11.w, r3.y, c7.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r3.w, c7.x, r4.w\n"
				"    mov r4.w, c7.x\n"
				"    cmp_pp r11.w, r11.w, c8.z, r4.w\n"
				"    add_pp r11.w, r6.w, r11.w\n"
				"    cmp r1.w, -r11.w, r11.x, c8.z\n"
				"    rcp r1.w, r1.w\n"
				"    add r7.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r7.w, -r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.z, r4.w\n"
				"    cmp r10.w, -r11.w, r6.x, c8.z\n"
				"    add r0.w, r10.w, -c5.x\n"
				"    abs r4.w, r0.w\n"
				"    mov r3.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r11.w, r3.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r1.w, r11.w\n"
				"    mov r6.w, -c3.x\n"
				"    add r8.w, r6.w, c5.x\n"
				"    cmp r1.w, -r1.w, r8.w, c5.x\n"
				"    add r7.w, -r10.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r10.w, c3.x, r4.w\n"
				"    cmp r1.w, r7.w, r1.w, r10.w\n"
				"    abs r0.w, r1.x\n"
				"    cmp r9.x, -r0.w, c8.z, r1.w\n"
				"    mov r9.yzw, c8.z\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:3:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat3_ps20 = &__EstablishGuessfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SEQR H0.x, R0.x, {0}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H1.x, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H1.y, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H1.y, R0.x, {-0.5}.x;\n"
				"MULX H1.y, H0.y, H1.y;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"SLTR H0.z, R2.y, {-0.1}.x;\n"
				"SGER H0.w, R2.y, maxvalue.y;\n"
				"ADDX H0.z, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.y, R2.x, halfk.x;\n"
				"SEQR H0.w, R2.x, halfk.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H1.x, H0.y;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R1.xyzx;\n"
				"SNER H0.z, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.z, -H1.x, H0.z, {1}.x;\n"
				"MULX H1.x, H0.w, H0.z;\n"
				"MADX H0.z, -H0.w, H0.z, {1}.x;\n"
				"MULX H1.x, H0.y, H1.x;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R0.x(GT.x), halfk.x;\n"
				"MOVR R0.y, twotologkminusi.x;\n"
				"ADDR R0.y, halfk.x, -R0.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R0.y;\n"
				"MOVR o[COLR].x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat3_fp30 = &__EstablishGuessfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r2.x, r3.x, c2.x, c2.z;\n"
				"MAD r2.y, r3.y, c2.y, c2.w;\n"
				"MAD r9.x, r3.x, c0.x, c0.z;\n"
				"MAD r9.y, r3.y, c0.y, c0.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"TEX r11, r2, texture[1], RECT;\n"
				"TEX r6, r9, texture[0], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r11.w, r3.y, c7.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r3.w, r4.w, c7.x;\n"
				"MOV r4.w, c7.x;\n"
				"CMP r11.w, r11.w, r4.w, c8.z;\n"
				"ADD r11.w, r6.w, r11.w;\n"
				"CMP r1.w, -r11.w, c8.z, r11.x;\n"
				"RCP r1.w, r1.w;\n"
				"ADD r7.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r7.w, r1.w, -r1.w;\n"
				"CMP r1.w, -r1.w, r4.w, c8.z;\n"
				"CMP r10.w, -r11.w, c8.z, r6.x;\n"
				"ADD r0.w, r10.w, -c5.x;\n"
				"ABS r4.w, r0.w;\n"
				"MOV r3.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r11.w, r3.w, r4.w, c7.x;\n"
				"MUL r1.w, r1.w, r11.w;\n"
				"MOV r6.w, -c3.x;\n"
				"ADD r8.w, r6.w, c5.x;\n"
				"CMP r1.w, -r1.w, c5.x, r8.w;\n"
				"ADD r7.w, -r10.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r10.w, c3.x, r4.w;\n"
				"CMP r1.w, r7.w, r10.w, r1.w;\n"
				"ABS r0.w, r1.x;\n"
				"CMP r9.x, -r0.w, r1.w, c8.z;\n"
				"MOV r9.yzw, c8.z;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat3_arb = &__EstablishGuessfloat3_arb_desc;
}

void __EstablishGuessfloat3_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                        __BrtFloat1  &output,
                                        const __BrtArray2d<__BrtFloat3  > &value,
                                        const __BrtFloat1  &twotologkminusi,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &halfk,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat4 &__indexof_output){
  if (scatterindex[__indexof_output] == __BrtFloat1((float)0))
  {
    output = __BrtFloat1((float)0);
  }

  else
  {
    __GatherGuessfloat3_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,halfk,sign,__indexof_output);
  }

}
void  __EstablishGuessfloat3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __EstablishGuessfloat3_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  EstablishGuessfloat3 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__EstablishGuessfloat3_fp[] = {
     "fp30", __EstablishGuessfloat3_fp30,
     "arb", __EstablishGuessfloat3_arb,
     "ps20", __EstablishGuessfloat3_ps20,
     "cpu", (void *) __EstablishGuessfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__EstablishGuessfloat3_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 1, 0, 0, 0.1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    texld r0, t1, s2\n"
				"    mad r2.x, t0.x, c1.x, c1.z\n"
				"    mad r2.y, t0.y, c1.y, c1.w\n"
				"    mad r2.w, r0.x, -c5.x, r2.x\n"
				"    add r2.w, r2.w, c7.x\n"
				"    frc r0.w, r2.w\n"
				"    add r0.w, r2.w, -r0.w\n"
				"    rcp r9.w, c4.x\n"
				"    mul r0.w, r0.w, r9.w\n"
				"    mul r2.w, r2.w, r9.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    add r0.w, r0.w, c7.x\n"
				"    frc r4.w, r0.w\n"
				"    add r0.w, r0.w, -r4.w\n"
				"    add r1.w, -r0.w, c7.w\n"
				"    add r8.w, r0.w, c4.x\n"
				"    cmp r0.w, r1.w, r8.w, r0.w\n"
				"    add r3.w, r0.w, c7.y\n"
				"    add r5.w, r3.w, -c4.x\n"
				"    cmp r7.x, r5.w, c7.z, r0.w\n"
				"    frc r7.w, r2.w\n"
				"    add r7.w, r2.w, -r7.w\n"
				"    add r7.y, r2.y, r7.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    mad r11.x, r7.x, c2.x, c2.z\n"
				"    mad r11.y, r7.y, c2.y, c2.w\n"
				"    texld r6, r4, s0\n"
				"    texld r1, r11, s1\n"
				"    add r7.w, r7.y, -c4.y\n"
				"    add r6.w, r7.y, c6.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r1.w, r7.w, c6.x, r11.w\n"
				"    mov r11.w, c6.x\n"
				"    cmp_pp r6.w, r6.w, c7.z, r11.w\n"
				"    add_pp r6.w, r1.w, r6.w\n"
				"    cmp r0.w, -r6.w, r6.x, c7.z\n"
				"    add r3.w, r0.w, -r0.x\n"
				"    abs r5.w, r3.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r2.w, -r5.w, c6.x, r11.w\n"
				"    cmp r4.w, -r6.w, r1.x, c7.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r1.w, -r11.w, r11.w\n"
				"    mov r8.w, -r1.w\n"
				"    mov r1.w, c6.x\n"
				"    cmp_pp r3.w, r8.w, c7.z, r1.w\n"
				"    mul_pp r10.w, r2.w, r3.w\n"
				"    add r2.w, r0.x, -c3.x\n"
				"    cmp r4.w, -r10.w, r2.w, r0.x\n"
				"    add r0.w, r0.x, -r0.w\n"
				"    add r11.w, r0.x, c3.x\n"
				"    cmp r7.x, r0.w, r4.w, r11.w\n"
				"    mov r7.yzw, c7.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:3:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//s:1:lastguess\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat3_ps20 = &__UpdateGuessfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main._tex_lastguess : TEXUNIT2\n"
				"#semantic main.sign : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var samplerRECT _tex_lastguess : TEXUNIT2 : texunit 2 : 9 : 1\n"
				"#var float sign : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"#var float2 _tex_lastguess_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"MADR R1.w, -sign.x, R0.x, R1.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxvalue.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R3.y, {-0.1}.x;\n"
				"SGER H0.y, R3.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R3.y, {-0.1}.x;\n"
				"SGER H0.z, R3.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.x, R3.xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, R3.xyxx, TEX1, RECT;\n"
				"MOVR R3.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"SGTR H0.x, R3.x, R0.x;\n"
				"SEQR H0.z, R3.x, R0.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), R2.xyzx;\n"
				"SNER H0.y, R1.x, {0}.x;\n"
				"MULR R1.y, R1.x, {2}.x;\n"
				"SEQR H1.x, R1.x, R1.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"ADDR o[COLR].x, R0.x, twotologkminusi.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"ADDR R0.x, R0.x, -twotologkminusi.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat3_fp30 = &__UpdateGuessfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {1, 0, 0, 0.1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[2], RECT;\n"
				"MAD r2.x, t0.x, c1.x, c1.z;\n"
				"MAD r2.y, t0.y, c1.y, c1.w;\n"
				"MAD r2.w, r0.x, -c5.x, r2.x;\n"
				"ADD r2.w, r2.w, c7.x;\n"
				"FRC r0.w, r2.w;\n"
				"ADD r0.w, r2.w, -r0.w;\n"
				"RCP r9.w, c4.x;\n"
				"MUL r0.w, r0.w, r9.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"ADD r0.w, r0.w, c7.x;\n"
				"FRC r4.w, r0.w;\n"
				"ADD r0.w, r0.w, -r4.w;\n"
				"ADD r1.w, -r0.w, c7.w;\n"
				"ADD r8.w, r0.w, c4.x;\n"
				"CMP r0.w, r1.w, r0.w, r8.w;\n"
				"ADD r3.w, r0.w, c7.y;\n"
				"ADD r5.w, r3.w, -c4.x;\n"
				"CMP r7.x, r5.w, r0.w, c7.z;\n"
				"FRC r7.w, r2.w;\n"
				"ADD r7.w, r2.w, -r7.w;\n"
				"ADD r7.y, r2.y, r7.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"MAD r11.x, r7.x, c2.x, c2.z;\n"
				"MAD r11.y, r7.y, c2.y, c2.w;\n"
				"TEX r6, r4, texture[0], RECT;\n"
				"TEX r1, r11, texture[1], RECT;\n"
				"ADD r7.w, r7.y, -c4.y;\n"
				"ADD r6.w, r7.y, c6.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r1.w, r7.w, r11.w, c6.x;\n"
				"MOV r11.w, c6.x;\n"
				"CMP r6.w, r6.w, r11.w, c7.z;\n"
				"ADD r6.w, r1.w, r6.w;\n"
				"CMP r0.w, -r6.w, c7.z, r6.x;\n"
				"ADD r3.w, r0.w, -r0.x;\n"
				"ABS r5.w, r3.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r2.w, -r5.w, r11.w, c6.x;\n"
				"CMP r4.w, -r6.w, c7.z, r1.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r1.w, -r11.w, r11.w;\n"
				"MOV r8.w, -r1.w;\n"
				"MOV r1.w, c6.x;\n"
				"CMP r3.w, r8.w, r1.w, c7.z;\n"
				"MUL r10.w, r2.w, r3.w;\n"
				"ADD r2.w, r0.x, -c3.x;\n"
				"CMP r4.w, -r10.w, r0.x, r2.w;\n"
				"ADD r0.w, r0.x, -r0.w;\n"
				"ADD r11.w, r0.x, c3.x;\n"
				"CMP r7.x, r0.w, r11.w, r4.w;\n"
				"MOV r7.yzw, c7.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:3:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat3_arb = &__UpdateGuessfloat3_arb_desc;
}

void __UpdateGuessfloat3_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat3  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &lastguess,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __GatherGuessfloat3_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,lastguess,sign,__indexof_output);
}
void  __UpdateGuessfloat3_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  unsigned int ratio5 = extents[1][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[1][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[1]);
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __UpdateGuessfloat3_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[1]);
    }
  }
}

void  UpdateGuessfloat3 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		::brook::stream lastguess,
		const float  sign) {
  static const void *__UpdateGuessfloat3_fp[] = {
     "fp30", __UpdateGuessfloat3_fp30,
     "arb", __UpdateGuessfloat3_arb,
     "ps20", __UpdateGuessfloat3_ps20,
     "cpu", (void *) __UpdateGuessfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__UpdateGuessfloat3_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushStream(lastguess);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.0625, 1.0625, 0, 1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    mad r7.x, t0.x, c0.x, c0.z\n"
				"    mad r7.y, t0.y, c0.y, c0.w\n"
				"    mad r9.x, r7.x, c1.x, c1.z\n"
				"    mad r9.y, r7.y, c1.y, c1.w\n"
				"    texld r4, r9, s0\n"
				"    mov r7.w, -c3.x\n"
				"    mad r6.w, r4.x, r7.w, r7.x\n"
				"    add r1.w, r6.w, c7.x\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    rcp r5.w, c4.x\n"
				"    mul r0.w, r10.w, r5.w\n"
				"    frc r2.w, r0.w\n"
				"    mul r9.w, r2.w, c4.x\n"
				"    add r4.w, r9.w, c7.x\n"
				"    frc r11.w, r4.w\n"
				"    add r8.w, r4.w, -r11.w\n"
				"    add r10.w, -r8.w, c7.w\n"
				"    add r0.w, r8.w, c4.x\n"
				"    cmp r2.w, r10.w, r0.w, r8.w\n"
				"    add r9.w, r2.w, c7.y\n"
				"    add r11.w, r9.w, -c4.x\n"
				"    cmp r1.x, r11.w, c7.z, r2.w\n"
				"    mul r1.w, r1.w, r5.w\n"
				"    frc r6.w, r1.w\n"
				"    add r1.w, r1.w, -r6.w\n"
				"    add r1.y, r7.y, r1.w\n"
				"    mad r5.x, r1.x, c2.x, c2.z\n"
				"    mad r5.y, r1.y, c2.y, c2.w\n"
				"    texld r3, r5, s1\n"
				"    texld r10, t1, s2\n"
				"    mad r3.w, r7.w, c5.x, r7.x\n"
				"    add r3.w, r3.w, c7.x\n"
				"    mul r7.w, r5.w, r3.w\n"
				"    frc r10.w, r7.w\n"
				"    add r7.w, r7.w, -r10.w\n"
				"    add r4.y, r7.y, r7.w\n"
				"    frc r10.w, r3.w\n"
				"    add r3.w, r3.w, -r10.w\n"
				"    mul r3.w, r3.w, r5.w\n"
				"    frc r3.w, r3.w\n"
				"    mul r3.w, r3.w, c4.x\n"
				"    add r3.w, r3.w, c7.x\n"
				"    frc r10.w, r3.w\n"
				"    add r3.w, r3.w, -r10.w\n"
				"    add r10.w, -r3.w, c7.w\n"
				"    add r0.w, r3.w, c4.x\n"
				"    cmp r3.w, r10.w, r0.w, r3.w\n"
				"    add r4.w, -c4.x, r3.w\n"
				"    add r4.w, r4.w, c7.y\n"
				"    cmp r4.x, r4.w, c7.z, r3.w\n"
				"    add r9.xy, r4, -c4\n"
				"    add r3.w, r9.y, c6.y\n"
				"    mov r0.w, c7.z\n"
				"    cmp_pp r3.w, r3.w, c6.w, r0.w\n"
				"    add r9.w, r9.x, c6.x\n"
				"    add r10.w, r9.y, c6.x\n"
				"    cmp_pp r11.w, r9.w, c6.w, r0.w\n"
				"    mul r3.w, r3.w, r11.w\n"
				"    cmp_pp r10.w, r10.w, c6.w, r0.w\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r6.xyz, -r3.w, r3, r10.x\n"
				"    mov r6.w, c7.z\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:output\n"
				"//c:1:gatherindex\n"
				"//c:3:value\n"
				"//s:1:inf\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//c:1:maxshift\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat3_ps20 = &__RelativeGatherfloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_output_invscalebias : C0\n"
				"#semantic main.gatherindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_gatherindex : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main._tex_inf : TEXUNIT2\n"
				"#semantic main.sign : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.maxshift : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var float4 _const_output_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT gatherindex[0] : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var float4 __gatherconst_gatherindex : C1 :  : 4 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var samplerRECT _tex_inf : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float sign : C3 :  : 9 : 1\n"
				"#var float2 maxvalue : C4 :  : 10 : 1\n"
				"#var float maxshift : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_inf_pos : $vin.TEXCOORD1 : TEX1 : 8 : 1\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_gatherindex;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE maxshift;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR o[COLR].xyz, R0.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, maxshift.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R1.x, R0.xyxx, TEX0, RECT;\n"
				"MADR R0.w, -sign.x, R1.x, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R3.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R3.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"ADDR R0.x, R3.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.y, R0.x, {0}.x;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"ADDR R0.z, R0.z, {0.5}.x;\n"
				"FLRR R0.z, R0.z;\n"
				"SLER H0.x, R0.z, {-0.5}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.y, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.z;\n"
				"ADDR R0.z, R0.z, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.z;\n"
				"ADDR R0.y, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.y, maxvalue.x;\n"
				"MOVR R3.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"ADDR R2.xy, R2.xyxx, -maxvalue.xyxx;\n"
				"SGER H0.x, R2.y, {-0.0625}.x;\n"
				"SGER H0.y, R2.x, {-0.0625}.x;\n"
				"SGER H0.z, R2.y, {-1.0625}.x;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R3.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"TEX R0.xyz, R3.xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:output\n"
				"##c:1:gatherindex\n"
				"##c:3:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat3_fp30 = &__RelativeGatherfloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.0625, 1.0625, 0, 1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, r7.x, c1.x, c1.z;\n"
				"MAD r9.y, r7.y, c1.y, c1.w;\n"
				"TEX r4, r9, texture[0], RECT;\n"
				"MOV r7.w, -c3.x;\n"
				"MAD r6.w, r4.x, r7.w, r7.x;\n"
				"ADD r1.w, r6.w, c7.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"RCP r5.w, c4.x;\n"
				"MUL r0.w, r10.w, r5.w;\n"
				"FRC r2.w, r0.w;\n"
				"MUL r9.w, r2.w, c4.x;\n"
				"ADD r4.w, r9.w, c7.x;\n"
				"FRC r11.w, r4.w;\n"
				"ADD r8.w, r4.w, -r11.w;\n"
				"ADD r10.w, -r8.w, c7.w;\n"
				"ADD r0.w, r8.w, c4.x;\n"
				"CMP r2.w, r10.w, r8.w, r0.w;\n"
				"ADD r9.w, r2.w, c7.y;\n"
				"ADD r11.w, r9.w, -c4.x;\n"
				"CMP r1.x, r11.w, r2.w, c7.z;\n"
				"MUL r1.w, r1.w, r5.w;\n"
				"FRC r6.w, r1.w;\n"
				"ADD r1.w, r1.w, -r6.w;\n"
				"ADD r1.y, r7.y, r1.w;\n"
				"MAD r5.x, r1.x, c2.x, c2.z;\n"
				"MAD r5.y, r1.y, c2.y, c2.w;\n"
				"TEX r3, r5, texture[1], RECT;\n"
				"TEX r10, t1, texture[2], RECT;\n"
				"MAD r3.w, r7.w, c5.x, r7.x;\n"
				"ADD r3.w, r3.w, c7.x;\n"
				"MUL r7.w, r5.w, r3.w;\n"
				"FRC r10.w, r7.w;\n"
				"ADD r7.w, r7.w, -r10.w;\n"
				"ADD r4.y, r7.y, r7.w;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r3.w, r3.w, -r10.w;\n"
				"MUL r3.w, r3.w, r5.w;\n"
				"FRC r3.w, r3.w;\n"
				"MUL r3.w, r3.w, c4.x;\n"
				"ADD r3.w, r3.w, c7.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r3.w, r3.w, -r10.w;\n"
				"ADD r10.w, -r3.w, c7.w;\n"
				"ADD r0.w, r3.w, c4.x;\n"
				"CMP r3.w, r10.w, r3.w, r0.w;\n"
				"ADD r4.w, -c4.x, r3.w;\n"
				"ADD r4.w, r4.w, c7.y;\n"
				"CMP r4.x, r4.w, r3.w, c7.z;\n"
				"ADD r9.xy, r4, -c4;\n"
				"ADD r3.w, r9.y, c6.y;\n"
				"MOV r0.w, c7.z;\n"
				"CMP r3.w, r3.w, r0.w, c6.w;\n"
				"ADD r9.w, r9.x, c6.x;\n"
				"ADD r10.w, r9.y, c6.x;\n"
				"CMP r11.w, r9.w, r0.w, c6.w;\n"
				"MUL r3.w, r3.w, r11.w;\n"
				"CMP r10.w, r10.w, r0.w, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r6.xyz, -r3.w, r10.x, r3;\n"
				"MOV r6.w, c7.z;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:output\n"
				"##c:1:gatherindex\n"
				"##c:3:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat3_arb = &__RelativeGatherfloat3_arb_desc;
}

void __RelativeGatherfloat3_cpu_inner (__BrtFloat3  &output,
                                        const __BrtArray2d<__BrtFloat1  > &gatherindex,
                                        const __BrtArray2d<__BrtFloat3  > &value,
                                        const __BrtFloat1  &inf,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &maxshift,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  isoffedge;

  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * gatherindex[__indexof_output],maxvalue,nextPlaceToLook);
  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * maxshift,maxvalue,isoffedge);
  isoffedge -= maxvalue;
  if (isoffedge.swizzle1(maskY) >= -__BrtFloat1(0.062500f) || isoffedge.swizzle1(maskY) >= -__BrtFloat1(1.062500f) && isoffedge.swizzle1(maskX) >= -__BrtFloat1(0.062500f))
  {
    output = inf;
  }

  else
  {
    output = value[nextPlaceToLook];
  }

}
void  __RelativeGatherfloat3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio3 = extents[0][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[0][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __RelativeGatherfloat3_cpu_inner (
      *arg0,
      arg1,
      arg2,
      *(arg3 + iter3),
      *arg4,
      *arg5,
      *arg6,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[0]);
    }
  }
}

void  RelativeGatherfloat3 (::brook::stream output,
		::brook::stream gatherindex,
		::brook::stream value,
		::brook::stream inf,
		const float  sign,
		const float2  maxvalue,
		const float  maxshift) {
  static const void *__RelativeGatherfloat3_fp[] = {
     "fp30", __RelativeGatherfloat3_fp30,
     "arb", __RelativeGatherfloat3_arb,
     "ps20", __RelativeGatherfloat3_ps20,
     "cpu", (void *) __RelativeGatherfloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__RelativeGatherfloat3_fp);

  k->PushOutput(output);
  k->PushGatherStream(gatherindex);
  k->PushGatherStream(value);
  k->PushStream(inf);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->PushConstant(maxshift);
  k->Map();

}


float  shiftValuesfloat3(::brook::stream list_stream, ::brook::stream (*output_stream), int  WIDTH, int  LENGTH, int  sign)
{
  ::brook::stream tmp_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream ret_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream guess_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  unsigned int  i;
  float2  maxvalue;
  unsigned int  logN;
  unsigned int  LogNMinusK;
  float  maxshift;

  maxvalue.x = (float ) (LENGTH);
  maxvalue.y = (float ) (WIDTH);
  logN = (unsigned int ) (ceil(log((float ) (LENGTH) * WIDTH) / log(2.000000f)));
  debugStreamPrint(list_stream,"Combined...");
  NanToBoolRightfloat3(list_stream,ret_stream,(float ) (sign),maxvalue);
  for (i = 1; i < logN; ++i)
  {
    streamSwap(ret_stream,tmp_stream);
    NanToRightfloat3(tmp_stream,ret_stream,(float ) (sign) * (1 << i),maxvalue);
  }

  debugStreamPrint(ret_stream,"scattering...");
  {
    static ::brook::stream item(::brook::getStreamType(( float  *)0), 1,-1);
    float2  index;

    if (sign == -1)
    {
      index.y = (float ) (WIDTH - 1);
      index.x = (float ) (LENGTH - 1);
    }

    else
    {
      index.y = index.x = 0;
    }

    kernelReadItem(ret_stream,index,item);
    streamWrite(item,&maxshift);
  }

  LogNMinusK = logN - 2;
  i = logN - 1;
  EstablishGuessfloat3(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,(float ) (1 << i),(float ) (sign));
  for (i = 1; i < logN; ++i)
  {
    LogNMinusK = logN - 1 - i;
    streamSwap(tmp_stream,guess_stream);
    UpdateGuessfloat3(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,tmp_stream,(float ) (sign));
  }

  debugStreamPrint(guess_stream,"Gather Value");
  if (1)
  {
    unsigned int  size;
    unsigned int  width;

    size = (unsigned int ) (LENGTH) * (unsigned int ) (WIDTH) - (unsigned int ) (maxshift);
    width = size / LENGTH + ((size % LENGTH) ? (1) : (0));
    if (1)
    {
      ::brook::stream proper_output_stream=quickAllocStream(::brook::getStreamType(( float3  *)0), width , LENGTH,-1);

      if (width)
      {
        RelativeGatherfloat3(proper_output_stream,guess_stream,list_stream,*sentinelStream(2),(float ) (sign),maxvalue,maxshift);
      }

      streamSwap(*output_stream,proper_output_stream);
    }

    debugStreamPrint(*output_stream,"Final Value");
  }

  return maxshift;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine1_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t1.x, c5.x, c5.z\n"
				"    mad r7.y, t1.y, c5.y, c5.w\n"
				"    rcp r7.w, c1.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c0.x, c0.z\n"
				"    mad r8.y, r9.y, c0.y, c0.w\n"
				"    texld r3, r8, s0\n"
				"    texld r10, t0, s1\n"
				"    mul r3.w, r7.y, c4.x\n"
				"    frc r10.w, r2.x\n"
				"    mad r3.w, r10.w, c1.x, r3.w\n"
				"    mul r10.w, r7.w, r3.w\n"
				"    frc r3.w, r10.w\n"
				"    mul r10.w, r3.w, c1.x\n"
				"    add r10.w, r10.w, -c2.x\n"
				"    frc r3.w, r10.w\n"
				"    add r10.w, r10.w, -r3.w\n"
				"    abs r3.w, r10.w\n"
				"    cmp_pp r3.w, -r3.w, c6.w, c6.y\n"
				"    add r10.w, r10.w, -c1.x\n"
				"    abs r10.w, r10.w\n"
				"    cmp_pp r10.w, -r10.w, c6.w, c6.y\n"
				"    add_pp r3.w, r3.w, r10.w\n"
				"    cmp r7.xyz, -r3.w, r10, r3\n"
				"    mov r7.w, c6.y\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:3:input0\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:3:oldoutput\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine1_ps20 = &__float3streamCombine1_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine1_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.offset : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._tex_oldoutput : TEXUNIT1\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var float modulus : C1 :  : 2 : 1\n"
				"#var float offset : C2 :  : 3 : 1\n"
				"#var float length : C3 :  : 4 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 5 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT1 : texunit 1 : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 9 : 1\n"
				"#var float4 __workspace : C6 :  : 11 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX1, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, length.x;\n"
				"MULR R1.x, R2.w, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |length.x|;\n"
				"RCPR R1.y, modulus.x;\n"
				"MULR R1.y, R3.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |modulus.x|;\n"
				"MOVR R1.z, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.x;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, -offset.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SEQR H0.x, R1.x, modulus.x;\n"
				"SEQR H0.y, R1.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"MOVR o[COLR].xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine1_fp30 = &__float3streamCombine1_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine1_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c5.x, c5.z;\n"
				"MAD r7.y, t1.y, c5.y, c5.w;\n"
				"RCP r7.w, c1.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c0.x, c0.z;\n"
				"MAD r8.y, r9.y, c0.y, c0.w;\n"
				"TEX r3, r8, texture[0], RECT;\n"
				"TEX r10, t0, texture[1], RECT;\n"
				"MUL r3.w, r7.y, c4.x;\n"
				"FRC r10.w, r2.x;\n"
				"MAD r3.w, r10.w, c1.x, r3.w;\n"
				"MUL r10.w, r7.w, r3.w;\n"
				"FRC r3.w, r10.w;\n"
				"MUL r10.w, r3.w, c1.x;\n"
				"ADD r10.w, r10.w, -c2.x;\n"
				"FRC r3.w, r10.w;\n"
				"ADD r10.w, r10.w, -r3.w;\n"
				"ABS r3.w, r10.w;\n"
				"CMP r3.w, -r3.w, c6.y, c6.w;\n"
				"ADD r10.w, r10.w, -c1.x;\n"
				"ABS r10.w, r10.w;\n"
				"CMP r10.w, -r10.w, c6.y, c6.w;\n"
				"ADD r3.w, r3.w, r10.w;\n"
				"CMP r7.xyz, -r3.w, r3, r10;\n"
				"MOV r7.w, c6.y;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine1_arb = &__float3streamCombine1_arb_desc;
}

void __float3streamCombine1_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat3  &oldoutput,
                                        __BrtFloat3  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = oldoutput;
  }

}
void  __float3streamCombine1_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat3 *arg5 = (__BrtFloat3 *)args[5];
  __BrtFloat3 *arg6 = (__BrtFloat3 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio5 = extents[6][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[6][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[6]);
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine1_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof6);
    i++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[6]);
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float3streamCombine1 (::brook::stream input0,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float3streamCombine1_fp[] = {
     "fp30", __float3streamCombine1_fp30,
     "arb", __float3streamCombine1_arb,
     "ps20", __float3streamCombine1_ps20,
     "cpu", (void *) __float3streamCombine1_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine1_fp);

  k->PushGatherStream(input0);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 1, 0, 0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t0.x, c5.x, c5.z\n"
				"    mad r7.y, t0.y, c5.y, c5.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r3.x, r9.x, c0.x, c0.z\n"
				"    mad r3.y, r9.y, c0.y, c0.w\n"
				"    mad r10.x, r9.x, c1.x, c1.z\n"
				"    mad r10.y, r9.y, c1.y, c1.w\n"
				"    texld r5, r3, s0\n"
				"    texld r0, r10, s1\n"
				"    mul r5.w, r7.y, c4.x\n"
				"    frc r0.w, r2.x\n"
				"    mad r5.w, r0.w, c2.x, r5.w\n"
				"    mul r0.w, r7.w, r5.w\n"
				"    frc r5.w, r0.w\n"
				"    mul r0.w, r5.w, c2.x\n"
				"    add r5.w, r0.w, c6.w\n"
				"    frc r0.w, r5.w\n"
				"    add r5.w, r5.w, -r0.w\n"
				"    abs r0.w, r5.w\n"
				"    cmp_pp r0.w, -r0.w, c6.y, c6.z\n"
				"    add r5.w, r5.w, -c2.x\n"
				"    abs r5.w, r5.w\n"
				"    cmp_pp r5.w, -r5.w, c6.y, c6.z\n"
				"    add_pp r0.w, r0.w, r5.w\n"
				"    cmp r11.xyz, -r0.w, r0, r5\n"
				"    mov r11.w, c6.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:6\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float3streamCombine2f_ps20 = &__float3streamCombine2f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float length : C3 :  : 5 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 8 : 1\n"
				"#var float4 __workspace : C6 :  : 10 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, length.x;\n"
				"MULR R0.x, R1.w, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |length.x|;\n"
				"RCPR R0.y, modulus.x;\n"
				"MULR R0.y, R2.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |modulus.x|;\n"
				"MOVR R0.z, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.x;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, -{-0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SEQR H0.x, R0.x, modulus.x;\n"
				"SEQR H0.y, R0.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xyz, R1.xyxx, TEX0, RECT;\n"
				"TEX R1.xyz, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R0.xyzx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float3streamCombine2f_fp30 = &__float3streamCombine2f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c5.x, c5.z;\n"
				"MAD r7.y, t0.y, c5.y, c5.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r3.x, r9.x, c0.x, c0.z;\n"
				"MAD r3.y, r9.y, c0.y, c0.w;\n"
				"MAD r10.x, r9.x, c1.x, c1.z;\n"
				"MAD r10.y, r9.y, c1.y, c1.w;\n"
				"TEX r5, r3, texture[0], RECT;\n"
				"TEX r0, r10, texture[1], RECT;\n"
				"MUL r5.w, r7.y, c4.x;\n"
				"FRC r0.w, r2.x;\n"
				"MAD r5.w, r0.w, c2.x, r5.w;\n"
				"MUL r0.w, r7.w, r5.w;\n"
				"FRC r5.w, r0.w;\n"
				"MUL r0.w, r5.w, c2.x;\n"
				"ADD r5.w, r0.w, c6.w;\n"
				"FRC r0.w, r5.w;\n"
				"ADD r5.w, r5.w, -r0.w;\n"
				"ABS r0.w, r5.w;\n"
				"CMP r0.w, -r0.w, c6.z, c6.y;\n"
				"ADD r5.w, r5.w, -c2.x;\n"
				"ABS r5.w, r5.w;\n"
				"CMP r5.w, -r5.w, c6.z, c6.y;\n"
				"ADD r0.w, r0.w, r5.w;\n"
				"CMP r11.xyz, -r0.w, r5, r0;\n"
				"MOV r11.w, c6.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float3streamCombine2f_arb = &__float3streamCombine2f_arb_desc;
}

void __float3streamCombine2f_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                         const __BrtArray2d<__BrtFloat3  > &input1,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat3  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = input1[newindex];
  }

}
void  __float3streamCombine2f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat3 *arg5 = (__BrtFloat3 *)args[5];
  unsigned int dim=dims[5];
  unsigned int newline=extents[5][dim-1];
  arg5+=mapbegin;
  ;
__BrtFloat4 indexof5 = computeIndexOf(mapbegin, extents[5], dims[5], extents[5]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine2f_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      indexof5);
    i++;
    ++arg5;
indexof5.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof5 = computeReferenceIndexOf(i+mapbegin, extents[5],dim);
    }
  }
}

void  float3streamCombine2f (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float3streamCombine2f_fp[] = {
     "fp30", __float3streamCombine2f_fp30,
     "arb", __float3streamCombine2f_arb,
     "ps20", __float3streamCombine2f_ps20,
     "cpu", (void *) __float3streamCombine2f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine2f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 0, -1, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t1.x, c6.x, c6.z\n"
				"    mad r0.y, t1.y, c6.y, c6.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r5.x, r8.x, c1.x, c1.z\n"
				"    mad r5.y, r8.y, c1.y, c1.w\n"
				"    mad r2.x, r8.x, c0.x, c0.z\n"
				"    mad r2.y, r8.y, c0.y, c0.w\n"
				"    texld r9, r5, s1\n"
				"    texld r4, t0, s2\n"
				"    texld r11, r2, s0\n"
				"    mul r9.w, r0.y, c5.x\n"
				"    frc r4.w, r7.x\n"
				"    mad r9.w, r4.w, c2.x, r9.w\n"
				"    mul r4.w, r7.w, r9.w\n"
				"    frc r9.w, r4.w\n"
				"    mul r4.w, r9.w, c2.x\n"
				"    add r9.w, r4.w, -c3.x\n"
				"    frc r4.w, r9.w\n"
				"    add r9.w, r9.w, -r4.w\n"
				"    add r4.w, r9.w, c7.z\n"
				"    abs r4.w, r4.w\n"
				"    cmp r9.xyz, -r4.w, r9, r4\n"
				"    abs r11.w, r9.w\n"
				"    cmp_pp r11.w, -r11.w, c7.w, c7.y\n"
				"    add r9.w, r9.w, -c2.x\n"
				"    abs r9.w, r9.w\n"
				"    cmp_pp r9.w, -r9.w, c7.w, c7.y\n"
				"    add_pp r11.w, r11.w, r9.w\n"
				"    cmp r1.xyz, -r11.w, r9, r11\n"
				"    mov r1.w, c7.y\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:3:oldoutput\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine2_ps20 = &__float3streamCombine2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.offset : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._tex_oldoutput : TEXUNIT2\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float offset : C3 :  : 5 : 1\n"
				"#var float length : C4 :  : 6 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 7 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT2 : texunit 2 : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 11 : 1\n"
				"#var float4 __workspace : C7 :  : 13 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 10 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 12 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R1.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine2_fp30 = &__float3streamCombine2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t1.x, c6.x, c6.z;\n"
				"MAD r0.y, t1.y, c6.y, c6.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r5.x, r8.x, c1.x, c1.z;\n"
				"MAD r5.y, r8.y, c1.y, c1.w;\n"
				"MAD r2.x, r8.x, c0.x, c0.z;\n"
				"MAD r2.y, r8.y, c0.y, c0.w;\n"
				"TEX r9, r5, texture[1], RECT;\n"
				"TEX r4, t0, texture[2], RECT;\n"
				"TEX r11, r2, texture[0], RECT;\n"
				"MUL r9.w, r0.y, c5.x;\n"
				"FRC r4.w, r7.x;\n"
				"MAD r9.w, r4.w, c2.x, r9.w;\n"
				"MUL r4.w, r7.w, r9.w;\n"
				"FRC r9.w, r4.w;\n"
				"MUL r4.w, r9.w, c2.x;\n"
				"ADD r9.w, r4.w, -c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"ADD r9.w, r9.w, -r4.w;\n"
				"ADD r4.w, r9.w, c7.z;\n"
				"ABS r4.w, r4.w;\n"
				"CMP r9.xyz, -r4.w, r4, r9;\n"
				"ABS r11.w, r9.w;\n"
				"CMP r11.w, -r11.w, c7.y, c7.w;\n"
				"ADD r9.w, r9.w, -c2.x;\n"
				"ABS r9.w, r9.w;\n"
				"CMP r9.w, -r9.w, c7.y, c7.w;\n"
				"ADD r11.w, r11.w, r9.w;\n"
				"CMP r1.xyz, -r11.w, r11, r9;\n"
				"MOV r1.w, c7.y;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine2_arb = &__float3streamCombine2_arb_desc;
}

void __float3streamCombine2_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                        const __BrtArray2d<__BrtFloat3  > &input1,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat3  &oldoutput,
                                        __BrtFloat3  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = oldoutput;
    }

}
void  __float3streamCombine2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat3 *arg6 = (__BrtFloat3 *)args[6];
  __BrtFloat3 *arg7 = (__BrtFloat3 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  unsigned int ratio6 = extents[7][dim-1]/extents[6][dim-1];
  unsigned int scale6=extents[6][dim-1]/extents[7][dim-1];
  if (scale6<1) scale6 = 1;
  unsigned int ratioiter6 = 0;
  if (ratio6) ratioiter6 = mapbegin%ratio6;
  unsigned int iter6 = getIndexOf(mapbegin,extents[6], dim, extents[7]);
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine2_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *(arg6 + iter6),
      *arg7,
      indexof7);
    i++;
    if (++ratioiter6>=ratio6){
      ratioiter6=0;
      iter6+=scale6;
    }
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter6=getIndexOf(i+mapbegin,extents[6],dim, extents[7]);
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float3streamCombine2 (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float3streamCombine2_fp[] = {
     "fp30", __float3streamCombine2_fp30,
     "arb", __float3streamCombine2_arb,
     "ps20", __float3streamCombine2_ps20,
     "cpu", (void *) __float3streamCombine2_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine2_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 1, 0, 0.5\n"
				"    def c8, -1, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t0.x, c6.x, c6.z\n"
				"    mad r0.y, t0.y, c6.y, c6.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c1.x, c1.z\n"
				"    mad r10.y, r8.y, c1.y, c1.w\n"
				"    mad r9.x, r8.x, c2.x, c2.z\n"
				"    mad r9.y, r8.y, c2.y, c2.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s1\n"
				"    texld r6, r9, s2\n"
				"    texld r1, r4, s0\n"
				"    mul r11.w, r0.y, c5.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, c7.w\n"
				"    frc r6.w, r11.w\n"
				"    add r11.w, r11.w, -r6.w\n"
				"    add r6.w, r11.w, c8.x\n"
				"    abs r6.w, r6.w\n"
				"    cmp r11.xyz, -r6.w, r11, r6\n"
				"    abs r1.w, r11.w\n"
				"    cmp_pp r1.w, -r1.w, c7.y, c7.z\n"
				"    add r11.w, r11.w, -c3.x\n"
				"    abs r11.w, r11.w\n"
				"    cmp_pp r11.w, -r11.w, c7.y, c7.z\n"
				"    add_pp r1.w, r1.w, r11.w\n"
				"    cmp r8.xyz, -r1.w, r11, r1\n"
				"    mov r8.w, c7.z\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine3f_ps20 = &__float3streamCombine3f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float length : C4 :  : 7 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R0.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xyz, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R0.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"TEX R0.xyz, R1.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine3f_fp30 = &__float3streamCombine3f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c8 = {-1, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t0.x, c6.x, c6.z;\n"
				"MAD r0.y, t0.y, c6.y, c6.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c1.x, c1.z;\n"
				"MAD r10.y, r8.y, c1.y, c1.w;\n"
				"MAD r9.x, r8.x, c2.x, c2.z;\n"
				"MAD r9.y, r8.y, c2.y, c2.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[1], RECT;\n"
				"TEX r6, r9, texture[2], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c5.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, c7.w;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r11.w, r11.w, -r6.w;\n"
				"ADD r6.w, r11.w, c8.x;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r11.xyz, -r6.w, r6, r11;\n"
				"ABS r1.w, r11.w;\n"
				"CMP r1.w, -r1.w, c7.z, c7.y;\n"
				"ADD r11.w, r11.w, -c3.x;\n"
				"ABS r11.w, r11.w;\n"
				"CMP r11.w, -r11.w, c7.z, c7.y;\n"
				"ADD r1.w, r1.w, r11.w;\n"
				"CMP r8.xyz, -r1.w, r1, r11;\n"
				"MOV r8.w, c7.z;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float3streamCombine3f_arb = &__float3streamCombine3f_arb_desc;
}

void __float3streamCombine3f_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                         const __BrtArray2d<__BrtFloat3  > &input1,
                                         const __BrtArray2d<__BrtFloat3  > &input2,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat3  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = input2[newindex];
    }

}
void  __float3streamCombine3f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat3 *arg6 = (__BrtFloat3 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine3f_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof6);
    i++;
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float3streamCombine3f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float3streamCombine3f_fp[] = {
     "fp30", __float3streamCombine3f_fp30,
     "arb", __float3streamCombine3f_arb,
     "ps20", __float3streamCombine3f_ps20,
     "cpu", (void *) __float3streamCombine3f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine3f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 0, -1, 1\n"
				"    def c9, -2, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    rcp r0.w, c5.x\n"
				"    mad r0.x, t1.x, c7.x, c7.z\n"
				"    mad r0.y, t1.y, c7.y, c7.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c5.x, r7.x\n"
				"    add r11.w, r4.w, c8.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c5.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c8.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c2.x, c2.z\n"
				"    mad r10.y, r8.y, c2.y, c2.w\n"
				"    mad r9.x, r8.x, c1.x, c1.z\n"
				"    mad r9.y, r8.y, c1.y, c1.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s2\n"
				"    texld r6, t0, s3\n"
				"    texld r1, r9, s1\n"
				"    texld r8, r4, s0\n"
				"    mul r11.w, r0.y, c6.x\n"
				"    frc r6.w, r7.x\n"
				"    mad r11.w, r6.w, c3.x, r11.w\n"
				"    mul r6.w, r7.w, r11.w\n"
				"    frc r11.w, r6.w\n"
				"    mul r6.w, r11.w, c3.x\n"
				"    add r11.w, r6.w, -c4.x\n"
				"    frc r6.w, r11.w\n"
				"    add r1.w, r11.w, -r6.w\n"
				"    add r11.w, r1.w, c9.x\n"
				"    abs r11.w, r11.w\n"
				"    cmp r7.xyz, -r11.w, r11, r6\n"
				"    add r7.w, r1.w, c8.z\n"
				"    abs r7.w, r7.w\n"
				"    cmp r1.xyz, -r7.w, r1, r7\n"
				"    abs r8.w, r1.w\n"
				"    cmp_pp r8.w, -r8.w, c8.w, c8.y\n"
				"    add r1.w, r1.w, -c3.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.w, c8.y\n"
				"    add_pp r8.w, r8.w, r1.w\n"
				"    cmp r10.xyz, -r8.w, r1, r8\n"
				"    mov r10.w, c8.y\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:3:oldoutput\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine3_ps20 = &__float3streamCombine3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.offset : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._tex_oldoutput : TEXUNIT3\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float offset : C4 :  : 7 : 1\n"
				"#var float length : C5 :  : 8 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 9 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT3 : texunit 3 : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 13 : 1\n"
				"#var float4 __workspace : C8 :  : 15 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 12 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 14 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX3, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"SEQR H0.w, R1.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.xyz, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R3.xyzx;\n"
				"TEX R1.xyz, R2.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine3_fp30 = &__float3streamCombine3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 0, -1, 1};\n"
				"PARAM c9 = {-2, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c5.x;\n"
				"MAD r0.x, t1.x, c7.x, c7.z;\n"
				"MAD r0.y, t1.y, c7.y, c7.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c5.x, r7.x;\n"
				"ADD r11.w, r4.w, c8.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c5.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c8.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c2.x, c2.z;\n"
				"MAD r10.y, r8.y, c2.y, c2.w;\n"
				"MAD r9.x, r8.x, c1.x, c1.z;\n"
				"MAD r9.y, r8.y, c1.y, c1.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[2], RECT;\n"
				"TEX r6, t0, texture[3], RECT;\n"
				"TEX r1, r9, texture[1], RECT;\n"
				"TEX r8, r4, texture[0], RECT;\n"
				"MUL r11.w, r0.y, c6.x;\n"
				"FRC r6.w, r7.x;\n"
				"MAD r11.w, r6.w, c3.x, r11.w;\n"
				"MUL r6.w, r7.w, r11.w;\n"
				"FRC r11.w, r6.w;\n"
				"MUL r6.w, r11.w, c3.x;\n"
				"ADD r11.w, r6.w, -c4.x;\n"
				"FRC r6.w, r11.w;\n"
				"ADD r1.w, r11.w, -r6.w;\n"
				"ADD r11.w, r1.w, c9.x;\n"
				"ABS r11.w, r11.w;\n"
				"CMP r7.xyz, -r11.w, r6, r11;\n"
				"ADD r7.w, r1.w, c8.z;\n"
				"ABS r7.w, r7.w;\n"
				"CMP r1.xyz, -r7.w, r7, r1;\n"
				"ABS r8.w, r1.w;\n"
				"CMP r8.w, -r8.w, c8.y, c8.w;\n"
				"ADD r1.w, r1.w, -c3.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c8.y, c8.w;\n"
				"ADD r8.w, r8.w, r1.w;\n"
				"CMP r10.xyz, -r8.w, r8, r1;\n"
				"MOV r10.w, c8.y;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine3_arb = &__float3streamCombine3_arb_desc;
}

void __float3streamCombine3_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                        const __BrtArray2d<__BrtFloat3  > &input1,
                                        const __BrtArray2d<__BrtFloat3  > &input2,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat3  &oldoutput,
                                        __BrtFloat3  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = oldoutput;
      }

}
void  __float3streamCombine3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat3 *arg7 = (__BrtFloat3 *)args[7];
  __BrtFloat3 *arg8 = (__BrtFloat3 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  unsigned int ratio7 = extents[8][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[8][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[8]);
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine3_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *(arg7 + iter7),
      *arg8,
      indexof8);
    i++;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[8]);
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float3streamCombine3 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float3streamCombine3_fp[] = {
     "fp30", __float3streamCombine3_fp30,
     "arb", __float3streamCombine3_arb,
     "ps20", __float3streamCombine3_ps20,
     "cpu", (void *) __float3streamCombine3_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine3_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 1, 0, 0.5\n"
				"    def c9, -1, 0, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    mad r7.x, t0.x, c7.x, c7.z\n"
				"    mad r7.y, t0.y, c7.y, c7.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c5.x, r2.x\n"
				"    add r9.w, r2.y, c8.x\n"
				"    add r2.w, r2.w, c8.x\n"
				"    rcp r4.w, c5.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c5.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c2.x, c2.z\n"
				"    mad r8.y, r9.y, c2.y, c2.w\n"
				"    mad r10.x, r9.x, c3.x, c3.z\n"
				"    mad r10.y, r9.y, c3.y, c3.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s2\n"
				"    texld r9, r10, s3\n"
				"    texld r1, r4, s1\n"
				"    texld r8, r11, s0\n"
				"    mul r6.w, r7.y, c6.x\n"
				"    frc r9.w, r2.x\n"
				"    mad r6.w, r9.w, c4.x, r6.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r6.w, r9.w, c8.w\n"
				"    frc r9.w, r6.w\n"
				"    add r1.w, r6.w, -r9.w\n"
				"    add r6.w, r1.w, c9.w\n"
				"    abs r6.w, r6.w\n"
				"    cmp r7.xyz, -r6.w, r6, r9\n"
				"    add r7.w, r1.w, c9.x\n"
				"    abs r7.w, r7.w\n"
				"    cmp r1.xyz, -r7.w, r1, r7\n"
				"    abs r8.w, r1.w\n"
				"    cmp_pp r8.w, -r8.w, c8.y, c8.z\n"
				"    add r1.w, r1.w, -c4.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.y, c8.z\n"
				"    add_pp r8.w, r8.w, r1.w\n"
				"    cmp r10.xyz, -r8.w, r1, r8\n"
				"    mov r10.w, c8.z\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//c:3:input3\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine4f_ps20 = &__float3streamCombine4f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float length : C5 :  : 9 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 12 : 1\n"
				"#var float4 __workspace : C8 :  : 14 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 11 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"SEQR H0.w, R0.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xyz, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R0.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"TEX R0.xyz, R1.xyxx, TEX2, RECT;\n"
				"TEX R1.xyz, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine4f_fp30 = &__float3streamCombine4f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c9 = {-1, 0, 0, -2};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c7.x, c7.z;\n"
				"MAD r7.y, t0.y, c7.y, c7.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c5.x, r2.x;\n"
				"ADD r9.w, r2.y, c8.x;\n"
				"ADD r2.w, r2.w, c8.x;\n"
				"RCP r4.w, c5.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c5.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c2.x, c2.z;\n"
				"MAD r8.y, r9.y, c2.y, c2.w;\n"
				"MAD r10.x, r9.x, c3.x, c3.z;\n"
				"MAD r10.y, r9.y, c3.y, c3.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[2], RECT;\n"
				"TEX r9, r10, texture[3], RECT;\n"
				"TEX r1, r4, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"MUL r6.w, r7.y, c6.x;\n"
				"FRC r9.w, r2.x;\n"
				"MAD r6.w, r9.w, c4.x, r6.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r6.w, r9.w, c8.w;\n"
				"FRC r9.w, r6.w;\n"
				"ADD r1.w, r6.w, -r9.w;\n"
				"ADD r6.w, r1.w, c9.w;\n"
				"ABS r6.w, r6.w;\n"
				"CMP r7.xyz, -r6.w, r9, r6;\n"
				"ADD r7.w, r1.w, c9.x;\n"
				"ABS r7.w, r7.w;\n"
				"CMP r1.xyz, -r7.w, r7, r1;\n"
				"ABS r8.w, r1.w;\n"
				"CMP r8.w, -r8.w, c8.z, c8.y;\n"
				"ADD r1.w, r1.w, -c4.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c8.z, c8.y;\n"
				"ADD r8.w, r8.w, r1.w;\n"
				"CMP r10.xyz, -r8.w, r8, r1;\n"
				"MOV r10.w, c8.z;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float3streamCombine4f_arb = &__float3streamCombine4f_arb_desc;
}

void __float3streamCombine4f_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                         const __BrtArray2d<__BrtFloat3  > &input1,
                                         const __BrtArray2d<__BrtFloat3  > &input2,
                                         const __BrtArray2d<__BrtFloat3  > &input3,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat3  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = input3[newindex];
      }

}
void  __float3streamCombine4f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat3  > arg3(
      (__BrtFloat3  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat3 *arg7 = (__BrtFloat3 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine4f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      indexof7);
    i++;
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float3streamCombine4f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float3streamCombine4f_fp[] = {
     "fp30", __float3streamCombine4f_fp30,
     "arb", __float3streamCombine4f_arb,
     "ps20", __float3streamCombine4f_ps20,
     "cpu", (void *) __float3streamCombine4f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine4f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 0, -1, 1\n"
				"    def c10, -2, 0, 0, -3\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t1.x, c8.x, c8.z\n"
				"    mad r7.y, t1.y, c8.y, c8.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c2.x, c2.z\n"
				"    mad r10.y, r9.y, c2.y, c2.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s3\n"
				"    texld r9, t0, s4\n"
				"    texld r1, r10, s2\n"
				"    texld r8, r4, s1\n"
				"    texld r3, r11, s0\n"
				"    mul r6.w, r7.y, c7.x\n"
				"    frc r9.w, r2.x\n"
				"    mad r6.w, r9.w, c4.x, r6.w\n"
				"    mul r9.w, r7.w, r6.w\n"
				"    frc r6.w, r9.w\n"
				"    mul r9.w, r6.w, c4.x\n"
				"    add r9.w, r9.w, -c5.x\n"
				"    frc r6.w, r9.w\n"
				"    add r8.w, r9.w, -r6.w\n"
				"    add r9.w, r8.w, c10.w\n"
				"    abs r9.w, r9.w\n"
				"    cmp r7.xyz, -r9.w, r6, r9\n"
				"    add r1.w, r8.w, c10.x\n"
				"    abs r1.w, r1.w\n"
				"    cmp r2.xyz, -r1.w, r1, r7\n"
				"    add r2.w, r8.w, c9.z\n"
				"    abs r2.w, r2.w\n"
				"    cmp r8.xyz, -r2.w, r8, r2\n"
				"    abs r3.w, r8.w\n"
				"    cmp_pp r3.w, -r3.w, c9.w, c9.y\n"
				"    add r8.w, r8.w, -c4.x\n"
				"    abs r8.w, r8.w\n"
				"    cmp_pp r8.w, -r8.w, c9.w, c9.y\n"
				"    add_pp r3.w, r3.w, r8.w\n"
				"    cmp r0.xyz, -r3.w, r8, r3\n"
				"    mov r0.w, c9.y\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:10\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//c:3:input3\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:3:oldoutput\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float3streamCombine4_ps20 = &__float3streamCombine4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.offset : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._tex_oldoutput : TEXUNIT4\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float offset : C5 :  : 9 : 1\n"
				"#var float length : C6 :  : 10 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 11 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT4 : texunit 4 : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 15 : 1\n"
				"#var float4 __workspace : C9 :  : 17 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 14 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 16 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0.xyz, f[TEX0].xyxx, TEX4, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R1.y, {2}.x;\n"
				"SEQR H0.w, R1.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX0, RECT;\n"
				"TEX R3.xyz, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R3.xyzx;\n"
				"TEX R1.xyz, R2.xyxx, TEX2, RECT;\n"
				"TEX R2.xyz, R2.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float3streamCombine4_fp30 = &__float3streamCombine4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-2, 0, 0, -3};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c8.x, c8.z;\n"
				"MAD r7.y, t1.y, c8.y, c8.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c2.x, c2.z;\n"
				"MAD r10.y, r9.y, c2.y, c2.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[3], RECT;\n"
				"TEX r9, t0, texture[4], RECT;\n"
				"TEX r1, r10, texture[2], RECT;\n"
				"TEX r8, r4, texture[1], RECT;\n"
				"TEX r3, r11, texture[0], RECT;\n"
				"MUL r6.w, r7.y, c7.x;\n"
				"FRC r9.w, r2.x;\n"
				"MAD r6.w, r9.w, c4.x, r6.w;\n"
				"MUL r9.w, r7.w, r6.w;\n"
				"FRC r6.w, r9.w;\n"
				"MUL r9.w, r6.w, c4.x;\n"
				"ADD r9.w, r9.w, -c5.x;\n"
				"FRC r6.w, r9.w;\n"
				"ADD r8.w, r9.w, -r6.w;\n"
				"ADD r9.w, r8.w, c10.w;\n"
				"ABS r9.w, r9.w;\n"
				"CMP r7.xyz, -r9.w, r9, r6;\n"
				"ADD r1.w, r8.w, c10.x;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r2.xyz, -r1.w, r7, r1;\n"
				"ADD r2.w, r8.w, c9.z;\n"
				"ABS r2.w, r2.w;\n"
				"CMP r8.xyz, -r2.w, r2, r8;\n"
				"ABS r3.w, r8.w;\n"
				"CMP r3.w, -r3.w, c9.y, c9.w;\n"
				"ADD r8.w, r8.w, -c4.x;\n"
				"ABS r8.w, r8.w;\n"
				"CMP r8.w, -r8.w, c9.y, c9.w;\n"
				"ADD r3.w, r3.w, r8.w;\n"
				"CMP r0.xyz, -r3.w, r3, r8;\n"
				"MOV r0.w, c9.y;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:3:oldoutput\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float3streamCombine4_arb = &__float3streamCombine4_arb_desc;
}

void __float3streamCombine4_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                        const __BrtArray2d<__BrtFloat3  > &input1,
                                        const __BrtArray2d<__BrtFloat3  > &input2,
                                        const __BrtArray2d<__BrtFloat3  > &input3,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat3  &oldoutput,
                                        __BrtFloat3  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = oldoutput;
        }

}
void  __float3streamCombine4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat3  > arg3(
      (__BrtFloat3  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat3 *arg8 = (__BrtFloat3 *)args[8];
  __BrtFloat3 *arg9 = (__BrtFloat3 *)args[9];
  unsigned int dim=dims[9];
  unsigned int newline=extents[9][dim-1];
  unsigned int ratio8 = extents[9][dim-1]/extents[8][dim-1];
  unsigned int scale8=extents[8][dim-1]/extents[9][dim-1];
  if (scale8<1) scale8 = 1;
  unsigned int ratioiter8 = 0;
  if (ratio8) ratioiter8 = mapbegin%ratio8;
  unsigned int iter8 = getIndexOf(mapbegin,extents[8], dim, extents[9]);
  arg9+=mapbegin;
  ;
__BrtFloat4 indexof9 = computeIndexOf(mapbegin, extents[9], dims[9], extents[9]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine4_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      *(arg8 + iter8),
      *arg9,
      indexof9);
    i++;
    if (++ratioiter8>=ratio8){
      ratioiter8=0;
      iter8+=scale8;
    }
    ++arg9;
indexof9.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter8=getIndexOf(i+mapbegin,extents[8],dim, extents[9]);
      indexof9 = computeReferenceIndexOf(i+mapbegin, extents[9],dim);
    }
  }
}

void  float3streamCombine4 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float3streamCombine4_fp[] = {
     "fp30", __float3streamCombine4_fp30,
     "arb", __float3streamCombine4_arb,
     "ps20", __float3streamCombine4_ps20,
     "cpu", (void *) __float3streamCombine4_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine4_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine5f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 1, 0, 0.5\n"
				"    def c10, -1, -3, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t0.x, c8.x, c8.z\n"
				"    mad r7.y, t0.y, c8.y, c8.w\n"
				"    rcp r7.w, c5.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c4.x, c4.z\n"
				"    mad r10.y, r9.y, c4.y, c4.w\n"
				"    mad r0.x, r9.x, c2.x, c2.z\n"
				"    mad r0.y, r9.y, c2.y, c2.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    mov r4.xy, r9\n"
				"    mad r9.x, r4.x, c0.x, c0.z\n"
				"    mad r9.y, r4.y, c0.y, c0.w\n"
				"    texld r1, r8, s3\n"
				"    texld r8, r10, s4\n"
				"    texld r3, r0, s2\n"
				"    texld r10, r6, s1\n"
				"    texld r5, r9, s0\n"
				"    mul r1.w, r7.y, c7.x\n"
				"    frc r8.w, r2.x\n"
				"    mad r1.w, r8.w, c5.x, r1.w\n"
				"    mul r8.w, r7.w, r1.w\n"
				"    frc r1.w, r8.w\n"
				"    mul r8.w, r1.w, c5.x\n"
				"    add r1.w, r8.w, c9.w\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    add r1.w, r10.w, c10.y\n"
				"    abs r1.w, r1.w\n"
				"    cmp r7.xyz, -r1.w, r1, r8\n"
				"    add r3.w, r10.w, c10.w\n"
				"    abs r3.w, r3.w\n"
				"    cmp r2.xyz, -r3.w, r3, r7\n"
				"    add r2.w, r10.w, c10.x\n"
				"    abs r2.w, r2.w\n"
				"    cmp r10.xyz, -r2.w, r10, r2\n"
				"    abs r5.w, r10.w\n"
				"    cmp_pp r5.w, -r5.w, c9.y, c9.z\n"
				"    add r10.w, r10.w, -c5.x\n"
				"    abs r10.w, r10.w\n"
				"    cmp_pp r10.w, -r10.w, c9.y, c9.z\n"
				"    add_pp r5.w, r5.w, r10.w\n"
				"    cmp r11.xyz, -r5.w, r10, r5\n"
				"    mov r11.w, c9.z\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:3:input0\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//c:3:input3\n"
				"//c:3:input4\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:3:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine5f_ps20 = &__float3streamCombine5f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine5f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.input4 : TEXUNIT4\n"
				"#semantic main.__gatherconst_input4 : C4\n"
				"#semantic main.modulus : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var samplerRECT input4[0] : TEXUNIT4 : texunit 4 : 8 : 1\n"
				"#var float4 __gatherconst_input4 : C4 :  : 9 : 1\n"
				"#var float modulus : C5 :  : 10 : 1\n"
				"#var float length : C6 :  : 11 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 14 : 1\n"
				"#var float4 __workspace : C9 :  : 16 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 13 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 15 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE __gatherconst_input4;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R0.y, {2}.x;\n"
				"SEQR H0.w, R0.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0.xyz, R1.xyxx, TEX0, RECT;\n"
				"TEX R2.xyz, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, R0.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"TEX R0.xyz, R1.xyxx, TEX2, RECT;\n"
				"TEX R2.xyz, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xyz(GT.x), R2.xyzx;\n"
				"TEX R0.xyz, R1.xyxx, TEX4, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:3:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine5f_fp30 = &__float3streamCombine5f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float3streamCombine5f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-1, -3, 0, -2};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c8.x, c8.z;\n"
				"MAD r7.y, t0.y, c8.y, c8.w;\n"
				"RCP r7.w, c5.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c4.x, c4.z;\n"
				"MAD r10.y, r9.y, c4.y, c4.w;\n"
				"MAD r0.x, r9.x, c2.x, c2.z;\n"
				"MAD r0.y, r9.y, c2.y, c2.w;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"MOV r4.xy, r9;\n"
				"MAD r9.x, r4.x, c0.x, c0.z;\n"
				"MAD r9.y, r4.y, c0.y, c0.w;\n"
				"TEX r1, r8, texture[3], RECT;\n"
				"TEX r8, r10, texture[4], RECT;\n"
				"TEX r3, r0, texture[2], RECT;\n"
				"TEX r10, r6, texture[1], RECT;\n"
				"TEX r5, r9, texture[0], RECT;\n"
				"MUL r1.w, r7.y, c7.x;\n"
				"FRC r8.w, r2.x;\n"
				"MAD r1.w, r8.w, c5.x, r1.w;\n"
				"MUL r8.w, r7.w, r1.w;\n"
				"FRC r1.w, r8.w;\n"
				"MUL r8.w, r1.w, c5.x;\n"
				"ADD r1.w, r8.w, c9.w;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"ADD r1.w, r10.w, c10.y;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r7.xyz, -r1.w, r8, r1;\n"
				"ADD r3.w, r10.w, c10.w;\n"
				"ABS r3.w, r3.w;\n"
				"CMP r2.xyz, -r3.w, r7, r3;\n"
				"ADD r2.w, r10.w, c10.x;\n"
				"ABS r2.w, r2.w;\n"
				"CMP r10.xyz, -r2.w, r2, r10;\n"
				"ABS r5.w, r10.w;\n"
				"CMP r5.w, -r5.w, c9.z, c9.y;\n"
				"ADD r10.w, r10.w, -c5.x;\n"
				"ABS r10.w, r10.w;\n"
				"CMP r10.w, -r10.w, c9.z, c9.y;\n"
				"ADD r5.w, r5.w, r10.w;\n"
				"CMP r11.xyz, -r5.w, r5, r10;\n"
				"MOV r11.w, c9.z;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:3:input0\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##c:3:input3\n"
				"##c:3:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:3:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float3streamCombine5f_arb = &__float3streamCombine5f_arb_desc;
}

void __float3streamCombine5f_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input0,
                                         const __BrtArray2d<__BrtFloat3  > &input1,
                                         const __BrtArray2d<__BrtFloat3  > &input2,
                                         const __BrtArray2d<__BrtFloat3  > &input3,
                                         const __BrtArray2d<__BrtFloat3  > &input4,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat3  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = input4[newindex];
        }

}
void  __float3streamCombine5f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat3  > arg3(
      (__BrtFloat3  *)args[3], extents[3]);
  __BrtArray2d<__BrtFloat3  > arg4(
      (__BrtFloat3  *)args[4], extents[4]);
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat3 *arg8 = (__BrtFloat3 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float3streamCombine5f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      *arg5,
      *arg6,
      *arg7,
      *arg8,
      indexof8);
    i++;
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float3streamCombine5f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		::brook::stream input4,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float3streamCombine5f_fp[] = {
     "fp30", __float3streamCombine5f_fp30,
     "arb", __float3streamCombine5f_arb,
     "ps20", __float3streamCombine5f_ps20,
     "cpu", (void *) __float3streamCombine5f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float3streamCombine5f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushGatherStream(input4);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}


void  combineStreamsHelperfloat3(::brook::stream (**streams), unsigned int  num, ::brook::stream output, float  modulus, float  offset, float  length, float  lengthmodmodulus)
{
  switch (num)
  {
  case 1:
    float3streamCombine1(*streams[0],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 2:
    float3streamCombine2(*streams[0],*streams[1],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 3:
    float3streamCombine3(*streams[0],*streams[1],*streams[2],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 4:
  default:
    float3streamCombine4(*streams[0],*streams[1],*streams[2],*streams[3],modulus,offset,length,lengthmodmodulus,output,output);
    if (num > 4)
    {
      combineStreamsHelperfloat3(streams + 4,num - 4,output,modulus,4 + offset,length,lengthmodmodulus);
    }

  }

}

void  combineStreamsfloat3(::brook::stream (**streams), unsigned int  num, unsigned int  width, unsigned int  length, ::brook::stream (*output))
{
  unsigned int  lengthmodmodulus = (num != 0) ? (length % num) : (0);
  ::brook::stream tmp=quickAllocStream(::brook::getStreamType(( float3  *)0), num * width , length,-1);

  streamSwap(tmp,*output);
  switch (num)
  {
  case 0:
    return;
  case 1:
    streamSwap(*output,*streams[0]);
    break;
  case 2:
    float3streamCombine2f(*streams[0],*streams[1],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 3:
    float3streamCombine3f(*streams[0],*streams[1],*streams[2],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 4:
    float3streamCombine4f(*streams[0],*streams[1],*streams[2],*streams[3],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 5:
  default:
    float3streamCombine5f(*streams[0],*streams[1],*streams[2],*streams[3],*streams[4],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    if (num > MAX_VOUT_STREAMS)
    {
      fprintf(stderr,"vout stream not reconstituted properly. %s%d streams","Too little precision for more than ",MAX_VOUT_STREAMS);
    }

    if (num > 5)
    {
      combineStreamsHelperfloat3(streams + 5,num - 5,*output,(float ) (num),(float ) (5 - 0.500000f),(float ) (length),(float ) (lengthmodmodulus));
    }

  }

}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0, 0.5, -0.5, 1\n"
				"    def c8, 0.25, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r0.x, t0.x, c2.x, c2.z\n"
				"    mad r0.y, t0.y, c2.y, c2.w\n"
				"    add r0.w, -c3.x, r0.x\n"
				"    add r7.w, r0.w, c7.y\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c5.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r1.w, r7.w, r11.w\n"
				"    frc r8.w, r6.w\n"
				"    mul r3.w, r8.w, c5.x\n"
				"    add r10.w, r3.w, c7.y\n"
				"    frc r5.w, r10.w\n"
				"    add r2.w, r10.w, -r5.w\n"
				"    add r4.w, -r2.w, c7.z\n"
				"    add r11.w, r2.w, c5.x\n"
				"    cmp r6.w, r4.w, r11.w, r2.w\n"
				"    add r8.w, r6.w, c8.x\n"
				"    add r10.w, r8.w, -c5.x\n"
				"    cmp r1.x, r10.w, c7.x, r6.w\n"
				"    frc r5.w, r1.w\n"
				"    add r1.w, r1.w, -r5.w\n"
				"    add r9.w, r0.y, -c3.y\n"
				"    add r1.y, r1.w, r9.w\n"
				"    mad r9.x, r1.x, c1.x, c1.z\n"
				"    mad r9.y, r1.y, c1.y, c1.w\n"
				"    mad r11.x, r0.x, c0.x, c0.z\n"
				"    mad r11.y, r0.y, c0.y, c0.w\n"
				"    texld r6, r9, s1\n"
				"    texld r8, r11, s0\n"
				"    cmp_pp r6.w, r0.w, c7.w, c7.x\n"
				"    add r8.w, r1.x, -c4.x\n"
				"    cmp_pp r8.w, r8.w, c7.w, c7.x\n"
				"    add r1.w, r1.y, -c4.y\n"
				"    abs r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c7.w, c7.x\n"
				"    mul r8.w, r8.w, r1.w\n"
				"    add r0.w, -r1.y, c4.y\n"
				"    cmp_pp r0.w, r0.w, c7.x, c7.w\n"
				"    add_pp r8.w, r8.w, r0.w\n"
				"    cmp r6.xyz, -r8.w, r6, c6.x\n"
				"    abs r8.w, r9.w\n"
				"    cmp_pp r8.w, -r8.w, c7.w, c7.x\n"
				"    mul r6.w, r6.w, r8.w\n"
				"    add r8.w, -r0.y, c3.y\n"
				"    cmp_pp r8.w, r8.w, c7.x, c7.w\n"
				"    add_pp r6.w, r6.w, r8.w\n"
				"    cmp r3.xyz, -r6.w, r8, r6\n"
				"    mov r3.w, c7.x\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:3:input1\n"
				"//c:3:input2\n"
				"//oi:3:output\n"
				"//c:2:startsecond\n"
				"//c:2:endsecond\n"
				"//c:2:maxinput2value\n"
				"//c:1:inf\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat3_ps20 = &__combinefloat3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input1 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input1 : C0\n"
				"#semantic main.input2 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input2 : C1\n"
				"#semantic main._const_output_invscalebias : C2\n"
				"#semantic main.startsecond : C3\n"
				"#semantic main.endsecond : C4\n"
				"#semantic main.maxinput2value : C5\n"
				"#semantic main.inf : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input1[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input1 : C0 :  : 1 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input2 : C1 :  : 3 : 1\n"
				"#var float4 _const_output_invscalebias : C2 :  : 5 : 1\n"
				"#var float2 startsecond : C3 :  : 7 : 1\n"
				"#var float2 endsecond : C4 :  : 8 : 1\n"
				"#var float2 maxinput2value : C5 :  : 9 : 1\n"
				"#var float inf : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 6 : 1\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE startsecond;\n"
				"DECLARE endsecond;\n"
				"DECLARE maxinput2value;\n"
				"DECLARE inf;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SGTR H0.x, R0.y, startsecond.y;\n"
				"SGER H0.y, R0.x, startsecond.x;\n"
				"SEQR H0.z, R0.y, startsecond.y;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDR R0.w, R0.y, -startsecond.y;\n"
				"MOVR R1.y, R0.w;\n"
				"MOVR R1.x, R0.x;\n"
				"TEX R0.xyz, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.w, R1.x, -startsecond.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxinput2value.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.z, R1.x, {0}.x;\n"
				"RCPR R1.y, maxinput2value.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxinput2value.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.z, R1.x, {-0.5}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxinput2value.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.z, R1.x, maxinput2value.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SGTR H0.z, R3.y, endsecond.y;\n"
				"SGER H0.w, R3.x, endsecond.x;\n"
				"SEQR H1.x, R3.y, endsecond.y;\n"
				"MADX H0.z, H1.x, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"TEX R1.xyz, R3.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR].xyz, inf.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR].xyz(GT.x), R1.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].xyz(GT.x), R0.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##oi:3:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat3_fp30 = &__combinefloat3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0, 0.5, -0.5, 1};\n"
				"PARAM c8 = {0.25, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r0.x, t0.x, c2.x, c2.z;\n"
				"MAD r0.y, t0.y, c2.y, c2.w;\n"
				"ADD r0.w, -c3.x, r0.x;\n"
				"ADD r7.w, r0.w, c7.y;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c5.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r1.w, r7.w, r11.w;\n"
				"FRC r8.w, r6.w;\n"
				"MUL r3.w, r8.w, c5.x;\n"
				"ADD r10.w, r3.w, c7.y;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r2.w, r10.w, -r5.w;\n"
				"ADD r4.w, -r2.w, c7.z;\n"
				"ADD r11.w, r2.w, c5.x;\n"
				"CMP r6.w, r4.w, r2.w, r11.w;\n"
				"ADD r8.w, r6.w, c8.x;\n"
				"ADD r10.w, r8.w, -c5.x;\n"
				"CMP r1.x, r10.w, r6.w, c7.x;\n"
				"FRC r5.w, r1.w;\n"
				"ADD r1.w, r1.w, -r5.w;\n"
				"ADD r9.w, r0.y, -c3.y;\n"
				"ADD r1.y, r1.w, r9.w;\n"
				"MAD r9.x, r1.x, c1.x, c1.z;\n"
				"MAD r9.y, r1.y, c1.y, c1.w;\n"
				"MAD r11.x, r0.x, c0.x, c0.z;\n"
				"MAD r11.y, r0.y, c0.y, c0.w;\n"
				"TEX r6, r9, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"CMP r6.w, r0.w, c7.x, c7.w;\n"
				"ADD r8.w, r1.x, -c4.x;\n"
				"CMP r8.w, r8.w, c7.x, c7.w;\n"
				"ADD r1.w, r1.y, -c4.y;\n"
				"ABS r1.w, r1.w;\n"
				"CMP r1.w, -r1.w, c7.x, c7.w;\n"
				"MUL r8.w, r8.w, r1.w;\n"
				"ADD r0.w, -r1.y, c4.y;\n"
				"CMP r0.w, r0.w, c7.w, c7.x;\n"
				"ADD r8.w, r8.w, r0.w;\n"
				"CMP r6.xyz, -r8.w, c6.x, r6;\n"
				"ABS r8.w, r9.w;\n"
				"CMP r8.w, -r8.w, c7.x, c7.w;\n"
				"MUL r6.w, r6.w, r8.w;\n"
				"ADD r8.w, -r0.y, c3.y;\n"
				"CMP r8.w, r8.w, c7.w, c7.x;\n"
				"ADD r6.w, r6.w, r8.w;\n"
				"CMP r3.xyz, -r6.w, r6, r8;\n"
				"MOV r3.w, c7.x;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:3:input1\n"
				"##c:3:input2\n"
				"##oi:3:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat3_arb = &__combinefloat3_arb_desc;
}

void __combinefloat3_cpu_inner (const __BrtArray2d<__BrtFloat3  > &input1,
                                 const __BrtArray2d<__BrtFloat3  > &input2,
                                 __BrtFloat3  &output,
                                 const __BrtFloat2  &startsecond,
                                 const __BrtFloat2  &endsecond,
                                 const __BrtFloat2  &maxinput2value,
                                 const __BrtFloat1  &inf,
                                 const __BrtFloat4 &__indexof_output){
  if ((__indexof_output).swizzle1(maskY) > startsecond.swizzle1(maskY) || (__indexof_output).swizzle1(maskY) == startsecond.swizzle1(maskY) && (__indexof_output).swizzle1(maskX) >= startsecond.swizzle1(maskX))
  {
    __BrtFloat2  secondindex;

    __getIndexAt_cpu_inner(__BrtFloat4 ((__indexof_output).swizzle1(maskX),(__indexof_output).swizzle1(maskY) - startsecond.swizzle1(maskY),__BrtFloat1((float)0),__BrtFloat1((float)0)),-startsecond.swizzle1(maskX),maxinput2value,secondindex);
    if (secondindex.swizzle1(maskY) > endsecond.swizzle1(maskY) || secondindex.swizzle1(maskY) == endsecond.swizzle1(maskY) && secondindex.swizzle1(maskX) >= endsecond.swizzle1(maskX))
    {
      output = inf;
    }

    else
    {
      output = input2[secondindex];
    }

  }

  else
  {
    output = input1[__indexof_output];
  }

}
void  __combinefloat3_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat3  > arg0(
      (__BrtFloat3  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat3  > arg1(
      (__BrtFloat3  *)args[1], extents[1]);
  __BrtFloat3 *arg2 = (__BrtFloat3 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  ;
__BrtFloat4 indexof2 = computeIndexOf(mapbegin, extents[2], dims[2], extents[2]);
  unsigned int i=0; 
  while (i<mapextent) {
    __combinefloat3_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof2);
    i++;
    ++arg2;
indexof2.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof2 = computeReferenceIndexOf(i+mapbegin, extents[2],dim);
    }
  }
}

void  combinefloat3 (::brook::stream input1,
		::brook::stream input2,
		::brook::stream output,
		const float2  startsecond,
		const float2  endsecond,
		const float2  maxinput2value,
		const float  inf) {
  static const void *__combinefloat3_fp[] = {
     "fp30", __combinefloat3_fp30,
     "arb", __combinefloat3_arb,
     "ps20", __combinefloat3_ps20,
     "cpu", (void *) __combinefloat3_cpu,
     NULL, NULL };
  static __BRTKernel k(__combinefloat3_fp);

  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushOutput(output);
  k->PushConstant(startsecond);
  k->PushConstant(endsecond);
  k->PushConstant(maxinput2value);
  k->PushConstant(inf);
  k->Map();

}


unsigned int  voutCombinefloat3(::brook::stream outleft_stream, float  maxshiftleft, unsigned int  LEFTWIDTH, ::brook::stream outright_stream, float  maxshiftright, unsigned int  RIGHTWIDTH, unsigned int  LENGTH, ::brook::stream (*output))
{
  unsigned int  totalsize;
  float2  maxleftvalue;
  float2  maxrightvalue;

  maxleftvalue.x = (float ) (LENGTH);
  maxleftvalue.y = (float ) (LEFTWIDTH);
  maxrightvalue.x = (float ) (LENGTH);
  maxrightvalue.y = (float ) (RIGHTWIDTH);
  totalsize = LEFTWIDTH * LENGTH + RIGHTWIDTH * LENGTH - (unsigned int ) (maxshiftleft) - (unsigned int ) (maxshiftright);
  if (1)
  {
    unsigned int  length = LENGTH;
    unsigned int  width = totalsize / length + ((totalsize % length != 0) ? (1) : (0));
    ::brook::stream output_stream=quickAllocStream(::brook::getStreamType(( float3  *)0), width , length,-1);
    float2  startsecond;
    float2  endsecond;

    cpuGetIndexAt(float2 (maxleftvalue.x,maxleftvalue.y - 1),-maxshiftleft,maxleftvalue,&startsecond);
    cpuGetIndexAt(float2 (maxrightvalue.x,maxrightvalue.y - 1),-maxshiftright,maxrightvalue,&endsecond);
    combinefloat3(outleft_stream,outright_stream,output_stream,startsecond,endsecond,maxrightvalue,1.000000f / (float ) (floor(0.500000f)));
    streamSwap(*output,output_stream);
  }

  return totalsize;
}

unsigned int  totalCombineVoutfloat3(::brook::stream list_stream, unsigned int  WIDTH, ::brook::stream list2_stream, unsigned int  WIDTH2, unsigned int  LENGTH, ::brook::stream (*output))
{
  ::brook::stream outleft_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream outright_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH2 , LENGTH,-1);
  float  maxshiftleft = shiftValuesfloat3(list_stream,&outleft_stream,WIDTH,LENGTH,-1);
  float  maxshiftright = shiftValuesfloat3(list2_stream,&outright_stream,WIDTH2,LENGTH,-1);

  return voutCombinefloat3(outleft_stream,maxshiftleft,WIDTH,outright_stream,maxshiftright,WIDTH2,LENGTH,output);
}

#undef VECTOR_TEMPLATIZED_FUNCTIONS

#define VECTOR_TEMPLATIZED_FUNCTIONS


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s1\n"
				"    rcp r2.w, r0.x\n"
				"    max r11.w, -r2.w, r2.w\n"
				"    cmp r1, -r11.w, r7, r0\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s1\n"
				"    rcp r9.w, r0.x\n"
				"    max r6.w, -r9.w, r9.w\n"
				"    cmp r8, -r6.w, r7, r0\n"
				"    rcp r3.w, r8.x\n"
				"    max r0.w, -r3.w, r3.w\n"
				"    cmp r2, -r0.w, r2, r8\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s1\n"
				"    rcp r4.w, r0.x\n"
				"    max r1.w, -r4.w, r4.w\n"
				"    cmp r3, -r1.w, r7, r0\n"
				"    rcp r10.w, r3.x\n"
				"    max r7.w, -r10.w, r10.w\n"
				"    cmp r2, -r7.w, r2, r3\n"
				"    rcp r11.w, r2.x\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp r9, -r8.w, r9, r2\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s1\n"
				"    rcp r11.w, r0.x\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp r10, -r8.w, r7, r0\n"
				"    rcp r5.w, r10.x\n"
				"    max r11.w, -r5.w, r5.w\n"
				"    cmp r2, -r11.w, r2, r10\n"
				"    rcp r1.w, r2.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp r9, -r10.w, r9, r2\n"
				"    rcp r0.w, r9.x\n"
				"    max r6.w, -r0.w, r0.w\n"
				"    cmp r4, -r6.w, r4, r9\n"
				"    mov oC0, r4\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s1\n"
				"    rcp r6.w, r0.x\n"
				"    max r3.w, -r6.w, r6.w\n"
				"    cmp r5, -r3.w, r7, r0\n"
				"    rcp r0.w, r5.x\n"
				"    max r1.w, -r0.w, r0.w\n"
				"    cmp r2, -r1.w, r2, r5\n"
				"    rcp r3.w, r2.x\n"
				"    max r0.w, -r3.w, r3.w\n"
				"    cmp r9, -r0.w, r9, r2\n"
				"    rcp r6.w, r9.x\n"
				"    max r2.w, -r6.w, r6.w\n"
				"    cmp r4, -r2.w, r4, r9\n"
				"    rcp r10.w, r4.x\n"
				"    max r7.w, -r10.w, r10.w\n"
				"    cmp r11, -r7.w, r11, r4\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s1\n"
				"    rcp r1.w, r0.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp r0, -r10.w, r7, r0\n"
				"    rcp r7.w, r0.x\n"
				"    max r3.w, -r7.w, r7.w\n"
				"    cmp r2, -r3.w, r2, r0\n"
				"    rcp r5.w, r2.x\n"
				"    max r1.w, -r5.w, r5.w\n"
				"    cmp r9, -r1.w, r9, r2\n"
				"    rcp r3.w, r9.x\n"
				"    max r5.w, -r3.w, r3.w\n"
				"    cmp r4, -r5.w, r4, r9\n"
				"    rcp r7.w, r4.x\n"
				"    max r9.w, -r7.w, r7.w\n"
				"    cmp r11, -r9.w, r11, r4\n"
				"    rcp r10.w, r11.x\n"
				"    max r0.w, -r10.w, r10.w\n"
				"    cmp r6, -r0.w, r6, r11\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl t4.xy\n"
				"    dcl t5.xy\n"
				"    dcl t6.xy\n"
				"    dcl t7.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t0, s0\n"
				"    texld r7, t1, s0\n"
				"    texld r2, t2, s0\n"
				"    texld r9, t3, s0\n"
				"    texld r4, t4, s0\n"
				"    texld r11, t5, s0\n"
				"    texld r6, t6, s0\n"
				"    texld r1, t7, s1\n"
				"    rcp r8.w, r0.x\n"
				"    max r5.w, -r8.w, r8.w\n"
				"    cmp r0, -r5.w, r7, r0\n"
				"    rcp r7.w, r0.x\n"
				"    max r5.w, -r7.w, r7.w\n"
				"    cmp r2, -r5.w, r2, r0\n"
				"    rcp r0.w, r2.x\n"
				"    max r10.w, -r0.w, r0.w\n"
				"    cmp r9, -r10.w, r9, r2\n"
				"    rcp r8.w, r9.x\n"
				"    max r7.w, -r8.w, r8.w\n"
				"    cmp r4, -r7.w, r4, r9\n"
				"    rcp r10.w, r4.x\n"
				"    max r8.w, -r10.w, r10.w\n"
				"    cmp r11, -r8.w, r11, r4\n"
				"    rcp r0.w, r11.x\n"
				"    max r4.w, -r0.w, r0.w\n"
				"    cmp r6, -r4.w, r6, r11\n"
				"    rcp r5.w, r6.x\n"
				"    max r2.w, -r5.w, r5.w\n"
				"    cmp r1, -r2.w, r1, r6\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:input\n"
				"//s:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat4_ps20 = &__valueProducedfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 5 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX1, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVR o[COLR], R0;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 6 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 7 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX3].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 8 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX4].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 9 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX5].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 10 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX6].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __workspace : C0 :  : 11 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex___reduce7_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD7 : TEX7 : 10 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1, f[TEX1].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R2.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R2.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX2].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX3].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX4].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX5].xyxx, TEX0, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"TEX R1, f[TEX6].xyxx, TEX0, RECT;\n"
				"TEX R2, f[TEX7].xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R1;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), R2;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat4_fp30 = &__valueProducedfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueProducedfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r7;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[1], RECT;\n"
				"RCP r2.w, r0.x;\n"
				"MAX r11.w, -r2.w, r2.w;\n"
				"CMP r1, -r11.w, r0, r7;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[1], RECT;\n"
				"RCP r9.w, r0.x;\n"
				"MAX r6.w, -r9.w, r9.w;\n"
				"CMP r8, -r6.w, r0, r7;\n"
				"RCP r3.w, r8.x;\n"
				"MAX r0.w, -r3.w, r3.w;\n"
				"CMP r2, -r0.w, r8, r2;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[1], RECT;\n"
				"RCP r4.w, r0.x;\n"
				"MAX r1.w, -r4.w, r4.w;\n"
				"CMP r3, -r1.w, r0, r7;\n"
				"RCP r10.w, r3.x;\n"
				"MAX r7.w, -r10.w, r10.w;\n"
				"CMP r2, -r7.w, r3, r2;\n"
				"RCP r11.w, r2.x;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r9, -r8.w, r2, r9;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[1], RECT;\n"
				"RCP r11.w, r0.x;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r10, -r8.w, r0, r7;\n"
				"RCP r5.w, r10.x;\n"
				"MAX r11.w, -r5.w, r5.w;\n"
				"CMP r2, -r11.w, r10, r2;\n"
				"RCP r1.w, r2.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r9, -r10.w, r2, r9;\n"
				"RCP r0.w, r9.x;\n"
				"MAX r6.w, -r0.w, r0.w;\n"
				"CMP r4, -r6.w, r9, r4;\n"
				"MOV oC0, r4;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[1], RECT;\n"
				"RCP r6.w, r0.x;\n"
				"MAX r3.w, -r6.w, r6.w;\n"
				"CMP r5, -r3.w, r0, r7;\n"
				"RCP r0.w, r5.x;\n"
				"MAX r1.w, -r0.w, r0.w;\n"
				"CMP r2, -r1.w, r5, r2;\n"
				"RCP r3.w, r2.x;\n"
				"MAX r0.w, -r3.w, r3.w;\n"
				"CMP r9, -r0.w, r2, r9;\n"
				"RCP r6.w, r9.x;\n"
				"MAX r2.w, -r6.w, r6.w;\n"
				"CMP r4, -r2.w, r9, r4;\n"
				"RCP r10.w, r4.x;\n"
				"MAX r7.w, -r10.w, r10.w;\n"
				"CMP r11, -r7.w, r4, r11;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[1], RECT;\n"
				"RCP r1.w, r0.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r0, -r10.w, r0, r7;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r3.w, -r7.w, r7.w;\n"
				"CMP r2, -r3.w, r0, r2;\n"
				"RCP r5.w, r2.x;\n"
				"MAX r1.w, -r5.w, r5.w;\n"
				"CMP r9, -r1.w, r2, r9;\n"
				"RCP r3.w, r9.x;\n"
				"MAX r5.w, -r3.w, r3.w;\n"
				"CMP r4, -r5.w, r9, r4;\n"
				"RCP r7.w, r4.x;\n"
				"MAX r9.w, -r7.w, r7.w;\n"
				"CMP r11, -r9.w, r4, r11;\n"
				"RCP r10.w, r11.x;\n"
				"MAX r0.w, -r10.w, r10.w;\n"
				"CMP r6, -r0.w, r11, r6;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"ATTRIB t4 = fragment.texcoord[4];\n"
				"ATTRIB t5 = fragment.texcoord[5];\n"
				"ATTRIB t6 = fragment.texcoord[6];\n"
				"ATTRIB t7 = fragment.texcoord[7];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"TEX r7, t1, texture[0], RECT;\n"
				"TEX r2, t2, texture[0], RECT;\n"
				"TEX r9, t3, texture[0], RECT;\n"
				"TEX r4, t4, texture[0], RECT;\n"
				"TEX r11, t5, texture[0], RECT;\n"
				"TEX r6, t6, texture[0], RECT;\n"
				"TEX r1, t7, texture[1], RECT;\n"
				"RCP r8.w, r0.x;\n"
				"MAX r5.w, -r8.w, r8.w;\n"
				"CMP r0, -r5.w, r0, r7;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r5.w, -r7.w, r7.w;\n"
				"CMP r2, -r5.w, r0, r2;\n"
				"RCP r0.w, r2.x;\n"
				"MAX r10.w, -r0.w, r0.w;\n"
				"CMP r9, -r10.w, r2, r9;\n"
				"RCP r8.w, r9.x;\n"
				"MAX r7.w, -r8.w, r8.w;\n"
				"CMP r4, -r7.w, r9, r4;\n"
				"RCP r10.w, r4.x;\n"
				"MAX r8.w, -r10.w, r10.w;\n"
				"CMP r11, -r8.w, r4, r11;\n"
				"RCP r0.w, r11.x;\n"
				"MAX r4.w, -r0.w, r0.w;\n"
				"CMP r6, -r4.w, r11, r6;\n"
				"RCP r5.w, r6.x;\n"
				"MAX r2.w, -r5.w, r5.w;\n"
				"CMP r1, -r2.w, r6, r1;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:input\n"
				"##s:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __valueProducedfloat4_arb = &__valueProducedfloat4_arb_desc;
}

void __valueProducedfloat4_cpu_inner (const __BrtFloat4  &input,
                                       __BrtFloat4  &output){
  output = __isinf_cpu_inner(input.swizzle1(maskX)).questioncolon(output,input);
}
void  __valueProducedfloat4__base_cpu_inner (const __BrtFloat4  &input,
                                             __BrtFloat4  &output) {
  output = input;
}
void  __valueProducedfloat4__combine_cpu_inner (const __BrtFloat4  &input,
                                                __BrtFloat4  &output,
                                                __BrtFloat4  &__combiner) {
  __valueProducedfloat4_cpu_inner (__combiner, output);
}
void  __valueProducedfloat4_cpu (const std::vector<void *>&args,
                                 const std::vector<const unsigned int *>&extents,
                                 const std::vector<unsigned int>&dims,
                                 unsigned int mapbegin, 
                                 unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int i=0; 
  if (mapextent) {
    __valueProducedfloat4__base_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
  while (i<mapextent) {
    __valueProducedfloat4_cpu_inner (
      *arg0,
      *arg1);
    i++;
    ++arg0;
    if ((mapbegin+i)%newline==0) {
    }
  }
}
void  __valueProducedfloat4_ndcpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   const unsigned int *mapbegin, 
                                   const unsigned int *mapextents) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  unsigned int dim=dims[0];
  unsigned int newline=mapextents[dim-1];
  unsigned int mapextent = mapextents[0], i=1;
  for (;i<dim;++i) mapextent*=mapextents[i];

  unsigned int iter0 = getIndexOf(0, mapbegin, mapextents, extents[0], dim, extents[0]);
  i=0; 
  if (mapextent) {
    __valueProducedfloat4__base_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
  while (i<mapextent) {
    __valueProducedfloat4_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    iter0++;
    if (i%newline==0) {
      iter0 = getIndexOf(i, mapbegin, mapextents,extents[0], dim, extents[0]);
    }
  }
}
void  __valueProducedfloat4__combine_cpu (const std::vector<void *>&args,
                                          const std::vector<const unsigned int *>&extents,
                                          const std::vector<unsigned int>&dims,
                                          unsigned int mapbegin) {
    __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
    arg0+=mapbegin;
    __valueProducedfloat4__combine_cpu_inner (
      *arg0,
      *arg1,
      *arg2);
}

class __valueProducedfloat4_scatterclass{ public:
  void operator () (__BrtFloat4  &output, 
                    const __BrtFloat4  &input) const {
    __valueProducedfloat4_cpu_inner (input, output);
  }
}__valueProducedfloat4_scatter;
void  valueProducedfloat4 (::brook::stream input,
		::brook::stream output) {
  static const void *__valueProducedfloat4_fp[] = {
     "fp30", __valueProducedfloat4_fp30,
     "arb", __valueProducedfloat4_arb,
     "ps20", __valueProducedfloat4_ps20,
     "cpu", (void *) __valueProducedfloat4_cpu,
     "ndcpu", (void *) __valueProducedfloat4_ndcpu,
     "combine", (void *) __valueProducedfloat4__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat4_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}

void  valueProducedfloat4 (::brook::stream input,
		float4  & output) {
  static const void *__valueProducedfloat4_fp[] = {
     "fp30", __valueProducedfloat4_fp30,
     "arb", __valueProducedfloat4_arb,
     "ps20", __valueProducedfloat4_ps20,
     "cpu", (void *) __valueProducedfloat4_cpu,
     "ndcpu", (void *) __valueProducedfloat4_ndcpu,
     "combine", (void *) __valueProducedfloat4__combine_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueProducedfloat4_fp);

  k->PushStream(input);
  k->PushReduce(&output, __BRTReductionType(&output));
  k->Reduce();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c0, 0, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    texld r0, t0, s0\n"
				"    rcp r7.w, r0.x\n"
				"    max r4.w, -r7.w, r7.w\n"
				"    cmp_pp r6.x, -r4.w, c0.x, c0.w\n"
				"    mov r6.yzw, c0.x\n"
				"    mov oC0, r6\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:2\n"
				"//s:4:inp\n"
				"//o:1:outp\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat4_ps20 = &__isFiniteKernelfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_inp : TEXUNIT0\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_inp : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __workspace : C0 :  : 3 : 1\n"
				"#var float2 _tex_inp_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.y, R0.x, R1.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVX o[COLR].x, H0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat4_fp30 = &__isFiniteKernelfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __isFiniteKernelfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = {0, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"RCP r7.w, r0.x;\n"
				"MAX r4.w, -r7.w, r7.w;\n"
				"CMP r6.x, -r4.w, c0.w, c0.x;\n"
				"MOV r6.yzw, c0.x;\n"
				"MOV oC0, r6;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:4:inp\n"
				"##o:1:outp\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.sampler(1, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __isFiniteKernelfloat4_arb = &__isFiniteKernelfloat4_arb_desc;
}

void __isFiniteKernelfloat4_cpu_inner (const __BrtFloat4  &inp,
                                        __BrtFloat1  &outp){
  outp = !__isinf_cpu_inner(inp.swizzle1(maskX));
}
void  __isFiniteKernelfloat4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  unsigned int ratio0 = extents[1][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[1][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[1]);
  arg1+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __isFiniteKernelfloat4_cpu_inner (
      *(arg0 + iter0),
      *arg1);
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    ++arg1;
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[1]);
    }
  }
}

void  isFiniteKernelfloat4 (::brook::stream inp,
		::brook::stream outp) {
  static const void *__isFiniteKernelfloat4_fp[] = {
     "fp30", __isFiniteKernelfloat4_fp30,
     "arb", __isFiniteKernelfloat4_arb,
     "ps20", __isFiniteKernelfloat4_ps20,
     "cpu", (void *) __isFiniteKernelfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__isFiniteKernelfloat4_fp);

  k->PushStream(inp);
  k->PushOutput(outp);
  k->Map();

}


int  finiteValueProducedfloat4(::brook::stream input)
{
   static ::brook::stream output(::brook::getStreamType(( float4  *)0), 1 , 1,-1);
   static ::brook::stream finiteout(::brook::getStreamType(( float  *)0), 1 , 1,-1);
  float4  rettype;
  float  ret;

  debugStreamPrint(input,"Finite Values in...");
  valueProducedfloat4(input,output);
  streamWrite(output,&rettype);
  isFiniteKernelfloat4(output,finiteout);
  streamWrite(finiteout,&ret);
  return (int ) (ret);
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0.1, 0, 0\n"
				"    dcl_2d s0\n"
				"    mov r5.xy, c1\n"
				"    mad r7.x, c0.x, r5.x, c0.z\n"
				"    mad r7.y, c0.y, r5.y, c0.w\n"
				"    texld r2, r7, s0\n"
				"    mov r9.w, -c2.y\n"
				"    add r4.w, r9.w, c1.y\n"
				"    cmp_pp r11.w, r4.w, c4.x, c4.w\n"
				"    mov r5.w, c1.y\n"
				"    add r6.w, c4.y, r5.w\n"
				"    cmp_pp r1.w, r6.w, c4.w, c4.x\n"
				"    add_pp r8.w, r11.w, r1.w\n"
				"    cmp r10, -r8.w, r2, c3.x\n"
				"    mov oC0, r10\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//c:4:value\n"
				"//c:2:index\n"
				"//o:4:output\n"
				"//c:2:maxvalue\n"
				"//c:1:nothing\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat4_ps20 = &__valueAtfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main.index : C1\n"
				"#semantic main.maxvalue : C2\n"
				"#semantic main.nothing : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float2 index : C1 :  : 2 : 1\n"
				"#var float2 maxvalue : C2 :  : 4 : 1\n"
				"#var float nothing : C3 :  : 5 : 1\n"
				"#var float4 __workspace : C4 :  : 6 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 3 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE index;\n"
				"DECLARE maxvalue;\n"
				"DECLARE nothing;\n"
				"DECLARE __workspace;\n"
				"TEX R0, index.xyxx, TEX0, RECT;\n"
				"MOVR R1.y, maxvalue.y;\n"
				"SGER H0.x, index.y, R1.y;\n"
				"MOVR R1.x, {-0.1}.x;\n"
				"SLTR H0.y, index.y, R1.x;\n"
				"ADDX H0.y, H0.x, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MOVR o[COLR], nothing.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:4:value\n"
				"##c:2:index\n"
				"##o:4:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat4_fp30 = &__valueAtfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __valueAtfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0.1, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"MOV r5.xy, c1;\n"
				"MAD r7.x, c0.x, r5.x, c0.z;\n"
				"MAD r7.y, c0.y, r5.y, c0.w;\n"
				"TEX r2, r7, texture[0], RECT;\n"
				"MOV r9.w, -c2.y;\n"
				"ADD r4.w, r9.w, c1.y;\n"
				"CMP r11.w, r4.w, c4.w, c4.x;\n"
				"MOV r5.w, c1.y;\n"
				"ADD r6.w, c4.y, r5.w;\n"
				"CMP r1.w, r6.w, c4.x, c4.w;\n"
				"ADD r8.w, r11.w, r1.w;\n"
				"CMP r10, -r8.w, c3.x, r2;\n"
				"MOV oC0, r10;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##c:4:value\n"
				"##c:2:index\n"
				"##o:4:output\n"
				"##c:2:maxvalue\n"
				"##c:1:nothing\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(4, 0)
				.constant(5, 0)
				.sampler(1, 0)
				.output(3, 0)
			)
		);
	static const void* __valueAtfloat4_arb = &__valueAtfloat4_arb_desc;
}

void __valueAtfloat4_cpu_inner (const __BrtArray2d<__BrtFloat4  > &value,
                                 const __BrtFloat2  &index,
                                 __BrtFloat4  &output,
                                 const __BrtFloat2  &maxvalue,
                                 const __BrtFloat1  &nothing){
  if (index.swizzle1(maskY) >= maxvalue.swizzle1(maskY) || index.swizzle1(maskY) < -__BrtFloat1(0.100000f))
    output = nothing;
  else
    output = value[index];
}
void  __valueAtfloat4_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtFloat2 *arg1 = (__BrtFloat2 *)args[1];
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __valueAtfloat4_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4);
    i++;
    ++arg2;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  valueAtfloat4 (::brook::stream value,
		const float2  index,
		::brook::stream output,
		const float2  maxvalue,
		const float  nothing) {
  static const void *__valueAtfloat4_fp[] = {
     "fp30", __valueAtfloat4_fp30,
     "arb", __valueAtfloat4_arb,
     "ps20", __valueAtfloat4_ps20,
     "cpu", (void *) __valueAtfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__valueAtfloat4_fp);

  k->PushGatherStream(value);
  k->PushConstant(index);
  k->PushOutput(output);
  k->PushConstant(maxvalue);
  k->PushConstant(nothing);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 0.5, 0.25, 0, -0.5\n"
				"    def c5, 1, 0, 0, 0.1\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c4.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c4.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c4.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c4.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c4.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c5.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, r3.w, c5.x, r2.w\n"
				"    mov r2.w, c5.x\n"
				"    cmp_pp r9.w, r9.w, c4.z, r2.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c4.z\n"
				"    rcp r4.w, r4.w\n"
				"    add r6.w, -r4.w, -r4.w\n"
				"    cmp r4.w, r6.w, -r4.w, r4.w\n"
				"    mov r2.w, c4.z\n"
				"    cmp_pp r4.w, -r4.w, c5.x, r2.w\n"
				"    rcp r1.w, r4.x\n"
				"    max r10.w, -r1.w, r1.w\n"
				"    cmp_pp r0.w, -r10.w, c5.x, r2.w\n"
				"    add_pp r2.x, r4.w, r0.w\n"
				"    mov r2.yzw, c4.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:4:value\n"
				"//oi:1:output\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat4_ps20 = &__NanToBoolRightfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.sign : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float sign : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, sign.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SNER H0.x, R0.x, {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.y, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.y, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0, 0, 0, 0};\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R1;\n"
				"SNER H0.y, R2.x, {0}.x;\n"
				"MULR R1.x, R2.x, {2}.x;\n"
				"SEQR H0.z, R2.x, R1.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MULR R1.x, R0.x, {2}.x;\n"
				"SEQR H0.z, R0.x, R1.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {1}.x;\n"
				"ADDR o[COLR].x, R0.x, R0.y;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat4_fp30 = &__NanToBoolRightfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToBoolRightfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {0.5, 0.25, 0, -0.5};\n"
				"PARAM c5 = {1, 0, 0, 0.1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c4.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c4.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c4.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c4.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c4.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c5.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, r3.w, r2.w, c5.x;\n"
				"MOV r2.w, c5.x;\n"
				"CMP r9.w, r9.w, r2.w, c4.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c4.z, r9.x;\n"
				"RCP r4.w, r4.w;\n"
				"ADD r6.w, -r4.w, -r4.w;\n"
				"CMP r4.w, r6.w, r4.w, -r4.w;\n"
				"MOV r2.w, c4.z;\n"
				"CMP r4.w, -r4.w, r2.w, c5.x;\n"
				"RCP r1.w, r4.x;\n"
				"MAX r10.w, -r1.w, r1.w;\n"
				"CMP r0.w, -r10.w, r2.w, c5.x;\n"
				"ADD r2.x, r4.w, r0.w;\n"
				"MOV r2.yzw, c4.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:value\n"
				"##oi:1:output\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToBoolRightfloat4_arb = &__NanToBoolRightfloat4_arb_desc;
}

void __NanToBoolRightfloat4_cpu_inner (const __BrtArray2d<__BrtFloat4  > &value,
                                        __BrtFloat1  &output,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat4  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,sign,maxvalue,nextPlaceToLook);
  __valueAtfloat4_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = (__isinf_cpu_inner(value[__indexof_output].swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0))) + (__isinf_cpu_inner(neighbor.swizzle1(maskX)).questioncolon(__BrtFloat1((float)1),__BrtFloat1((float)0)));
}
void  __NanToBoolRightfloat4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToBoolRightfloat4_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToBoolRightfloat4 (::brook::stream value,
		::brook::stream output,
		const float  sign,
		const float2  maxvalue) {
  static const void *__NanToBoolRightfloat4_fp[] = {
     "fp30", __NanToBoolRightfloat4_fp30,
     "arb", __NanToBoolRightfloat4_arb,
     "ps20", __NanToBoolRightfloat4_ps20,
     "cpu", (void *) __NanToBoolRightfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToBoolRightfloat4_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r9.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r4.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r9.w, r9.w, c5.z, r0.w\n"
				"    add_pp r9.w, r4.w, r9.w\n"
				"    cmp r4.w, -r9.w, r9.x, c5.z\n"
				"    add r11.w, r4.x, r4.w\n"
				"    add r6.w, r11.w, c5.x\n"
				"    frc r1.w, r6.w\n"
				"    add r7.x, r6.w, -r1.w\n"
				"    mov r7.yzw, c5.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:1:value\n"
				"//oi:1:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat4_ps20 = &__NanToRightfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1.x, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R2.x, R0.x, R2.x;\n"
				"ADDR R2.x, R2.x, {0.5}.x;\n"
				"FLRR o[COLR].x, R2.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat4_fp30 = &__NanToRightfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __NanToRightfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r9.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r4.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r9.w, r9.w, r0.w, c5.z;\n"
				"ADD r9.w, r4.w, r9.w;\n"
				"CMP r4.w, -r9.w, c5.z, r9.x;\n"
				"ADD r11.w, r4.x, r4.w;\n"
				"ADD r6.w, r11.w, c5.x;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r7.x, r6.w, -r1.w;\n"
				"MOV r7.yzw, c5.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:1:value\n"
				"##oi:1:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __NanToRightfloat4_arb = &__NanToRightfloat4_arb_desc;
}

void __NanToRightfloat4_cpu_inner (const __BrtArray2d<__BrtFloat1  > &value,
                                    __BrtFloat1  &output,
                                    const __BrtFloat1  &twotoi,
                                    const __BrtFloat2  &maxvalue,
                                    const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat1  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = __round_cpu_inner(value[__indexof_output] + neighbor);
}
void  __NanToRightfloat4_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __NanToRightfloat4_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  NanToRightfloat4 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__NanToRightfloat4_fp[] = {
     "fp30", __NanToRightfloat4_fp30,
     "arb", __NanToRightfloat4_arb,
     "ps20", __NanToRightfloat4_ps20,
     "cpu", (void *) __NanToRightfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__NanToRightfloat4_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, 1, 0, 0, 0.1\n"
				"    def c5, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    add r7.w, r7.x, c2.x\n"
				"    add r7.w, r7.w, c5.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c3.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c3.x\n"
				"    add r3.w, r8.w, c5.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c5.w\n"
				"    add r4.w, r0.w, c3.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c5.y\n"
				"    add r8.w, r6.w, -c3.x\n"
				"    cmp r3.x, r8.w, c5.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    mad r2.x, r7.x, c0.x, c0.z\n"
				"    mad r2.y, r7.y, c0.y, c0.w\n"
				"    texld r9, r0, s0\n"
				"    texld r4, r2, s0\n"
				"    add r3.w, r3.y, -c3.y\n"
				"    add r11.w, r3.y, c4.w\n"
				"    mov r0.w, c5.z\n"
				"    cmp_pp r6.w, r3.w, c4.x, r0.w\n"
				"    mov r0.w, c4.x\n"
				"    cmp_pp r1.w, r11.w, c5.z, r0.w\n"
				"    add_pp r8.w, r6.w, r1.w\n"
				"    cmp r10, -r8.w, r9, c5.z\n"
				"    add r5, r4, r10\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:4\n"
				"//c:4:value\n"
				"//oi:4:output\n"
				"//c:1:twotoi\n"
				"//c:2:maxvalue\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat4_ps20 = &__CountToRightfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.value : TEXUNIT0\n"
				"#semantic main.__gatherconst_value : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.twotoi : C2\n"
				"#semantic main.maxvalue : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var samplerRECT value[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_value : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var float twotoi : C2 :  : 5 : 1\n"
				"#var float2 maxvalue : C3 :  : 6 : 1\n"
				"#var float4 __workspace : C4 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE twotoi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"ADDR R0.w, R0.x, twotoi.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R1.x;\n"
				"ADDR R1.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"MOVR R2, {0, 0, 0, 0};\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2(GT.x), R1;\n"
				"ADDR o[COLR], R0, R2;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:value\n"
				"##oi:4:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat4_fp30 = &__CountToRightfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __CountToRightfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {1, 0, 0, 0.1};\n"
				"PARAM c5 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"ADD r7.w, r7.x, c2.x;\n"
				"ADD r7.w, r7.w, c5.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c3.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c3.x;\n"
				"ADD r3.w, r8.w, c5.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c5.w;\n"
				"ADD r4.w, r0.w, c3.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c5.y;\n"
				"ADD r8.w, r6.w, -c3.x;\n"
				"CMP r3.x, r8.w, r11.w, c5.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"MAD r2.x, r7.x, c0.x, c0.z;\n"
				"MAD r2.y, r7.y, c0.y, c0.w;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"TEX r4, r2, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c3.y;\n"
				"ADD r11.w, r3.y, c4.w;\n"
				"MOV r0.w, c5.z;\n"
				"CMP r6.w, r3.w, r0.w, c4.x;\n"
				"MOV r0.w, c4.x;\n"
				"CMP r1.w, r11.w, r0.w, c5.z;\n"
				"ADD r8.w, r6.w, r1.w;\n"
				"CMP r10, -r8.w, c5.z, r9;\n"
				"ADD r5, r4, r10;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:4\n"
				"##c:4:value\n"
				"##oi:4:output\n"
				"##c:1:twotoi\n"
				"##c:2:maxvalue\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, 0)
				.constant(4, 0)
				.sampler(1, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __CountToRightfloat4_arb = &__CountToRightfloat4_arb_desc;
}

void __CountToRightfloat4_cpu_inner (const __BrtArray2d<__BrtFloat4  > &value,
                                      __BrtFloat4  &output,
                                      const __BrtFloat1  &twotoi,
                                      const __BrtFloat2  &maxvalue,
                                      const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat4  neighbor;

  __getIndexAt_cpu_inner(__indexof_output,twotoi,maxvalue,nextPlaceToLook);
  __valueAtfloat4_cpu_inner(value,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  output = value[__indexof_output] + neighbor;
}
void  __CountToRightfloat4_cpu (const std::vector<void *>&args,
                                const std::vector<const unsigned int *>&extents,
                                const std::vector<unsigned int>&dims,
                                unsigned int mapbegin, 
                                unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __CountToRightfloat4_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  CountToRightfloat4 (::brook::stream value,
		::brook::stream output,
		const float  twotoi,
		const float2  maxvalue) {
  static const void *__CountToRightfloat4_fp[] = {
     "fp30", __CountToRightfloat4_fp30,
     "arb", __CountToRightfloat4_arb,
     "ps20", __CountToRightfloat4_ps20,
     "cpu", (void *) __CountToRightfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__CountToRightfloat4_fp);

  k->PushGatherStream(value);
  k->PushOutput(output);
  k->PushConstant(twotoi);
  k->PushConstant(maxvalue);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r3.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r3.w\n"
				"    mad r5.x, r3.x, c2.x, c2.z\n"
				"    mad r5.y, r3.y, c2.y, c2.w\n"
				"    mad r0.x, r3.x, c0.x, c0.z\n"
				"    mad r0.y, r3.y, c0.y, c0.w\n"
				"    texld r2, r5, s1\n"
				"    texld r9, r0, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r2.w, r3.y, c7.w\n"
				"    mov r0.w, c8.z\n"
				"    cmp_pp r9.w, r3.w, c7.x, r0.w\n"
				"    mov r0.w, c7.x\n"
				"    cmp_pp r2.w, r2.w, c8.z, r0.w\n"
				"    add_pp r2.w, r9.w, r2.w\n"
				"    cmp r4.w, -r2.w, r2.x, c8.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r8.w, -r11.w, r11.w\n"
				"    cmp_pp r10.w, -r8.w, c8.z, r0.w\n"
				"    cmp r5.w, -r2.w, r9.x, c8.z\n"
				"    add r3.w, r5.w, -c5.x\n"
				"    mov r2.w, -r5.w\n"
				"    abs r4.w, r3.w\n"
				"    mov r11.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r11.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r10.w, r6.w\n"
				"    mov r7.w, -c3.x\n"
				"    add r10.w, r7.w, c5.x\n"
				"    cmp r5.w, -r1.w, r10.w, c5.x\n"
				"    add r0.w, r2.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r3.w, c3.x, r4.w\n"
				"    cmp r2.x, r0.w, r5.w, r3.w\n"
				"    mov r2.yzw, c8.z\n"
				"    mov oC0, r2\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:4:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat4_ps20 = &__GatherGuessfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.x, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R2.y, {-0.1}.x;\n"
				"SGER H0.y, R2.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.x, R2.x, halfk.x;\n"
				"SEQR H0.z, R2.x, halfk.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R0.x, {0, 0, 0, 0};\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), R1;\n"
				"SNER H0.y, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR o[COLR].x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), halfk.x;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, -R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat4_fp30 = &__GatherGuessfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __GatherGuessfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r3.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r3.w;\n"
				"MAD r5.x, r3.x, c2.x, c2.z;\n"
				"MAD r5.y, r3.y, c2.y, c2.w;\n"
				"MAD r0.x, r3.x, c0.x, c0.z;\n"
				"MAD r0.y, r3.y, c0.y, c0.w;\n"
				"TEX r2, r5, texture[1], RECT;\n"
				"TEX r9, r0, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r2.w, r3.y, c7.w;\n"
				"MOV r0.w, c8.z;\n"
				"CMP r9.w, r3.w, r0.w, c7.x;\n"
				"MOV r0.w, c7.x;\n"
				"CMP r2.w, r2.w, r0.w, c8.z;\n"
				"ADD r2.w, r9.w, r2.w;\n"
				"CMP r4.w, -r2.w, c8.z, r2.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r8.w, -r11.w, r11.w;\n"
				"CMP r10.w, -r8.w, r0.w, c8.z;\n"
				"CMP r5.w, -r2.w, c8.z, r9.x;\n"
				"ADD r3.w, r5.w, -c5.x;\n"
				"MOV r2.w, -r5.w;\n"
				"ABS r4.w, r3.w;\n"
				"MOV r11.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r11.w, r4.w, c7.x;\n"
				"MUL r1.w, r10.w, r6.w;\n"
				"MOV r7.w, -c3.x;\n"
				"ADD r10.w, r7.w, c5.x;\n"
				"CMP r5.w, -r1.w, c5.x, r10.w;\n"
				"ADD r0.w, r2.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r3.w, c3.x, r4.w;\n"
				"CMP r2.x, r0.w, r3.w, r5.w;\n"
				"MOV r2.yzw, c8.z;\n"
				"MOV oC0, r2;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __GatherGuessfloat4_arb = &__GatherGuessfloat4_arb_desc;
}

void __GatherGuessfloat4_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat4  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &halfk,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __BrtFloat1  neighbor;
  __BrtFloat2  nextPlaceToLook;

  __getIndexAt_cpu_inner(__indexof_output,-sign * halfk,maxvalue,nextPlaceToLook);
  __valueAtfloat_cpu_inner(scatterindex,nextPlaceToLook,neighbor,maxvalue,__BrtFloat1((float)0));
  if (neighbor > halfk)
  {
    output = halfk + twotologkminusi;
  }

  else
  {
    __BrtFloat4  actualValue;

    __valueAtfloat4_cpu_inner(value,nextPlaceToLook,actualValue,maxvalue,__BrtFloat1((float)0));
    if (neighbor == halfk && !__isinf_cpu_inner(actualValue.swizzle1(maskX)))
    {
      output = halfk;
    }

    else
    {
      output = halfk - twotologkminusi;
    }

  }

}
void  __GatherGuessfloat4_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __GatherGuessfloat4_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  GatherGuessfloat4 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__GatherGuessfloat4_fp[] = {
     "fp30", __GatherGuessfloat4_fp30,
     "arb", __GatherGuessfloat4_arb,
     "ps20", __GatherGuessfloat4_ps20,
     "cpu", (void *) __GatherGuessfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__GatherGuessfloat4_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 1, 0, 0, 0.1\n"
				"    def c8, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mov r0.w, -c6.x\n"
				"    mad r7.x, t0.x, c1.x, c1.z\n"
				"    mad r7.y, t0.y, c1.y, c1.w\n"
				"    mad r7.w, r0.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c8.x\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c4.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r1.w, r6.w\n"
				"    mul r8.w, r1.w, c4.x\n"
				"    add r3.w, r8.w, c8.x\n"
				"    frc r10.w, r3.w\n"
				"    add r0.w, r3.w, -r10.w\n"
				"    add r9.w, -r0.w, c8.w\n"
				"    add r4.w, r0.w, c4.x\n"
				"    cmp r11.w, r9.w, r4.w, r0.w\n"
				"    add r6.w, r11.w, c8.y\n"
				"    add r8.w, r6.w, -c4.x\n"
				"    cmp r3.x, r8.w, c8.z, r11.w\n"
				"    frc r3.w, r7.w\n"
				"    add r7.w, r7.w, -r3.w\n"
				"    add r3.y, r7.y, r7.w\n"
				"    mad r2.x, r3.x, c2.x, c2.z\n"
				"    mad r2.y, r3.y, c2.y, c2.w\n"
				"    mad r9.x, r3.x, c0.x, c0.z\n"
				"    mad r9.y, r3.y, c0.y, c0.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    texld r11, r2, s1\n"
				"    texld r6, r9, s0\n"
				"    texld r1, r4, s0\n"
				"    add r3.w, r3.y, -c4.y\n"
				"    add r11.w, r3.y, c7.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r6.w, r3.w, c7.x, r4.w\n"
				"    mov r4.w, c7.x\n"
				"    cmp_pp r11.w, r11.w, c8.z, r4.w\n"
				"    add_pp r11.w, r6.w, r11.w\n"
				"    cmp r1.w, -r11.w, r11.x, c8.z\n"
				"    rcp r1.w, r1.w\n"
				"    add r7.w, -r1.w, -r1.w\n"
				"    cmp r1.w, r7.w, -r1.w, r1.w\n"
				"    cmp_pp r1.w, -r1.w, c8.z, r4.w\n"
				"    cmp r10.w, -r11.w, r6.x, c8.z\n"
				"    add r0.w, r10.w, -c5.x\n"
				"    abs r4.w, r0.w\n"
				"    mov r3.w, -r4.w\n"
				"    mov r4.w, c8.z\n"
				"    cmp_pp r11.w, r3.w, c7.x, r4.w\n"
				"    mul_pp r1.w, r1.w, r11.w\n"
				"    mov r6.w, -c3.x\n"
				"    add r8.w, r6.w, c5.x\n"
				"    cmp r1.w, -r1.w, r8.w, c5.x\n"
				"    add r7.w, -r10.w, c5.x\n"
				"    mov r4.w, c5.x\n"
				"    add r10.w, c3.x, r4.w\n"
				"    cmp r1.w, r7.w, r1.w, r10.w\n"
				"    abs r0.w, r1.x\n"
				"    cmp r9.x, -r0.w, c8.z, r1.w\n"
				"    mov r9.yzw, c8.z\n"
				"    mov oC0, r9\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:4:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//c:1:halfk\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat4_ps20 = &__EstablishGuessfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.halfk : C5\n"
				"#semantic main.sign : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var float halfk : C5 :  : 9 : 1\n"
				"#var float sign : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE halfk;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, halfk.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R0.x, R0.xyxx, TEX0, RECT;\n"
				"SEQR H0.x, R0.x, {0}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H1.x, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H1.y, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H1.y, R0.x, {-0.5}.x;\n"
				"MULX H1.y, H0.y, H1.y;\n"
				"MOVR R2.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"ADDR R0.x, R2.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MULX H0.y, H0.z, H0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SLTR H0.y, R2.y, {-0.1}.x;\n"
				"SGER H0.z, R2.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"SLTR H0.z, R2.y, {-0.1}.x;\n"
				"SGER H0.w, R2.y, maxvalue.y;\n"
				"ADDX H0.z, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"TEX R0.x, R2.xyxx, TEX0, RECT;\n"
				"TEX R1, R2.xyxx, TEX1, RECT;\n"
				"MOVR R2.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), R0.x;\n"
				"SGTR H0.y, R2.x, halfk.x;\n"
				"SEQR H0.w, R2.x, halfk.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H1.x, H0.y;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, {0, 0, 0, 0};\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R1;\n"
				"SNER H0.z, R0.x, {0}.x;\n"
				"MULR R0.y, R0.x, {2}.x;\n"
				"SEQR H1.x, R0.x, R0.y;\n"
				"MADX H0.z, -H1.x, H0.z, {1}.x;\n"
				"MULX H1.x, H0.w, H0.z;\n"
				"MADX H0.z, -H0.w, H0.z, {1}.x;\n"
				"MULX H1.x, H0.y, H1.x;\n"
				"MULX H0.z, H0.y, H0.z;\n"
				"MOVR R0.x, twotologkminusi.x;\n"
				"ADDR R0.x, halfk.x, R0.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R0.x(GT.x), halfk.x;\n"
				"MOVR R0.y, twotologkminusi.x;\n"
				"ADDR R0.y, halfk.x, -R0.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R0.x(GT.x), R0.y;\n"
				"MOVR o[COLR].x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat4_fp30 = &__EstablishGuessfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __EstablishGuessfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {1, 0, 0, 0.1};\n"
				"PARAM c8 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MOV r0.w, -c6.x;\n"
				"MAD r7.x, t0.x, c1.x, c1.z;\n"
				"MAD r7.y, t0.y, c1.y, c1.w;\n"
				"MAD r7.w, r0.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c8.x;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c4.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r1.w, r6.w;\n"
				"MUL r8.w, r1.w, c4.x;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"FRC r10.w, r3.w;\n"
				"ADD r0.w, r3.w, -r10.w;\n"
				"ADD r9.w, -r0.w, c8.w;\n"
				"ADD r4.w, r0.w, c4.x;\n"
				"CMP r11.w, r9.w, r0.w, r4.w;\n"
				"ADD r6.w, r11.w, c8.y;\n"
				"ADD r8.w, r6.w, -c4.x;\n"
				"CMP r3.x, r8.w, r11.w, c8.z;\n"
				"FRC r3.w, r7.w;\n"
				"ADD r7.w, r7.w, -r3.w;\n"
				"ADD r3.y, r7.y, r7.w;\n"
				"MAD r2.x, r3.x, c2.x, c2.z;\n"
				"MAD r2.y, r3.y, c2.y, c2.w;\n"
				"MAD r9.x, r3.x, c0.x, c0.z;\n"
				"MAD r9.y, r3.y, c0.y, c0.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"TEX r11, r2, texture[1], RECT;\n"
				"TEX r6, r9, texture[0], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"ADD r3.w, r3.y, -c4.y;\n"
				"ADD r11.w, r3.y, c7.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r6.w, r3.w, r4.w, c7.x;\n"
				"MOV r4.w, c7.x;\n"
				"CMP r11.w, r11.w, r4.w, c8.z;\n"
				"ADD r11.w, r6.w, r11.w;\n"
				"CMP r1.w, -r11.w, c8.z, r11.x;\n"
				"RCP r1.w, r1.w;\n"
				"ADD r7.w, -r1.w, -r1.w;\n"
				"CMP r1.w, r7.w, r1.w, -r1.w;\n"
				"CMP r1.w, -r1.w, r4.w, c8.z;\n"
				"CMP r10.w, -r11.w, c8.z, r6.x;\n"
				"ADD r0.w, r10.w, -c5.x;\n"
				"ABS r4.w, r0.w;\n"
				"MOV r3.w, -r4.w;\n"
				"MOV r4.w, c8.z;\n"
				"CMP r11.w, r3.w, r4.w, c7.x;\n"
				"MUL r1.w, r1.w, r11.w;\n"
				"MOV r6.w, -c3.x;\n"
				"ADD r8.w, r6.w, c5.x;\n"
				"CMP r1.w, -r1.w, c5.x, r8.w;\n"
				"ADD r7.w, -r10.w, c5.x;\n"
				"MOV r4.w, c5.x;\n"
				"ADD r10.w, c3.x, r4.w;\n"
				"CMP r1.w, r7.w, r10.w, r1.w;\n"
				"ABS r0.w, r1.x;\n"
				"CMP r9.x, -r0.w, r1.w, c8.z;\n"
				"MOV r9.yzw, c8.z;\n"
				"MOV oC0, r9;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##c:1:halfk\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __EstablishGuessfloat4_arb = &__EstablishGuessfloat4_arb_desc;
}

void __EstablishGuessfloat4_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                        __BrtFloat1  &output,
                                        const __BrtArray2d<__BrtFloat4  > &value,
                                        const __BrtFloat1  &twotologkminusi,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &halfk,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat4 &__indexof_output){
  if (scatterindex[__indexof_output] == __BrtFloat1((float)0))
  {
    output = __BrtFloat1((float)0);
  }

  else
  {
    __GatherGuessfloat4_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,halfk,sign,__indexof_output);
  }

}
void  __EstablishGuessfloat4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __EstablishGuessfloat4_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
    }
  }
}

void  EstablishGuessfloat4 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		const float  halfk,
		const float  sign) {
  static const void *__EstablishGuessfloat4_fp[] = {
     "fp30", __EstablishGuessfloat4_fp30,
     "arb", __EstablishGuessfloat4_arb,
     "ps20", __EstablishGuessfloat4_ps20,
     "cpu", (void *) __EstablishGuessfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__EstablishGuessfloat4_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushConstant(halfk);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 1, 0, 0, 0.1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    texld r0, t1, s2\n"
				"    mad r2.x, t0.x, c1.x, c1.z\n"
				"    mad r2.y, t0.y, c1.y, c1.w\n"
				"    mad r2.w, r0.x, -c5.x, r2.x\n"
				"    add r2.w, r2.w, c7.x\n"
				"    frc r0.w, r2.w\n"
				"    add r0.w, r2.w, -r0.w\n"
				"    rcp r9.w, c4.x\n"
				"    mul r0.w, r0.w, r9.w\n"
				"    mul r2.w, r2.w, r9.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    add r0.w, r0.w, c7.x\n"
				"    frc r4.w, r0.w\n"
				"    add r0.w, r0.w, -r4.w\n"
				"    add r1.w, -r0.w, c7.w\n"
				"    add r8.w, r0.w, c4.x\n"
				"    cmp r0.w, r1.w, r8.w, r0.w\n"
				"    add r3.w, r0.w, c7.y\n"
				"    add r5.w, r3.w, -c4.x\n"
				"    cmp r7.x, r5.w, c7.z, r0.w\n"
				"    frc r7.w, r2.w\n"
				"    add r7.w, r2.w, -r7.w\n"
				"    add r7.y, r2.y, r7.w\n"
				"    mad r4.x, r7.x, c0.x, c0.z\n"
				"    mad r4.y, r7.y, c0.y, c0.w\n"
				"    mad r11.x, r7.x, c2.x, c2.z\n"
				"    mad r11.y, r7.y, c2.y, c2.w\n"
				"    texld r6, r4, s0\n"
				"    texld r1, r11, s1\n"
				"    add r7.w, r7.y, -c4.y\n"
				"    add r6.w, r7.y, c6.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r1.w, r7.w, c6.x, r11.w\n"
				"    mov r11.w, c6.x\n"
				"    cmp_pp r6.w, r6.w, c7.z, r11.w\n"
				"    add_pp r6.w, r1.w, r6.w\n"
				"    cmp r0.w, -r6.w, r6.x, c7.z\n"
				"    add r3.w, r0.w, -r0.x\n"
				"    abs r5.w, r3.w\n"
				"    mov r11.w, c7.z\n"
				"    cmp_pp r2.w, -r5.w, c6.x, r11.w\n"
				"    cmp r4.w, -r6.w, r1.x, c7.z\n"
				"    rcp r11.w, r4.w\n"
				"    max r1.w, -r11.w, r11.w\n"
				"    mov r8.w, -r1.w\n"
				"    mov r1.w, c6.x\n"
				"    cmp_pp r3.w, r8.w, c7.z, r1.w\n"
				"    mul_pp r10.w, r2.w, r3.w\n"
				"    add r2.w, r0.x, -c3.x\n"
				"    cmp r4.w, -r10.w, r2.w, r0.x\n"
				"    add r0.w, r0.x, -r0.w\n"
				"    add r11.w, r0.x, c3.x\n"
				"    cmp r7.x, r0.w, r4.w, r11.w\n"
				"    mov r7.yzw, c7.z\n"
				"    mov oC0, r7\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:1:scatterindex\n"
				"//oi:1:output\n"
				"//c:4:value\n"
				"//c:1:twotologkminusi\n"
				"//c:2:maxvalue\n"
				"//s:1:lastguess\n"
				"//c:1:sign\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat4_ps20 = &__UpdateGuessfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.scatterindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_scatterindex : C0\n"
				"#semantic main._const_output_invscalebias : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main.twotologkminusi : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main._tex_lastguess : TEXUNIT2\n"
				"#semantic main.sign : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT scatterindex[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_scatterindex : C0 :  : 1 : 1\n"
				"#var float4 _const_output_invscalebias : C1 :  : 3 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var float twotologkminusi : C3 :  : 7 : 1\n"
				"#var float2 maxvalue : C4 :  : 8 : 1\n"
				"#var samplerRECT _tex_lastguess : TEXUNIT2 : texunit 2 : 9 : 1\n"
				"#var float sign : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 4 : 1\n"
				"#var float2 _tex_lastguess_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_scatterindex;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE twotologkminusi;\n"
				"DECLARE maxvalue;\n"
				"DECLARE sign;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"MADR R1.w, -sign.x, R0.x, R1.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxvalue.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.y, maxvalue.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxvalue.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.x, R1.x, {-0.5}.x;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.x, R1.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SLTR H0.x, R3.y, {-0.1}.x;\n"
				"SGER H0.y, R3.y, maxvalue.y;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SLTR H0.y, R3.y, {-0.1}.x;\n"
				"SGER H0.z, R3.y, maxvalue.y;\n"
				"ADDX H0.y, H0.z, H0.y;\n"
				"MINX H0.y, H0.y, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"TEX R1.x, R3.xyxx, TEX0, RECT;\n"
				"TEX R2, R3.xyxx, TEX1, RECT;\n"
				"MOVR R3.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"SGTR H0.x, R3.x, R0.x;\n"
				"SEQR H0.z, R3.x, R0.x;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"MULX H0.y, H0.w, H0.y;\n"
				"ADDX H0.w, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, {0, 0, 0, 0};\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.x(GT.x), R2;\n"
				"SNER H0.y, R1.x, {0}.x;\n"
				"MULR R1.y, R1.x, {2}.x;\n"
				"SEQR H1.x, R1.x, R1.y;\n"
				"MADX H0.y, -H1.x, H0.y, {1}.x;\n"
				"MULX H1.x, H0.z, H0.y;\n"
				"MULX H1.x, H0.w, H1.x;\n"
				"MADX H0.y, -H0.z, H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"ADDR o[COLR].x, R0.x, twotologkminusi.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"ADDR R0.x, R0.x, -twotologkminusi.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR].x(GT.x), R0.x;\n"
				"MOVR o[COLR].yzw, {0, 0, 0, 0}.yyzw;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat4_fp30 = &__UpdateGuessfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __UpdateGuessfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {1, 0, 0, 0.1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[2], RECT;\n"
				"MAD r2.x, t0.x, c1.x, c1.z;\n"
				"MAD r2.y, t0.y, c1.y, c1.w;\n"
				"MAD r2.w, r0.x, -c5.x, r2.x;\n"
				"ADD r2.w, r2.w, c7.x;\n"
				"FRC r0.w, r2.w;\n"
				"ADD r0.w, r2.w, -r0.w;\n"
				"RCP r9.w, c4.x;\n"
				"MUL r0.w, r0.w, r9.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"ADD r0.w, r0.w, c7.x;\n"
				"FRC r4.w, r0.w;\n"
				"ADD r0.w, r0.w, -r4.w;\n"
				"ADD r1.w, -r0.w, c7.w;\n"
				"ADD r8.w, r0.w, c4.x;\n"
				"CMP r0.w, r1.w, r0.w, r8.w;\n"
				"ADD r3.w, r0.w, c7.y;\n"
				"ADD r5.w, r3.w, -c4.x;\n"
				"CMP r7.x, r5.w, r0.w, c7.z;\n"
				"FRC r7.w, r2.w;\n"
				"ADD r7.w, r2.w, -r7.w;\n"
				"ADD r7.y, r2.y, r7.w;\n"
				"MAD r4.x, r7.x, c0.x, c0.z;\n"
				"MAD r4.y, r7.y, c0.y, c0.w;\n"
				"MAD r11.x, r7.x, c2.x, c2.z;\n"
				"MAD r11.y, r7.y, c2.y, c2.w;\n"
				"TEX r6, r4, texture[0], RECT;\n"
				"TEX r1, r11, texture[1], RECT;\n"
				"ADD r7.w, r7.y, -c4.y;\n"
				"ADD r6.w, r7.y, c6.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r1.w, r7.w, r11.w, c6.x;\n"
				"MOV r11.w, c6.x;\n"
				"CMP r6.w, r6.w, r11.w, c7.z;\n"
				"ADD r6.w, r1.w, r6.w;\n"
				"CMP r0.w, -r6.w, c7.z, r6.x;\n"
				"ADD r3.w, r0.w, -r0.x;\n"
				"ABS r5.w, r3.w;\n"
				"MOV r11.w, c7.z;\n"
				"CMP r2.w, -r5.w, r11.w, c6.x;\n"
				"CMP r4.w, -r6.w, c7.z, r1.x;\n"
				"RCP r11.w, r4.w;\n"
				"MAX r1.w, -r11.w, r11.w;\n"
				"MOV r8.w, -r1.w;\n"
				"MOV r1.w, c6.x;\n"
				"CMP r3.w, r8.w, r1.w, c7.z;\n"
				"MUL r10.w, r2.w, r3.w;\n"
				"ADD r2.w, r0.x, -c3.x;\n"
				"CMP r4.w, -r10.w, r0.x, r2.w;\n"
				"ADD r0.w, r0.x, -r0.w;\n"
				"ADD r11.w, r0.x, c3.x;\n"
				"CMP r7.x, r0.w, r11.w, r4.w;\n"
				"MOV r7.yzw, c7.z;\n"
				"MOV oC0, r7;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:1:scatterindex\n"
				"##oi:1:output\n"
				"##c:4:value\n"
				"##c:1:twotologkminusi\n"
				"##c:2:maxvalue\n"
				"##s:1:lastguess\n"
				"##c:1:sign\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
		);
	static const void* __UpdateGuessfloat4_arb = &__UpdateGuessfloat4_arb_desc;
}

void __UpdateGuessfloat4_cpu_inner (const __BrtArray2d<__BrtFloat1  > &scatterindex,
                                     __BrtFloat1  &output,
                                     const __BrtArray2d<__BrtFloat4  > &value,
                                     const __BrtFloat1  &twotologkminusi,
                                     const __BrtFloat2  &maxvalue,
                                     const __BrtFloat1  &lastguess,
                                     const __BrtFloat1  &sign,
                                     const __BrtFloat4 &__indexof_output){
  __GatherGuessfloat4_cpu_inner(scatterindex,output,value,twotologkminusi,maxvalue,lastguess,sign,__indexof_output);
}
void  __UpdateGuessfloat4_cpu (const std::vector<void *>&args,
                               const std::vector<const unsigned int *>&extents,
                               const std::vector<unsigned int>&dims,
                               unsigned int mapbegin, 
                               unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[1];
  unsigned int newline=extents[1][dim-1];
  arg1+=mapbegin;
  unsigned int ratio5 = extents[1][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[1][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[1]);
  ;
__BrtFloat4 indexof1 = computeIndexOf(mapbegin, extents[1], dims[1], extents[1]);
  unsigned int i=0; 
  while (i<mapextent) {
    __UpdateGuessfloat4_cpu_inner (
      arg0,
      *arg1,
      arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof1);
    i++;
    ++arg1;
indexof1.unsafeGetAt(0)++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      indexof1 = computeReferenceIndexOf(i+mapbegin, extents[1],dim);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[1]);
    }
  }
}

void  UpdateGuessfloat4 (::brook::stream scatterindex,
		::brook::stream output,
		::brook::stream value,
		const float  twotologkminusi,
		const float2  maxvalue,
		::brook::stream lastguess,
		const float  sign) {
  static const void *__UpdateGuessfloat4_fp[] = {
     "fp30", __UpdateGuessfloat4_fp30,
     "arb", __UpdateGuessfloat4_arb,
     "ps20", __UpdateGuessfloat4_ps20,
     "cpu", (void *) __UpdateGuessfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__UpdateGuessfloat4_fp);

  k->PushGatherStream(scatterindex);
  k->PushOutput(output);
  k->PushGatherStream(value);
  k->PushConstant(twotologkminusi);
  k->PushConstant(maxvalue);
  k->PushStream(lastguess);
  k->PushConstant(sign);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.0625, 1.0625, 0, 1\n"
				"    def c7, 0.5, 0.25, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    mad r7.x, t0.x, c0.x, c0.z\n"
				"    mad r7.y, t0.y, c0.y, c0.w\n"
				"    mad r9.x, r7.x, c1.x, c1.z\n"
				"    mad r9.y, r7.y, c1.y, c1.w\n"
				"    texld r4, r9, s0\n"
				"    mov r7.w, -c3.x\n"
				"    mad r6.w, r4.x, r7.w, r7.x\n"
				"    add r1.w, r6.w, c7.x\n"
				"    frc r8.w, r1.w\n"
				"    add r10.w, r1.w, -r8.w\n"
				"    rcp r5.w, c4.x\n"
				"    mul r0.w, r10.w, r5.w\n"
				"    frc r2.w, r0.w\n"
				"    mul r9.w, r2.w, c4.x\n"
				"    add r4.w, r9.w, c7.x\n"
				"    frc r11.w, r4.w\n"
				"    add r8.w, r4.w, -r11.w\n"
				"    add r10.w, -r8.w, c7.w\n"
				"    add r0.w, r8.w, c4.x\n"
				"    cmp r2.w, r10.w, r0.w, r8.w\n"
				"    add r9.w, r2.w, c7.y\n"
				"    add r11.w, r9.w, -c4.x\n"
				"    cmp r1.x, r11.w, c7.z, r2.w\n"
				"    mul r1.w, r1.w, r5.w\n"
				"    frc r6.w, r1.w\n"
				"    add r1.w, r1.w, -r6.w\n"
				"    add r1.y, r7.y, r1.w\n"
				"    mad r5.x, r1.x, c2.x, c2.z\n"
				"    mad r5.y, r1.y, c2.y, c2.w\n"
				"    texld r3, r5, s1\n"
				"    texld r10, t1, s2\n"
				"    mad r7.w, r7.w, c5.x, r7.x\n"
				"    add r7.w, r7.w, c7.x\n"
				"    mul r10.w, r5.w, r7.w\n"
				"    frc r0.w, r10.w\n"
				"    add r10.w, r10.w, -r0.w\n"
				"    add r4.y, r7.y, r10.w\n"
				"    frc r10.w, r7.w\n"
				"    add r10.w, r7.w, -r10.w\n"
				"    mul r10.w, r10.w, r5.w\n"
				"    frc r10.w, r10.w\n"
				"    mul r10.w, r10.w, c4.x\n"
				"    add r10.w, r10.w, c7.x\n"
				"    frc r9.w, r10.w\n"
				"    add r10.w, r10.w, -r9.w\n"
				"    add r8.w, -r10.w, c7.w\n"
				"    add r1.w, r10.w, c4.x\n"
				"    cmp r10.w, r8.w, r1.w, r10.w\n"
				"    add r4.w, -c4.x, r10.w\n"
				"    add r4.w, r4.w, c7.y\n"
				"    cmp r4.x, r4.w, c7.z, r10.w\n"
				"    add r7.xy, r4, -c4\n"
				"    add r7.w, r7.y, c6.y\n"
				"    mov r1.w, c7.z\n"
				"    cmp_pp r7.w, r7.w, c6.w, r1.w\n"
				"    add r10.w, r7.x, c6.x\n"
				"    add r0.w, r7.y, c6.x\n"
				"    cmp_pp r10.w, r10.w, c6.w, r1.w\n"
				"    mul r10.w, r7.w, r10.w\n"
				"    cmp_pp r2.w, r0.w, c6.w, r1.w\n"
				"    add_pp r10.w, r10.w, r2.w\n"
				"    cmp r3, -r10.w, r3, r10.x\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:4:output\n"
				"//c:1:gatherindex\n"
				"//c:4:value\n"
				"//s:1:inf\n"
				"//c:1:sign\n"
				"//c:2:maxvalue\n"
				"//c:1:maxshift\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat4_ps20 = &__RelativeGatherfloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_output_invscalebias : C0\n"
				"#semantic main.gatherindex : TEXUNIT0\n"
				"#semantic main.__gatherconst_gatherindex : C1\n"
				"#semantic main.value : TEXUNIT1\n"
				"#semantic main.__gatherconst_value : C2\n"
				"#semantic main._tex_inf : TEXUNIT2\n"
				"#semantic main.sign : C3\n"
				"#semantic main.maxvalue : C4\n"
				"#semantic main.maxshift : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var float4 _const_output_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT gatherindex[0] : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var float4 __gatherconst_gatherindex : C1 :  : 4 : 1\n"
				"#var samplerRECT value[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_value : C2 :  : 6 : 1\n"
				"#var samplerRECT _tex_inf : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float sign : C3 :  : 9 : 1\n"
				"#var float2 maxvalue : C4 :  : 10 : 1\n"
				"#var float maxshift : C5 :  : 11 : 1\n"
				"#var float4 __workspace : C6 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_inf_pos : $vin.TEXCOORD1 : TEX1 : 8 : 1\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __gatherconst_gatherindex;\n"
				"DECLARE __gatherconst_value;\n"
				"DECLARE sign;\n"
				"DECLARE maxvalue;\n"
				"DECLARE maxshift;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX1].xyxx, TEX2, RECT;\n"
				"MOVR o[COLR], R0.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R0.w, maxshift.x;\n"
				"MADR R0.w, -sign.x, R0.w, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R2.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R2.y, R0.w;\n"
				"TEX R1.x, R0.xyxx, TEX0, RECT;\n"
				"MADR R0.w, -sign.x, R1.x, R0.x;\n"
				"ADDR R1.x, {0.5}.x, R0.w;\n"
				"MOVR R3.x, R0.w;\n"
				"RCPR R0.w, maxvalue.x;\n"
				"MULR R0.w, R1.x, R0.w;\n"
				"FLRR R0.w, R0.w;\n"
				"ADDR R0.w, R0.y, R0.w;\n"
				"MOVR R3.y, R0.w;\n"
				"ADDR R0.x, R2.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"ADDR R0.x, R3.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLTR H0.y, R0.x, {0}.x;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"ADDR R0.z, R0.z, {0.5}.x;\n"
				"FLRR R0.z, R0.z;\n"
				"SLER H0.x, R0.z, {-0.5}.x;\n"
				"RCPR R0.y, maxvalue.x;\n"
				"MULR R0.y, R0.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |maxvalue.x|;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, {0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SLER H0.y, R0.x, {-0.5}.x;\n"
				"MOVR R2.x, R0.z;\n"
				"ADDR R0.z, R0.z, maxvalue.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), R0.z;\n"
				"ADDR R0.y, R2.x, {0.25}.x;\n"
				"SGER H0.x, R0.y, maxvalue.x;\n"
				"MOVR R3.x, R0.x;\n"
				"ADDR R0.x, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"ADDR R2.xy, R2.xyxx, -maxvalue.xyxx;\n"
				"SGER H0.x, R2.y, {-0.0625}.x;\n"
				"SGER H0.y, R2.x, {-0.0625}.x;\n"
				"SGER H0.z, R2.y, {-1.0625}.x;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDR R0.x, R3.x, {0.25}.x;\n"
				"SGER H0.y, R0.x, maxvalue.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"TEX R0, R3.xyxx, TEX1, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:4:output\n"
				"##c:1:gatherindex\n"
				"##c:4:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat4_fp30 = &__RelativeGatherfloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __RelativeGatherfloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.0625, 1.0625, 0, 1};\n"
				"PARAM c7 = {0.5, 0.25, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, r7.x, c1.x, c1.z;\n"
				"MAD r9.y, r7.y, c1.y, c1.w;\n"
				"TEX r4, r9, texture[0], RECT;\n"
				"MOV r7.w, -c3.x;\n"
				"MAD r6.w, r4.x, r7.w, r7.x;\n"
				"ADD r1.w, r6.w, c7.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r10.w, r1.w, -r8.w;\n"
				"RCP r5.w, c4.x;\n"
				"MUL r0.w, r10.w, r5.w;\n"
				"FRC r2.w, r0.w;\n"
				"MUL r9.w, r2.w, c4.x;\n"
				"ADD r4.w, r9.w, c7.x;\n"
				"FRC r11.w, r4.w;\n"
				"ADD r8.w, r4.w, -r11.w;\n"
				"ADD r10.w, -r8.w, c7.w;\n"
				"ADD r0.w, r8.w, c4.x;\n"
				"CMP r2.w, r10.w, r8.w, r0.w;\n"
				"ADD r9.w, r2.w, c7.y;\n"
				"ADD r11.w, r9.w, -c4.x;\n"
				"CMP r1.x, r11.w, r2.w, c7.z;\n"
				"MUL r1.w, r1.w, r5.w;\n"
				"FRC r6.w, r1.w;\n"
				"ADD r1.w, r1.w, -r6.w;\n"
				"ADD r1.y, r7.y, r1.w;\n"
				"MAD r5.x, r1.x, c2.x, c2.z;\n"
				"MAD r5.y, r1.y, c2.y, c2.w;\n"
				"TEX r3, r5, texture[1], RECT;\n"
				"TEX r10, t1, texture[2], RECT;\n"
				"MAD r7.w, r7.w, c5.x, r7.x;\n"
				"ADD r7.w, r7.w, c7.x;\n"
				"MUL r10.w, r5.w, r7.w;\n"
				"FRC r0.w, r10.w;\n"
				"ADD r10.w, r10.w, -r0.w;\n"
				"ADD r4.y, r7.y, r10.w;\n"
				"FRC r10.w, r7.w;\n"
				"ADD r10.w, r7.w, -r10.w;\n"
				"MUL r10.w, r10.w, r5.w;\n"
				"FRC r10.w, r10.w;\n"
				"MUL r10.w, r10.w, c4.x;\n"
				"ADD r10.w, r10.w, c7.x;\n"
				"FRC r9.w, r10.w;\n"
				"ADD r10.w, r10.w, -r9.w;\n"
				"ADD r8.w, -r10.w, c7.w;\n"
				"ADD r1.w, r10.w, c4.x;\n"
				"CMP r10.w, r8.w, r10.w, r1.w;\n"
				"ADD r4.w, -c4.x, r10.w;\n"
				"ADD r4.w, r4.w, c7.y;\n"
				"CMP r4.x, r4.w, r10.w, c7.z;\n"
				"ADD r7.xy, r4, -c4;\n"
				"ADD r7.w, r7.y, c6.y;\n"
				"MOV r1.w, c7.z;\n"
				"CMP r7.w, r7.w, r1.w, c6.w;\n"
				"ADD r10.w, r7.x, c6.x;\n"
				"ADD r0.w, r7.y, c6.x;\n"
				"CMP r10.w, r10.w, r1.w, c6.w;\n"
				"MUL r10.w, r7.w, r10.w;\n"
				"CMP r2.w, r0.w, r1.w, c6.w;\n"
				"ADD r10.w, r10.w, r2.w;\n"
				"CMP r3, -r10.w, r10.x, r3;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:4:output\n"
				"##c:1:gatherindex\n"
				"##c:4:value\n"
				"##s:1:inf\n"
				"##c:1:sign\n"
				"##c:2:maxvalue\n"
				"##c:1:maxshift\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(4, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __RelativeGatherfloat4_arb = &__RelativeGatherfloat4_arb_desc;
}

void __RelativeGatherfloat4_cpu_inner (__BrtFloat4  &output,
                                        const __BrtArray2d<__BrtFloat1  > &gatherindex,
                                        const __BrtArray2d<__BrtFloat4  > &value,
                                        const __BrtFloat1  &inf,
                                        const __BrtFloat1  &sign,
                                        const __BrtFloat2  &maxvalue,
                                        const __BrtFloat1  &maxshift,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  nextPlaceToLook;
  __BrtFloat2  isoffedge;

  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * gatherindex[__indexof_output],maxvalue,nextPlaceToLook);
  __getIndexAt_cpu_inner(__indexof_output,-sign.swizzle1(maskX) * maxshift,maxvalue,isoffedge);
  isoffedge -= maxvalue;
  if (isoffedge.swizzle1(maskY) >= -__BrtFloat1(0.062500f) || isoffedge.swizzle1(maskY) >= -__BrtFloat1(1.062500f) && isoffedge.swizzle1(maskX) >= -__BrtFloat1(0.062500f))
  {
    output = inf;
  }

  else
  {
    output = value[nextPlaceToLook];
  }

}
void  __RelativeGatherfloat4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtFloat4 *arg0 = (__BrtFloat4 *)args[0];
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio3 = extents[0][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[0][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __RelativeGatherfloat4_cpu_inner (
      *arg0,
      arg1,
      arg2,
      *(arg3 + iter3),
      *arg4,
      *arg5,
      *arg6,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[0]);
    }
  }
}

void  RelativeGatherfloat4 (::brook::stream output,
		::brook::stream gatherindex,
		::brook::stream value,
		::brook::stream inf,
		const float  sign,
		const float2  maxvalue,
		const float  maxshift) {
  static const void *__RelativeGatherfloat4_fp[] = {
     "fp30", __RelativeGatherfloat4_fp30,
     "arb", __RelativeGatherfloat4_arb,
     "ps20", __RelativeGatherfloat4_ps20,
     "cpu", (void *) __RelativeGatherfloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__RelativeGatherfloat4_fp);

  k->PushOutput(output);
  k->PushGatherStream(gatherindex);
  k->PushGatherStream(value);
  k->PushStream(inf);
  k->PushConstant(sign);
  k->PushConstant(maxvalue);
  k->PushConstant(maxshift);
  k->Map();

}


float  shiftValuesfloat4(::brook::stream list_stream, ::brook::stream (*output_stream), int  WIDTH, int  LENGTH, int  sign)
{
  ::brook::stream tmp_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream ret_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream guess_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  unsigned int  i;
  float2  maxvalue;
  unsigned int  logN;
  unsigned int  LogNMinusK;
  float  maxshift;

  maxvalue.x = (float ) (LENGTH);
  maxvalue.y = (float ) (WIDTH);
  logN = (unsigned int ) (ceil(log((float ) (LENGTH) * WIDTH) / log(2.000000f)));
  debugStreamPrint(list_stream,"Combined...");
  NanToBoolRightfloat4(list_stream,ret_stream,(float ) (sign),maxvalue);
  for (i = 1; i < logN; ++i)
  {
    streamSwap(ret_stream,tmp_stream);
    NanToRightfloat4(tmp_stream,ret_stream,(float ) (sign) * (1 << i),maxvalue);
  }

  debugStreamPrint(ret_stream,"scattering...");
  {
    static ::brook::stream item(::brook::getStreamType(( float  *)0), 1,-1);
    float2  index;

    if (sign == -1)
    {
      index.y = (float ) (WIDTH - 1);
      index.x = (float ) (LENGTH - 1);
    }

    else
    {
      index.y = index.x = 0;
    }

    kernelReadItem(ret_stream,index,item);
    streamWrite(item,&maxshift);
  }

  LogNMinusK = logN - 2;
  i = logN - 1;
  EstablishGuessfloat4(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,(float ) (1 << i),(float ) (sign));
  for (i = 1; i < logN; ++i)
  {
    LogNMinusK = logN - 1 - i;
    streamSwap(tmp_stream,guess_stream);
    UpdateGuessfloat4(ret_stream,guess_stream,list_stream,(float ) (1 << LogNMinusK),maxvalue,tmp_stream,(float ) (sign));
  }

  debugStreamPrint(guess_stream,"Gather Value");
  if (1)
  {
    unsigned int  size;
    unsigned int  width;

    size = (unsigned int ) (LENGTH) * (unsigned int ) (WIDTH) - (unsigned int ) (maxshift);
    width = size / LENGTH + ((size % LENGTH) ? (1) : (0));
    if (1)
    {
      ::brook::stream proper_output_stream=quickAllocStream(::brook::getStreamType(( float4  *)0), width , LENGTH,-1);

      if (width)
      {
        RelativeGatherfloat4(proper_output_stream,guess_stream,list_stream,*sentinelStream(2),(float ) (sign),maxvalue,maxshift);
      }

      streamSwap(*output_stream,proper_output_stream);
    }

    debugStreamPrint(*output_stream,"Final Value");
  }

  return maxshift;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine1_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 0, 0, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t1.x, c5.x, c5.z\n"
				"    mad r7.y, t1.y, c5.y, c5.w\n"
				"    rcp r7.w, c1.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c0.x, c0.z\n"
				"    mad r8.y, r9.y, c0.y, c0.w\n"
				"    texld r3, r8, s0\n"
				"    texld r10, t0, s1\n"
				"    mul r2.w, r7.y, c4.x\n"
				"    frc r5.w, r2.x\n"
				"    mad r4.w, r5.w, c1.x, r2.w\n"
				"    mul r7.w, r7.w, r4.w\n"
				"    frc r11.w, r7.w\n"
				"    mul r6.w, r11.w, c1.x\n"
				"    add r1.w, r6.w, -c2.x\n"
				"    frc r8.w, r1.w\n"
				"    add r5.w, r1.w, -r8.w\n"
				"    abs r4.w, r5.w\n"
				"    cmp_pp r11.w, -r4.w, c6.w, c6.y\n"
				"    add r9.w, r5.w, -c1.x\n"
				"    abs r8.w, r9.w\n"
				"    cmp_pp r5.w, -r8.w, c6.w, c6.y\n"
				"    add_pp r0.w, r11.w, r5.w\n"
				"    cmp r3, -r0.w, r10, r3\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:4:input0\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:4:oldoutput\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine1_ps20 = &__float4streamCombine1_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine1_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.modulus : C1\n"
				"#semantic main.offset : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._tex_oldoutput : TEXUNIT1\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var float modulus : C1 :  : 2 : 1\n"
				"#var float offset : C2 :  : 3 : 1\n"
				"#var float length : C3 :  : 4 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 5 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT1 : texunit 1 : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 9 : 1\n"
				"#var float4 __workspace : C6 :  : 11 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 10 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX1, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, length.x;\n"
				"MULR R1.x, R2.w, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |length.x|;\n"
				"RCPR R1.y, modulus.x;\n"
				"MULR R1.y, R3.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |modulus.x|;\n"
				"MOVR R1.z, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.x;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, -offset.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SEQR H0.x, R1.x, modulus.x;\n"
				"SEQR H0.y, R1.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"MOVR o[COLR], R1;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine1_fp30 = &__float4streamCombine1_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine1_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 0, 0, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c5.x, c5.z;\n"
				"MAD r7.y, t1.y, c5.y, c5.w;\n"
				"RCP r7.w, c1.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c0.x, c0.z;\n"
				"MAD r8.y, r9.y, c0.y, c0.w;\n"
				"TEX r3, r8, texture[0], RECT;\n"
				"TEX r10, t0, texture[1], RECT;\n"
				"MUL r2.w, r7.y, c4.x;\n"
				"FRC r5.w, r2.x;\n"
				"MAD r4.w, r5.w, c1.x, r2.w;\n"
				"MUL r7.w, r7.w, r4.w;\n"
				"FRC r11.w, r7.w;\n"
				"MUL r6.w, r11.w, c1.x;\n"
				"ADD r1.w, r6.w, -c2.x;\n"
				"FRC r8.w, r1.w;\n"
				"ADD r5.w, r1.w, -r8.w;\n"
				"ABS r4.w, r5.w;\n"
				"CMP r11.w, -r4.w, c6.y, c6.w;\n"
				"ADD r9.w, r5.w, -c1.x;\n"
				"ABS r8.w, r9.w;\n"
				"CMP r5.w, -r8.w, c6.y, c6.w;\n"
				"ADD r0.w, r11.w, r5.w;\n"
				"CMP r3, -r0.w, r3, r10;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input0\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, 0)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(6, 0)
				.interpolant(6, kStreamInterpolant_Position)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine1_arb = &__float4streamCombine1_arb_desc;
}

void __float4streamCombine1_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat4  &oldoutput,
                                        __BrtFloat4  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = oldoutput;
  }

}
void  __float4streamCombine1_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtFloat1 *arg1 = (__BrtFloat1 *)args[1];
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat4 *arg5 = (__BrtFloat4 *)args[5];
  __BrtFloat4 *arg6 = (__BrtFloat4 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio5 = extents[6][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[6][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[6]);
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine1_cpu_inner (
      arg0,
      *arg1,
      *arg2,
      *arg3,
      *arg4,
      *(arg5 + iter5),
      *arg6,
      indexof6);
    i++;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[6]);
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float4streamCombine1 (::brook::stream input0,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float4streamCombine1_fp[] = {
     "fp30", __float4streamCombine1_fp30,
     "arb", __float4streamCombine1_arb,
     "ps20", __float4streamCombine1_ps20,
     "cpu", (void *) __float4streamCombine1_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine1_fp);

  k->PushGatherStream(input0);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c6, 0.03125, 1, 0, 0.5\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t0.x, c5.x, c5.z\n"
				"    mad r7.y, t0.y, c5.y, c5.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c3.x, r2.x\n"
				"    add r9.w, r2.y, c6.x\n"
				"    add r2.w, r2.w, c6.x\n"
				"    rcp r4.w, c3.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c3.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r3.x, r9.x, c0.x, c0.z\n"
				"    mad r3.y, r9.y, c0.y, c0.w\n"
				"    mad r10.x, r9.x, c1.x, c1.z\n"
				"    mad r10.y, r9.y, c1.y, c1.w\n"
				"    texld r5, r3, s0\n"
				"    texld r0, r10, s1\n"
				"    mul r2.w, r7.y, c4.x\n"
				"    frc r4.w, r2.x\n"
				"    mad r6.w, r4.w, c2.x, r2.w\n"
				"    mul r7.w, r7.w, r6.w\n"
				"    frc r9.w, r7.w\n"
				"    mul r1.w, r9.w, c2.x\n"
				"    add r8.w, r1.w, c6.w\n"
				"    frc r3.w, r8.w\n"
				"    add r2.w, r8.w, -r3.w\n"
				"    abs r11.w, r2.w\n"
				"    cmp_pp r7.w, -r11.w, c6.y, c6.z\n"
				"    add r1.w, r2.w, -c2.x\n"
				"    abs r3.w, r1.w\n"
				"    cmp_pp r2.w, -r3.w, c6.y, c6.z\n"
				"    add_pp r4.w, r7.w, r2.w\n"
				"    cmp r5, -r4.w, r0, r5\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:6\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float4streamCombine2f_ps20 = &__float4streamCombine2f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.length : C3\n"
				"#semantic main.lengthmodmodulus : C4\n"
				"#semantic main._const_output_invscalebias : C5\n"
				"#semantic main.__workspace : C6\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float length : C3 :  : 5 : 1\n"
				"#var float lengthmodmodulus : C4 :  : 6 : 1\n"
				"#var float4 _const_output_invscalebias : C5 :  : 8 : 1\n"
				"#var float4 __workspace : C6 :  : 10 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, length.x;\n"
				"MULR R0.x, R1.w, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |length.x|;\n"
				"RCPR R0.y, modulus.x;\n"
				"MULR R0.y, R2.x, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |modulus.x|;\n"
				"MOVR R0.z, R0.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.x;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.x, R0.y;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), -R0.y;\n"
				"ADDR R0.x, R0.x, -{-0.5}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"SEQR H0.x, R0.x, modulus.x;\n"
				"SEQR H0.y, R0.x, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0, R1.xyxx, TEX0, RECT;\n"
				"TEX R1, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R0;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float4streamCombine2f_fp30 = &__float4streamCombine2f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c5.x, c5.z;\n"
				"MAD r7.y, t0.y, c5.y, c5.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c3.x, r2.x;\n"
				"ADD r9.w, r2.y, c6.x;\n"
				"ADD r2.w, r2.w, c6.x;\n"
				"RCP r4.w, c3.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c3.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r3.x, r9.x, c0.x, c0.z;\n"
				"MAD r3.y, r9.y, c0.y, c0.w;\n"
				"MAD r10.x, r9.x, c1.x, c1.z;\n"
				"MAD r10.y, r9.y, c1.y, c1.w;\n"
				"TEX r5, r3, texture[0], RECT;\n"
				"TEX r0, r10, texture[1], RECT;\n"
				"MUL r2.w, r7.y, c4.x;\n"
				"FRC r4.w, r2.x;\n"
				"MAD r6.w, r4.w, c2.x, r2.w;\n"
				"MUL r7.w, r7.w, r6.w;\n"
				"FRC r9.w, r7.w;\n"
				"MUL r1.w, r9.w, c2.x;\n"
				"ADD r8.w, r1.w, c6.w;\n"
				"FRC r3.w, r8.w;\n"
				"ADD r2.w, r8.w, -r3.w;\n"
				"ABS r11.w, r2.w;\n"
				"CMP r7.w, -r11.w, c6.z, c6.y;\n"
				"ADD r1.w, r2.w, -c2.x;\n"
				"ABS r3.w, r1.w;\n"
				"CMP r2.w, -r3.w, c6.z, c6.y;\n"
				"ADD r4.w, r7.w, r2.w;\n"
				"CMP r5, -r4.w, r5, r0;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(6, kOutputInterpolant_Position)
				.output(6, 0)
			)
		);
	static const void* __float4streamCombine2f_arb = &__float4streamCombine2f_arb_desc;
}

void __float4streamCombine2f_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                         const __BrtArray2d<__BrtFloat4  > &input1,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat4  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
  {
    output = input1[newindex];
  }

}
void  __float4streamCombine2f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat4 *arg5 = (__BrtFloat4 *)args[5];
  unsigned int dim=dims[5];
  unsigned int newline=extents[5][dim-1];
  arg5+=mapbegin;
  ;
__BrtFloat4 indexof5 = computeIndexOf(mapbegin, extents[5], dims[5], extents[5]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine2f_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      indexof5);
    i++;
    ++arg5;
indexof5.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof5 = computeReferenceIndexOf(i+mapbegin, extents[5],dim);
    }
  }
}

void  float4streamCombine2f (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float4streamCombine2f_fp[] = {
     "fp30", __float4streamCombine2f_fp30,
     "arb", __float4streamCombine2f_arb,
     "ps20", __float4streamCombine2f_ps20,
     "cpu", (void *) __float4streamCombine2f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine2f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 0, -1, 1\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t1.x, c6.x, c6.z\n"
				"    mad r0.y, t1.y, c6.y, c6.w\n"
				"    rcp r7.w, c2.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r5.x, r8.x, c1.x, c1.z\n"
				"    mad r5.y, r8.y, c1.y, c1.w\n"
				"    mad r2.x, r8.x, c0.x, c0.z\n"
				"    mad r2.y, r8.y, c0.y, c0.w\n"
				"    texld r9, r5, s1\n"
				"    texld r4, t0, s2\n"
				"    texld r11, r2, s0\n"
				"    mul r6.w, r0.y, c5.x\n"
				"    frc r1.w, r7.x\n"
				"    mad r3.w, r1.w, c2.x, r6.w\n"
				"    mul r7.w, r7.w, r3.w\n"
				"    frc r10.w, r7.w\n"
				"    mul r5.w, r10.w, c2.x\n"
				"    add r2.w, r5.w, -c3.x\n"
				"    frc r6.w, r2.w\n"
				"    add r0.w, r2.w, -r6.w\n"
				"    add r8.w, r0.w, c7.z\n"
				"    abs r7.w, r8.w\n"
				"    cmp r9, -r7.w, r9, r4\n"
				"    abs r5.w, r0.w\n"
				"    cmp_pp r6.w, -r5.w, c7.w, c7.y\n"
				"    add r0.w, r0.w, -c2.x\n"
				"    abs r3.w, r0.w\n"
				"    cmp_pp r10.w, -r3.w, c7.w, c7.y\n"
				"    add_pp r4.w, r6.w, r10.w\n"
				"    cmp r11, -r4.w, r9, r11\n"
				"    mov oC0, r11\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:4:oldoutput\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine2_ps20 = &__float4streamCombine2_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.modulus : C2\n"
				"#semantic main.offset : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._tex_oldoutput : TEXUNIT2\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var float modulus : C2 :  : 4 : 1\n"
				"#var float offset : C3 :  : 5 : 1\n"
				"#var float length : C4 :  : 6 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 7 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT2 : texunit 2 : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 11 : 1\n"
				"#var float4 __workspace : C7 :  : 13 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 10 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 12 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX2, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R1.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"TEX R2, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R1;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine2_fp30 = &__float4streamCombine2_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine2_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t1.x, c6.x, c6.z;\n"
				"MAD r0.y, t1.y, c6.y, c6.w;\n"
				"RCP r7.w, c2.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r5.x, r8.x, c1.x, c1.z;\n"
				"MAD r5.y, r8.y, c1.y, c1.w;\n"
				"MAD r2.x, r8.x, c0.x, c0.z;\n"
				"MAD r2.y, r8.y, c0.y, c0.w;\n"
				"TEX r9, r5, texture[1], RECT;\n"
				"TEX r4, t0, texture[2], RECT;\n"
				"TEX r11, r2, texture[0], RECT;\n"
				"MUL r6.w, r0.y, c5.x;\n"
				"FRC r1.w, r7.x;\n"
				"MAD r3.w, r1.w, c2.x, r6.w;\n"
				"MUL r7.w, r7.w, r3.w;\n"
				"FRC r10.w, r7.w;\n"
				"MUL r5.w, r10.w, c2.x;\n"
				"ADD r2.w, r5.w, -c3.x;\n"
				"FRC r6.w, r2.w;\n"
				"ADD r0.w, r2.w, -r6.w;\n"
				"ADD r8.w, r0.w, c7.z;\n"
				"ABS r7.w, r8.w;\n"
				"CMP r9, -r7.w, r4, r9;\n"
				"ABS r5.w, r0.w;\n"
				"CMP r6.w, -r5.w, c7.y, c7.w;\n"
				"ADD r0.w, r0.w, -c2.x;\n"
				"ABS r3.w, r0.w;\n"
				"CMP r10.w, -r3.w, c7.y, c7.w;\n"
				"ADD r4.w, r6.w, r10.w;\n"
				"CMP r11, -r4.w, r11, r9;\n"
				"MOV oC0, r11;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, 0)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(7, 0)
				.interpolant(7, kStreamInterpolant_Position)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine2_arb = &__float4streamCombine2_arb_desc;
}

void __float4streamCombine2_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                        const __BrtArray2d<__BrtFloat4  > &input1,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat4  &oldoutput,
                                        __BrtFloat4  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = oldoutput;
    }

}
void  __float4streamCombine2_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtFloat1 *arg2 = (__BrtFloat1 *)args[2];
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat4 *arg6 = (__BrtFloat4 *)args[6];
  __BrtFloat4 *arg7 = (__BrtFloat4 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  unsigned int ratio6 = extents[7][dim-1]/extents[6][dim-1];
  unsigned int scale6=extents[6][dim-1]/extents[7][dim-1];
  if (scale6<1) scale6 = 1;
  unsigned int ratioiter6 = 0;
  if (ratio6) ratioiter6 = mapbegin%ratio6;
  unsigned int iter6 = getIndexOf(mapbegin,extents[6], dim, extents[7]);
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine2_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *(arg6 + iter6),
      *arg7,
      indexof7);
    i++;
    if (++ratioiter6>=ratio6){
      ratioiter6=0;
      iter6+=scale6;
    }
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter6=getIndexOf(i+mapbegin,extents[6],dim, extents[7]);
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float4streamCombine2 (::brook::stream input0,
		::brook::stream input1,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float4streamCombine2_fp[] = {
     "fp30", __float4streamCombine2_fp30,
     "arb", __float4streamCombine2_arb,
     "ps20", __float4streamCombine2_ps20,
     "cpu", (void *) __float4streamCombine2_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine2_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0.03125, 1, 0, 0.5\n"
				"    def c8, -1, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    rcp r0.w, c4.x\n"
				"    mad r0.x, t0.x, c6.x, c6.z\n"
				"    mad r0.y, t0.y, c6.y, c6.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c4.x, r7.x\n"
				"    add r11.w, r4.w, c7.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c4.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c7.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c1.x, c1.z\n"
				"    mad r10.y, r8.y, c1.y, c1.w\n"
				"    mad r9.x, r8.x, c2.x, c2.z\n"
				"    mad r9.y, r8.y, c2.y, c2.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s1\n"
				"    texld r6, r9, s2\n"
				"    texld r1, r4, s0\n"
				"    mul r0.w, r0.y, c5.x\n"
				"    frc r8.w, r7.x\n"
				"    mad r10.w, r8.w, c3.x, r0.w\n"
				"    mul r7.w, r7.w, r10.w\n"
				"    frc r5.w, r7.w\n"
				"    mul r2.w, r5.w, c3.x\n"
				"    add r9.w, r2.w, c7.w\n"
				"    frc r4.w, r9.w\n"
				"    add r8.w, r9.w, -r4.w\n"
				"    add r3.w, r8.w, c8.x\n"
				"    abs r7.w, r3.w\n"
				"    cmp r11, -r7.w, r11, r6\n"
				"    abs r2.w, r8.w\n"
				"    cmp_pp r4.w, -r2.w, c7.y, c7.z\n"
				"    add r8.w, r8.w, -c3.x\n"
				"    abs r10.w, r8.w\n"
				"    cmp_pp r5.w, -r10.w, c7.y, c7.z\n"
				"    add_pp r6.w, r4.w, r5.w\n"
				"    cmp r1, -r6.w, r11, r1\n"
				"    mov oC0, r1\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine3f_ps20 = &__float4streamCombine3f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.length : C4\n"
				"#semantic main.lengthmodmodulus : C5\n"
				"#semantic main._const_output_invscalebias : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float length : C4 :  : 7 : 1\n"
				"#var float lengthmodmodulus : C5 :  : 8 : 1\n"
				"#var float4 _const_output_invscalebias : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 12 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"SEQR H0.y, R0.y, {1}.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.z, -H0.x, {1}.x;\n"
				"MULX H0.z, H0.z, H0.y;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.y, {1}.x;\n"
				"MULX H0.y, H0.x, H0.y;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0, R1.xyxx, TEX0, RECT;\n"
				"TEX R2, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R0;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"TEX R0, R1.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine3f_fp30 = &__float4streamCombine3f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c8 = {-1, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"RCP r0.w, c4.x;\n"
				"MAD r0.x, t0.x, c6.x, c6.z;\n"
				"MAD r0.y, t0.y, c6.y, c6.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c4.x, r7.x;\n"
				"ADD r11.w, r4.w, c7.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c4.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c7.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c1.x, c1.z;\n"
				"MAD r10.y, r8.y, c1.y, c1.w;\n"
				"MAD r9.x, r8.x, c2.x, c2.z;\n"
				"MAD r9.y, r8.y, c2.y, c2.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[1], RECT;\n"
				"TEX r6, r9, texture[2], RECT;\n"
				"TEX r1, r4, texture[0], RECT;\n"
				"MUL r0.w, r0.y, c5.x;\n"
				"FRC r8.w, r7.x;\n"
				"MAD r10.w, r8.w, c3.x, r0.w;\n"
				"MUL r7.w, r7.w, r10.w;\n"
				"FRC r5.w, r7.w;\n"
				"MUL r2.w, r5.w, c3.x;\n"
				"ADD r9.w, r2.w, c7.w;\n"
				"FRC r4.w, r9.w;\n"
				"ADD r8.w, r9.w, -r4.w;\n"
				"ADD r3.w, r8.w, c8.x;\n"
				"ABS r7.w, r3.w;\n"
				"CMP r11, -r7.w, r6, r11;\n"
				"ABS r2.w, r8.w;\n"
				"CMP r4.w, -r2.w, c7.z, c7.y;\n"
				"ADD r8.w, r8.w, -c3.x;\n"
				"ABS r10.w, r8.w;\n"
				"CMP r5.w, -r10.w, c7.z, c7.y;\n"
				"ADD r6.w, r4.w, r5.w;\n"
				"CMP r1, -r6.w, r1, r11;\n"
				"MOV oC0, r1;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(7, kOutputInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __float4streamCombine3f_arb = &__float4streamCombine3f_arb_desc;
}

void __float4streamCombine3f_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                         const __BrtArray2d<__BrtFloat4  > &input1,
                                         const __BrtArray2d<__BrtFloat4  > &input2,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat4  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
    {
      output = input2[newindex];
    }

}
void  __float4streamCombine3f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat4 *arg6 = (__BrtFloat4 *)args[6];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  arg6+=mapbegin;
  ;
__BrtFloat4 indexof6 = computeIndexOf(mapbegin, extents[6], dims[6], extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine3f_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof6);
    i++;
    ++arg6;
indexof6.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof6 = computeReferenceIndexOf(i+mapbegin, extents[6],dim);
    }
  }
}

void  float4streamCombine3f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float4streamCombine3f_fp[] = {
     "fp30", __float4streamCombine3f_fp30,
     "arb", __float4streamCombine3f_arb,
     "ps20", __float4streamCombine3f_ps20,
     "cpu", (void *) __float4streamCombine3f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine3f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 0, -1, 1\n"
				"    def c9, -2, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    rcp r0.w, c5.x\n"
				"    mad r0.x, t1.x, c7.x, c7.z\n"
				"    mad r0.y, t1.y, c7.y, c7.w\n"
				"    rcp r7.w, c3.x\n"
				"    mul r7.xy, r0, r7.w\n"
				"    frc r2.w, r7.y\n"
				"    mad r4.w, r2.w, c5.x, r7.x\n"
				"    add r11.w, r4.w, c8.x\n"
				"    mul r0.w, r11.w, r0.w\n"
				"    frc r0.w, r0.w\n"
				"    mul r0.w, r0.w, c5.x\n"
				"    frc r6.w, r0.w\n"
				"    add r8.x, r0.w, -r6.w\n"
				"    add r8.w, r7.y, c8.x\n"
				"    frc r0.w, r8.w\n"
				"    add r8.y, r8.w, -r0.w\n"
				"    mad r10.x, r8.x, c2.x, c2.z\n"
				"    mad r10.y, r8.y, c2.y, c2.w\n"
				"    mad r9.x, r8.x, c1.x, c1.z\n"
				"    mad r9.y, r8.y, c1.y, c1.w\n"
				"    mad r4.x, r8.x, c0.x, c0.z\n"
				"    mad r4.y, r8.y, c0.y, c0.w\n"
				"    texld r11, r10, s2\n"
				"    texld r6, t0, s3\n"
				"    texld r1, r9, s1\n"
				"    texld r8, r4, s0\n"
				"    mul r0.w, r0.y, c6.x\n"
				"    frc r3.w, r7.x\n"
				"    mad r2.w, r3.w, c3.x, r0.w\n"
				"    mul r7.w, r7.w, r2.w\n"
				"    frc r9.w, r7.w\n"
				"    mul r4.w, r9.w, c3.x\n"
				"    add r0.w, r4.w, -c4.x\n"
				"    frc r3.w, r0.w\n"
				"    add r5.w, r0.w, -r3.w\n"
				"    add r2.w, r5.w, c9.x\n"
				"    abs r9.w, r2.w\n"
				"    cmp r11, -r9.w, r11, r6\n"
				"    add r6.w, r5.w, c8.z\n"
				"    abs r3.w, r6.w\n"
				"    cmp r1, -r3.w, r1, r11\n"
				"    abs r7.w, r5.w\n"
				"    cmp_pp r4.w, -r7.w, c8.w, c8.y\n"
				"    add r5.w, r5.w, -c3.x\n"
				"    abs r0.w, r5.w\n"
				"    cmp_pp r10.w, -r0.w, c8.w, c8.y\n"
				"    add_pp r2.w, r4.w, r10.w\n"
				"    cmp r8, -r2.w, r1, r8\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:4:oldoutput\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine3_ps20 = &__float4streamCombine3_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.modulus : C3\n"
				"#semantic main.offset : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._tex_oldoutput : TEXUNIT3\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var float modulus : C3 :  : 6 : 1\n"
				"#var float offset : C4 :  : 7 : 1\n"
				"#var float length : C5 :  : 8 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 9 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT3 : texunit 3 : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 13 : 1\n"
				"#var float4 __workspace : C8 :  : 15 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 12 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 14 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX3, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"SEQR H0.w, R1.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"TEX R3, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R1;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R3;\n"
				"TEX R1, R2.xyxx, TEX2, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine3_fp30 = &__float4streamCombine3_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine3_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 0, -1, 1};\n"
				"PARAM c9 = {-2, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"RCP r0.w, c5.x;\n"
				"MAD r0.x, t1.x, c7.x, c7.z;\n"
				"MAD r0.y, t1.y, c7.y, c7.w;\n"
				"RCP r7.w, c3.x;\n"
				"MUL r7.xy, r0, r7.w;\n"
				"FRC r2.w, r7.y;\n"
				"MAD r4.w, r2.w, c5.x, r7.x;\n"
				"ADD r11.w, r4.w, c8.x;\n"
				"MUL r0.w, r11.w, r0.w;\n"
				"FRC r0.w, r0.w;\n"
				"MUL r0.w, r0.w, c5.x;\n"
				"FRC r6.w, r0.w;\n"
				"ADD r8.x, r0.w, -r6.w;\n"
				"ADD r8.w, r7.y, c8.x;\n"
				"FRC r0.w, r8.w;\n"
				"ADD r8.y, r8.w, -r0.w;\n"
				"MAD r10.x, r8.x, c2.x, c2.z;\n"
				"MAD r10.y, r8.y, c2.y, c2.w;\n"
				"MAD r9.x, r8.x, c1.x, c1.z;\n"
				"MAD r9.y, r8.y, c1.y, c1.w;\n"
				"MAD r4.x, r8.x, c0.x, c0.z;\n"
				"MAD r4.y, r8.y, c0.y, c0.w;\n"
				"TEX r11, r10, texture[2], RECT;\n"
				"TEX r6, t0, texture[3], RECT;\n"
				"TEX r1, r9, texture[1], RECT;\n"
				"TEX r8, r4, texture[0], RECT;\n"
				"MUL r0.w, r0.y, c6.x;\n"
				"FRC r3.w, r7.x;\n"
				"MAD r2.w, r3.w, c3.x, r0.w;\n"
				"MUL r7.w, r7.w, r2.w;\n"
				"FRC r9.w, r7.w;\n"
				"MUL r4.w, r9.w, c3.x;\n"
				"ADD r0.w, r4.w, -c4.x;\n"
				"FRC r3.w, r0.w;\n"
				"ADD r5.w, r0.w, -r3.w;\n"
				"ADD r2.w, r5.w, c9.x;\n"
				"ABS r9.w, r2.w;\n"
				"CMP r11, -r9.w, r6, r11;\n"
				"ADD r6.w, r5.w, c8.z;\n"
				"ABS r3.w, r6.w;\n"
				"CMP r1, -r3.w, r11, r1;\n"
				"ABS r7.w, r5.w;\n"
				"CMP r4.w, -r7.w, c8.y, c8.w;\n"
				"ADD r5.w, r5.w, -c3.x;\n"
				"ABS r0.w, r5.w;\n"
				"CMP r10.w, -r0.w, c8.y, c8.w;\n"
				"ADD r2.w, r4.w, r10.w;\n"
				"CMP r8, -r2.w, r8, r1;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(8, 0)
				.interpolant(8, kStreamInterpolant_Position)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine3_arb = &__float4streamCombine3_arb_desc;
}

void __float4streamCombine3_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                        const __BrtArray2d<__BrtFloat4  > &input1,
                                        const __BrtArray2d<__BrtFloat4  > &input2,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat4  &oldoutput,
                                        __BrtFloat4  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = oldoutput;
      }

}
void  __float4streamCombine3_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtFloat1 *arg3 = (__BrtFloat1 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat4 *arg7 = (__BrtFloat4 *)args[7];
  __BrtFloat4 *arg8 = (__BrtFloat4 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  unsigned int ratio7 = extents[8][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[8][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[8]);
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine3_cpu_inner (
      arg0,
      arg1,
      arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *(arg7 + iter7),
      *arg8,
      indexof8);
    i++;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[8]);
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float4streamCombine3 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float4streamCombine3_fp[] = {
     "fp30", __float4streamCombine3_fp30,
     "arb", __float4streamCombine3_arb,
     "ps20", __float4streamCombine3_ps20,
     "cpu", (void *) __float4streamCombine3_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine3_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c8, 0.03125, 1, 0, 0.5\n"
				"    def c9, -1, 0, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    mad r7.x, t0.x, c7.x, c7.z\n"
				"    mad r7.y, t0.y, c7.y, c7.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c5.x, r2.x\n"
				"    add r9.w, r2.y, c8.x\n"
				"    add r2.w, r2.w, c8.x\n"
				"    rcp r4.w, c5.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c5.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c2.x, c2.z\n"
				"    mad r8.y, r9.y, c2.y, c2.w\n"
				"    mad r10.x, r9.x, c3.x, c3.z\n"
				"    mad r10.y, r9.y, c3.y, c3.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s2\n"
				"    texld r9, r10, s3\n"
				"    texld r1, r4, s1\n"
				"    texld r8, r11, s0\n"
				"    mul r2.w, r7.y, c6.x\n"
				"    frc r3.w, r2.x\n"
				"    mad r5.w, r3.w, c4.x, r2.w\n"
				"    mul r7.w, r7.w, r5.w\n"
				"    frc r0.w, r7.w\n"
				"    mul r4.w, r0.w, c4.x\n"
				"    add r11.w, r4.w, c8.w\n"
				"    frc r2.w, r11.w\n"
				"    add r10.w, r11.w, -r2.w\n"
				"    add r5.w, r10.w, c9.w\n"
				"    abs r0.w, r5.w\n"
				"    cmp r6, -r0.w, r6, r9\n"
				"    add r9.w, r10.w, c9.x\n"
				"    abs r2.w, r9.w\n"
				"    cmp r1, -r2.w, r1, r6\n"
				"    abs r7.w, r10.w\n"
				"    cmp_pp r4.w, -r7.w, c8.y, c8.z\n"
				"    add r10.w, r10.w, -c4.x\n"
				"    abs r11.w, r10.w\n"
				"    cmp_pp r3.w, -r11.w, c8.y, c8.z\n"
				"    add_pp r5.w, r4.w, r3.w\n"
				"    cmp r8, -r5.w, r1, r8\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//c:4:input3\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine4f_ps20 = &__float4streamCombine4f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.length : C5\n"
				"#semantic main.lengthmodmodulus : C6\n"
				"#semantic main._const_output_invscalebias : C7\n"
				"#semantic main.__workspace : C8\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float length : C5 :  : 9 : 1\n"
				"#var float lengthmodmodulus : C6 :  : 10 : 1\n"
				"#var float4 _const_output_invscalebias : C7 :  : 12 : 1\n"
				"#var float4 __workspace : C8 :  : 14 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 11 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"SEQR H0.w, R0.y, {2}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MULX H0.x, H0.z, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.z, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0, R1.xyxx, TEX0, RECT;\n"
				"TEX R2, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R0;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"TEX R0, R1.xyxx, TEX2, RECT;\n"
				"TEX R1, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine4f_fp30 = &__float4streamCombine4f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = {0.03125, 1, 0, 0.5};\n"
				"PARAM c9 = {-1, 0, 0, -2};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c7.x, c7.z;\n"
				"MAD r7.y, t0.y, c7.y, c7.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c5.x, r2.x;\n"
				"ADD r9.w, r2.y, c8.x;\n"
				"ADD r2.w, r2.w, c8.x;\n"
				"RCP r4.w, c5.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c5.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c2.x, c2.z;\n"
				"MAD r8.y, r9.y, c2.y, c2.w;\n"
				"MAD r10.x, r9.x, c3.x, c3.z;\n"
				"MAD r10.y, r9.y, c3.y, c3.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[2], RECT;\n"
				"TEX r9, r10, texture[3], RECT;\n"
				"TEX r1, r4, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c6.x;\n"
				"FRC r3.w, r2.x;\n"
				"MAD r5.w, r3.w, c4.x, r2.w;\n"
				"MUL r7.w, r7.w, r5.w;\n"
				"FRC r0.w, r7.w;\n"
				"MUL r4.w, r0.w, c4.x;\n"
				"ADD r11.w, r4.w, c8.w;\n"
				"FRC r2.w, r11.w;\n"
				"ADD r10.w, r11.w, -r2.w;\n"
				"ADD r5.w, r10.w, c9.w;\n"
				"ABS r0.w, r5.w;\n"
				"CMP r6, -r0.w, r9, r6;\n"
				"ADD r9.w, r10.w, c9.x;\n"
				"ABS r2.w, r9.w;\n"
				"CMP r1, -r2.w, r6, r1;\n"
				"ABS r7.w, r10.w;\n"
				"CMP r4.w, -r7.w, c8.z, c8.y;\n"
				"ADD r10.w, r10.w, -c4.x;\n"
				"ABS r11.w, r10.w;\n"
				"CMP r3.w, -r11.w, c8.z, c8.y;\n"
				"ADD r5.w, r4.w, r3.w;\n"
				"CMP r8, -r5.w, r8, r1;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.interpolant(8, kOutputInterpolant_Position)
				.output(8, 0)
			)
		);
	static const void* __float4streamCombine4f_arb = &__float4streamCombine4f_arb_desc;
}

void __float4streamCombine4f_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                         const __BrtArray2d<__BrtFloat4  > &input1,
                                         const __BrtArray2d<__BrtFloat4  > &input2,
                                         const __BrtArray2d<__BrtFloat4  > &input3,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat4  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
      {
        output = input3[newindex];
      }

}
void  __float4streamCombine4f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat4  > arg3(
      (__BrtFloat4  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat4 *arg7 = (__BrtFloat4 *)args[7];
  unsigned int dim=dims[7];
  unsigned int newline=extents[7][dim-1];
  arg7+=mapbegin;
  ;
__BrtFloat4 indexof7 = computeIndexOf(mapbegin, extents[7], dims[7], extents[7]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine4f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      indexof7);
    i++;
    ++arg7;
indexof7.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof7 = computeReferenceIndexOf(i+mapbegin, extents[7],dim);
    }
  }
}

void  float4streamCombine4f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float4streamCombine4f_fp[] = {
     "fp30", __float4streamCombine4f_fp30,
     "arb", __float4streamCombine4f_arb,
     "ps20", __float4streamCombine4f_ps20,
     "cpu", (void *) __float4streamCombine4f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine4f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 0, -1, 1\n"
				"    def c10, -2, 0, 0, -3\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t1.x, c8.x, c8.z\n"
				"    mad r7.y, t1.y, c8.y, c8.w\n"
				"    rcp r7.w, c4.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c2.x, c2.z\n"
				"    mad r10.y, r9.y, c2.y, c2.w\n"
				"    mad r4.x, r9.x, c1.x, c1.z\n"
				"    mad r4.y, r9.y, c1.y, c1.w\n"
				"    mad r11.x, r9.x, c0.x, c0.z\n"
				"    mad r11.y, r9.y, c0.y, c0.w\n"
				"    texld r6, r8, s3\n"
				"    texld r9, t0, s4\n"
				"    texld r1, r10, s2\n"
				"    texld r8, r4, s1\n"
				"    texld r3, r11, s0\n"
				"    mul r2.w, r7.y, c7.x\n"
				"    frc r10.w, r2.x\n"
				"    mad r0.w, r10.w, c4.x, r2.w\n"
				"    mul r7.w, r7.w, r0.w\n"
				"    frc r4.w, r7.w\n"
				"    mul r11.w, r4.w, c4.x\n"
				"    add r10.w, r11.w, -c5.x\n"
				"    frc r5.w, r10.w\n"
				"    add r7.w, r10.w, -r5.w\n"
				"    add r4.w, r7.w, c10.w\n"
				"    abs r2.w, r4.w\n"
				"    cmp r6, -r2.w, r6, r9\n"
				"    add r9.w, r7.w, c10.x\n"
				"    abs r0.w, r9.w\n"
				"    cmp r1, -r0.w, r1, r6\n"
				"    add r11.w, r7.w, c9.z\n"
				"    abs r10.w, r11.w\n"
				"    cmp r8, -r10.w, r8, r1\n"
				"    abs r5.w, r7.w\n"
				"    cmp_pp r4.w, -r5.w, c9.w, c9.y\n"
				"    add r7.w, r7.w, -c4.x\n"
				"    abs r2.w, r7.w\n"
				"    cmp_pp r6.w, -r2.w, c9.w, c9.y\n"
				"    add_pp r9.w, r4.w, r6.w\n"
				"    cmp r3, -r9.w, r8, r3\n"
				"    mov oC0, r3\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:10\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//c:4:input3\n"
				"//c:1:modulus\n"
				"//c:1:offset\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//s:4:oldoutput\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float4streamCombine4_ps20 = &__float4streamCombine4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.modulus : C4\n"
				"#semantic main.offset : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._tex_oldoutput : TEXUNIT4\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var float modulus : C4 :  : 8 : 1\n"
				"#var float offset : C5 :  : 9 : 1\n"
				"#var float length : C6 :  : 10 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 11 : 1\n"
				"#var samplerRECT _tex_oldoutput : TEXUNIT4 : texunit 4 : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 15 : 1\n"
				"#var float4 __workspace : C9 :  : 17 : 1\n"
				"#var float2 _tex_oldoutput_pos : $vin.TEXCOORD0 : TEX0 : 13 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 14 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 16 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE modulus;\n"
				"DECLARE offset;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX4, RECT;\n"
				"MOVR R1.xy, f[TEX1].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"RCPR R1.w, modulus.x;\n"
				"MULR R1.w, R1.x, R1.w;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, |modulus.x|;\n"
				"RCPR R2.x, modulus.x;\n"
				"MULR R2.xy, R1.xyxx, R2.x;\n"
				"FRCR R2.w, R2.y;\n"
				"MULR R2.w, R2.w, length.x;\n"
				"ADDR R2.w, R2.x, R2.w;\n"
				"ADDR R2.w, R2.w, {0.03125}.x;\n"
				"SLTR H0.y, R2.w, {0}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), -R1.w;\n"
				"MADR R3.x, R1.y, lengthmodmodulus.x, R3.x;\n"
				"SLTR H0.x, R3.x, {0}.x;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.x, R3.x, R1.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, |modulus.x|;\n"
				"RCPR R1.y, length.x;\n"
				"MULR R1.y, R2.w, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |length.x|;\n"
				"MOVR R1.z, R1.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.z(GT.x), -R1.y;\n"
				"FLRR R1.z, R1.z;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, -offset.x;\n"
				"FLRR R1.y, R1.y;\n"
				"SEQR H0.x, R1.y, modulus.x;\n"
				"SEQR H0.y, R1.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R1.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R1.y, {2}.x;\n"
				"SEQR H0.w, R1.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R2.x, R1.z;\n"
				"ADDR R1.x, R2.y, {0.03125}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"MOVR R2.y, R1.x;\n"
				"TEX R1, R2.xyxx, TEX0, RECT;\n"
				"TEX R3, R2.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R1;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R3;\n"
				"TEX R1, R2.xyxx, TEX2, RECT;\n"
				"TEX R2, R2.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float4streamCombine4_fp30 = &__float4streamCombine4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-2, 0, 0, -3};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 0, -1, 1};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"MAD r7.x, t1.x, c8.x, c8.z;\n"
				"MAD r7.y, t1.y, c8.y, c8.w;\n"
				"RCP r7.w, c4.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c2.x, c2.z;\n"
				"MAD r10.y, r9.y, c2.y, c2.w;\n"
				"MAD r4.x, r9.x, c1.x, c1.z;\n"
				"MAD r4.y, r9.y, c1.y, c1.w;\n"
				"MAD r11.x, r9.x, c0.x, c0.z;\n"
				"MAD r11.y, r9.y, c0.y, c0.w;\n"
				"TEX r6, r8, texture[3], RECT;\n"
				"TEX r9, t0, texture[4], RECT;\n"
				"TEX r1, r10, texture[2], RECT;\n"
				"TEX r8, r4, texture[1], RECT;\n"
				"TEX r3, r11, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c7.x;\n"
				"FRC r10.w, r2.x;\n"
				"MAD r0.w, r10.w, c4.x, r2.w;\n"
				"MUL r7.w, r7.w, r0.w;\n"
				"FRC r4.w, r7.w;\n"
				"MUL r11.w, r4.w, c4.x;\n"
				"ADD r10.w, r11.w, -c5.x;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r7.w, r10.w, -r5.w;\n"
				"ADD r4.w, r7.w, c10.w;\n"
				"ABS r2.w, r4.w;\n"
				"CMP r6, -r2.w, r9, r6;\n"
				"ADD r9.w, r7.w, c10.x;\n"
				"ABS r0.w, r9.w;\n"
				"CMP r1, -r0.w, r6, r1;\n"
				"ADD r11.w, r7.w, c9.z;\n"
				"ABS r10.w, r11.w;\n"
				"CMP r8, -r10.w, r1, r8;\n"
				"ABS r5.w, r7.w;\n"
				"CMP r4.w, -r5.w, c9.y, c9.w;\n"
				"ADD r7.w, r7.w, -c4.x;\n"
				"ABS r2.w, r7.w;\n"
				"CMP r6.w, -r2.w, c9.y, c9.w;\n"
				"ADD r9.w, r4.w, r6.w;\n"
				"CMP r3, -r9.w, r3, r8;\n"
				"MOV oC0, r3;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:1:modulus\n"
				"##c:1:offset\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##s:4:oldoutput\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(10, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(9, 0)
				.interpolant(9, kStreamInterpolant_Position)
				.interpolant(10, kOutputInterpolant_Position)
				.output(10, 0)
			)
		);
	static const void* __float4streamCombine4_arb = &__float4streamCombine4_arb_desc;
}

void __float4streamCombine4_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                        const __BrtArray2d<__BrtFloat4  > &input1,
                                        const __BrtArray2d<__BrtFloat4  > &input2,
                                        const __BrtArray2d<__BrtFloat4  > &input3,
                                        const __BrtFloat1  &modulus,
                                        const __BrtFloat1  &offset,
                                        const __BrtFloat1  &length,
                                        const __BrtFloat1  &lengthmodmodulus,
                                        const __BrtFloat4  &oldoutput,
                                        __BrtFloat4  &output,
                                        const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,offset,lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = oldoutput;
        }

}
void  __float4streamCombine4_cpu (const std::vector<void *>&args,
                                  const std::vector<const unsigned int *>&extents,
                                  const std::vector<unsigned int>&dims,
                                  unsigned int mapbegin, 
                                  unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat4  > arg3(
      (__BrtFloat4  *)args[3], extents[3]);
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat4 *arg8 = (__BrtFloat4 *)args[8];
  __BrtFloat4 *arg9 = (__BrtFloat4 *)args[9];
  unsigned int dim=dims[9];
  unsigned int newline=extents[9][dim-1];
  unsigned int ratio8 = extents[9][dim-1]/extents[8][dim-1];
  unsigned int scale8=extents[8][dim-1]/extents[9][dim-1];
  if (scale8<1) scale8 = 1;
  unsigned int ratioiter8 = 0;
  if (ratio8) ratioiter8 = mapbegin%ratio8;
  unsigned int iter8 = getIndexOf(mapbegin,extents[8], dim, extents[9]);
  arg9+=mapbegin;
  ;
__BrtFloat4 indexof9 = computeIndexOf(mapbegin, extents[9], dims[9], extents[9]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine4_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      *(arg8 + iter8),
      *arg9,
      indexof9);
    i++;
    if (++ratioiter8>=ratio8){
      ratioiter8=0;
      iter8+=scale8;
    }
    ++arg9;
indexof9.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      iter8=getIndexOf(i+mapbegin,extents[8],dim, extents[9]);
      indexof9 = computeReferenceIndexOf(i+mapbegin, extents[9],dim);
    }
  }
}

void  float4streamCombine4 (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		const float  modulus,
		const float  offset,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream oldoutput,
		::brook::stream output) {
  static const void *__float4streamCombine4_fp[] = {
     "fp30", __float4streamCombine4_fp30,
     "arb", __float4streamCombine4_arb,
     "ps20", __float4streamCombine4_ps20,
     "cpu", (void *) __float4streamCombine4_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine4_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushConstant(modulus);
  k->PushConstant(offset);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushStream(oldoutput);
  k->PushOutput(output);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine5f_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c9, 0.03125, 1, 0, 0.5\n"
				"    def c10, -1, -3, 0, -2\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    dcl_2d s4\n"
				"    mad r7.x, t0.x, c8.x, c8.z\n"
				"    mad r7.y, t0.y, c8.y, c8.w\n"
				"    rcp r7.w, c5.x\n"
				"    mul r2.xy, r7, r7.w\n"
				"    frc r2.w, r2.y\n"
				"    mad r2.w, r2.w, c6.x, r2.x\n"
				"    add r9.w, r2.y, c9.x\n"
				"    add r2.w, r2.w, c9.x\n"
				"    rcp r4.w, c6.x\n"
				"    mul r2.w, r2.w, r4.w\n"
				"    frc r2.w, r2.w\n"
				"    mul r2.w, r2.w, c6.x\n"
				"    frc r11.w, r2.w\n"
				"    add r9.x, r2.w, -r11.w\n"
				"    frc r2.w, r9.w\n"
				"    add r9.y, r9.w, -r2.w\n"
				"    mad r8.x, r9.x, c3.x, c3.z\n"
				"    mad r8.y, r9.y, c3.y, c3.w\n"
				"    mad r10.x, r9.x, c4.x, c4.z\n"
				"    mad r10.y, r9.y, c4.y, c4.w\n"
				"    mad r0.x, r9.x, c2.x, c2.z\n"
				"    mad r0.y, r9.y, c2.y, c2.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    mov r4.xy, r9\n"
				"    mad r9.x, r4.x, c0.x, c0.z\n"
				"    mad r9.y, r4.y, c0.y, c0.w\n"
				"    texld r1, r8, s3\n"
				"    texld r8, r10, s4\n"
				"    texld r3, r0, s2\n"
				"    texld r10, r6, s1\n"
				"    texld r5, r9, s0\n"
				"    mul r2.w, r7.y, c7.x\n"
				"    frc r0.w, r2.x\n"
				"    mad r11.w, r0.w, c5.x, r2.w\n"
				"    mul r7.w, r7.w, r11.w\n"
				"    frc r6.w, r7.w\n"
				"    mul r9.w, r6.w, c5.x\n"
				"    add r2.w, r9.w, c9.w\n"
				"    frc r0.w, r2.w\n"
				"    add r11.w, r2.w, -r0.w\n"
				"    add r7.w, r11.w, c10.y\n"
				"    abs r9.w, r7.w\n"
				"    cmp r1, -r9.w, r1, r8\n"
				"    add r8.w, r11.w, c10.w\n"
				"    abs r4.w, r8.w\n"
				"    cmp r3, -r4.w, r3, r1\n"
				"    add r6.w, r11.w, c10.x\n"
				"    abs r2.w, r6.w\n"
				"    cmp r10, -r2.w, r10, r3\n"
				"    abs r0.w, r11.w\n"
				"    cmp_pp r7.w, -r0.w, c9.y, c9.z\n"
				"    add r11.w, r11.w, -c5.x\n"
				"    abs r9.w, r11.w\n"
				"    cmp_pp r1.w, -r9.w, c9.y, c9.z\n"
				"    add_pp r8.w, r7.w, r1.w\n"
				"    cmp r5, -r8.w, r10, r5\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:9\n"
				"//c:4:input0\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//c:4:input3\n"
				"//c:4:input4\n"
				"//c:1:modulus\n"
				"//c:1:length\n"
				"//c:1:lengthmodmodulus\n"
				"//oi:4:output\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine5f_ps20 = &__float4streamCombine5f_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine5f_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input0 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input0 : C0\n"
				"#semantic main.input1 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input1 : C1\n"
				"#semantic main.input2 : TEXUNIT2\n"
				"#semantic main.__gatherconst_input2 : C2\n"
				"#semantic main.input3 : TEXUNIT3\n"
				"#semantic main.__gatherconst_input3 : C3\n"
				"#semantic main.input4 : TEXUNIT4\n"
				"#semantic main.__gatherconst_input4 : C4\n"
				"#semantic main.modulus : C5\n"
				"#semantic main.length : C6\n"
				"#semantic main.lengthmodmodulus : C7\n"
				"#semantic main._const_output_invscalebias : C8\n"
				"#semantic main.__workspace : C9\n"
				"#var samplerRECT input0[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input0 : C0 :  : 1 : 1\n"
				"#var samplerRECT input1[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input1 : C1 :  : 3 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_input2 : C2 :  : 5 : 1\n"
				"#var samplerRECT input3[0] : TEXUNIT3 : texunit 3 : 6 : 1\n"
				"#var float4 __gatherconst_input3 : C3 :  : 7 : 1\n"
				"#var samplerRECT input4[0] : TEXUNIT4 : texunit 4 : 8 : 1\n"
				"#var float4 __gatherconst_input4 : C4 :  : 9 : 1\n"
				"#var float modulus : C5 :  : 10 : 1\n"
				"#var float length : C6 :  : 11 : 1\n"
				"#var float lengthmodmodulus : C7 :  : 12 : 1\n"
				"#var float4 _const_output_invscalebias : C8 :  : 14 : 1\n"
				"#var float4 __workspace : C9 :  : 16 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 13 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 15 : 1\n"
				"DECLARE __gatherconst_input0;\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE __gatherconst_input3;\n"
				"DECLARE __gatherconst_input4;\n"
				"DECLARE modulus;\n"
				"DECLARE length;\n"
				"DECLARE lengthmodmodulus;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R0.x, {0}.x;\n"
				"RCPR R0.w, modulus.x;\n"
				"MULR R0.w, R0.x, R0.w;\n"
				"FRCR R0.w, |R0.w|;\n"
				"MULR R0.w, R0.w, |modulus.x|;\n"
				"RCPR R1.x, modulus.x;\n"
				"MULR R1.xy, R0.xyxx, R1.x;\n"
				"FRCR R1.w, R1.y;\n"
				"MULR R1.w, R1.w, length.x;\n"
				"ADDR R1.w, R1.x, R1.w;\n"
				"ADDR R1.w, R1.w, {0.03125}.x;\n"
				"SLTR H0.y, R1.w, {0}.x;\n"
				"MOVR R2.x, R0.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), -R0.w;\n"
				"MADR R2.x, R0.y, lengthmodmodulus.x, R2.x;\n"
				"SLTR H0.x, R2.x, {0}.x;\n"
				"RCPR R0.x, modulus.x;\n"
				"MULR R0.x, R2.x, R0.x;\n"
				"FRCR R0.x, |R0.x|;\n"
				"MULR R0.x, R0.x, |modulus.x|;\n"
				"RCPR R0.y, length.x;\n"
				"MULR R0.y, R1.w, R0.y;\n"
				"FRCR R0.y, |R0.y|;\n"
				"MULR R0.y, R0.y, |length.x|;\n"
				"MOVR R0.z, R0.y;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.z(GT.x), -R0.y;\n"
				"FLRR R0.z, R0.z;\n"
				"MOVR R0.y, R0.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), -R0.x;\n"
				"ADDR R0.y, R0.y, -{-0.5}.x;\n"
				"FLRR R0.y, R0.y;\n"
				"SEQR H0.x, R0.y, modulus.x;\n"
				"SEQR H0.y, R0.y, {0}.x;\n"
				"ADDX H0.x, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"SEQR H0.z, R0.y, {1}.x;\n"
				"MULX H0.y, H0.y, H0.z;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"SEQR H0.x, R0.y, {2}.x;\n"
				"SEQR H0.w, R0.y, {3}.x;\n"
				"MULX H1.x, H0.z, H0.x;\n"
				"ADDX H0.x, -H0.x, {1}.x;\n"
				"MULX H0.x, H0.z, H0.x;\n"
				"MULX H0.z, H0.x, H0.w;\n"
				"ADDX H0.w, -H0.w, {1}.x;\n"
				"MULX H0.w, H0.x, H0.w;\n"
				"MOVR R1.x, R0.z;\n"
				"ADDR R0.x, R1.y, {0.03125}.x;\n"
				"FLRR R0.x, R0.x;\n"
				"MOVR R1.y, R0.x;\n"
				"TEX R0, R1.xyxx, TEX0, RECT;\n"
				"TEX R2, R1.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], R0;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"TEX R0, R1.xyxx, TEX2, RECT;\n"
				"TEX R2, R1.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"TEX R0, R1.xyxx, TEX4, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:4:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine5f_fp30 = &__float4streamCombine5f_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __float4streamCombine5f_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c10 = {-1, -3, 0, -2};\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = program.local[7];\n"
				"PARAM c8 = program.local[8];\n"
				"PARAM c9 = {0.03125, 1, 0, 0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r7.x, t0.x, c8.x, c8.z;\n"
				"MAD r7.y, t0.y, c8.y, c8.w;\n"
				"RCP r7.w, c5.x;\n"
				"MUL r2.xy, r7, r7.w;\n"
				"FRC r2.w, r2.y;\n"
				"MAD r2.w, r2.w, c6.x, r2.x;\n"
				"ADD r9.w, r2.y, c9.x;\n"
				"ADD r2.w, r2.w, c9.x;\n"
				"RCP r4.w, c6.x;\n"
				"MUL r2.w, r2.w, r4.w;\n"
				"FRC r2.w, r2.w;\n"
				"MUL r2.w, r2.w, c6.x;\n"
				"FRC r11.w, r2.w;\n"
				"ADD r9.x, r2.w, -r11.w;\n"
				"FRC r2.w, r9.w;\n"
				"ADD r9.y, r9.w, -r2.w;\n"
				"MAD r8.x, r9.x, c3.x, c3.z;\n"
				"MAD r8.y, r9.y, c3.y, c3.w;\n"
				"MAD r10.x, r9.x, c4.x, c4.z;\n"
				"MAD r10.y, r9.y, c4.y, c4.w;\n"
				"MAD r0.x, r9.x, c2.x, c2.z;\n"
				"MAD r0.y, r9.y, c2.y, c2.w;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"MOV r4.xy, r9;\n"
				"MAD r9.x, r4.x, c0.x, c0.z;\n"
				"MAD r9.y, r4.y, c0.y, c0.w;\n"
				"TEX r1, r8, texture[3], RECT;\n"
				"TEX r8, r10, texture[4], RECT;\n"
				"TEX r3, r0, texture[2], RECT;\n"
				"TEX r10, r6, texture[1], RECT;\n"
				"TEX r5, r9, texture[0], RECT;\n"
				"MUL r2.w, r7.y, c7.x;\n"
				"FRC r0.w, r2.x;\n"
				"MAD r11.w, r0.w, c5.x, r2.w;\n"
				"MUL r7.w, r7.w, r11.w;\n"
				"FRC r6.w, r7.w;\n"
				"MUL r9.w, r6.w, c5.x;\n"
				"ADD r2.w, r9.w, c9.w;\n"
				"FRC r0.w, r2.w;\n"
				"ADD r11.w, r2.w, -r0.w;\n"
				"ADD r7.w, r11.w, c10.y;\n"
				"ABS r9.w, r7.w;\n"
				"CMP r1, -r9.w, r8, r1;\n"
				"ADD r8.w, r11.w, c10.w;\n"
				"ABS r4.w, r8.w;\n"
				"CMP r3, -r4.w, r1, r3;\n"
				"ADD r6.w, r11.w, c10.x;\n"
				"ABS r2.w, r6.w;\n"
				"CMP r10, -r2.w, r3, r10;\n"
				"ABS r0.w, r11.w;\n"
				"CMP r7.w, -r0.w, c9.z, c9.y;\n"
				"ADD r11.w, r11.w, -c5.x;\n"
				"ABS r9.w, r11.w;\n"
				"CMP r1.w, -r9.w, c9.z, c9.y;\n"
				"ADD r8.w, r7.w, r1.w;\n"
				"CMP r5, -r8.w, r5, r10;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:9\n"
				"##c:4:input0\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##c:4:input3\n"
				"##c:4:input4\n"
				"##c:1:modulus\n"
				"##c:1:length\n"
				"##c:1:lengthmodmodulus\n"
				"##oi:4:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.constant(6, 0)
				.constant(7, 0)
				.constant(8, 0)
				.constant(9, kOutputConstant_Indexof)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(9, kOutputInterpolant_Position)
				.output(9, 0)
			)
		);
	static const void* __float4streamCombine5f_arb = &__float4streamCombine5f_arb_desc;
}

void __float4streamCombine5f_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input0,
                                         const __BrtArray2d<__BrtFloat4  > &input1,
                                         const __BrtArray2d<__BrtFloat4  > &input2,
                                         const __BrtArray2d<__BrtFloat4  > &input3,
                                         const __BrtArray2d<__BrtFloat4  > &input4,
                                         const __BrtFloat1  &modulus,
                                         const __BrtFloat1  &length,
                                         const __BrtFloat1  &lengthmodmodulus,
                                         __BrtFloat4  &output,
                                         const __BrtFloat4 &__indexof_output){
  __BrtFloat2  newindex;
  __BrtFloat1  whichmod;

  __calculateDividedIndex_cpu_inner(__indexof_output,modulus,length,newindex);
  __calculateIndexModulus_cpu_inner(__indexof_output,modulus,-__BrtFloat1(0.500000f),lengthmodmodulus,whichmod);
  if (whichmod == __BrtFloat1((float)0) || whichmod == modulus)
  {
    output = input0[newindex];
  }

  else
    if (whichmod == __BrtFloat1((float)1))
    {
      output = input1[newindex];
    }

    else
      if (whichmod == __BrtFloat1((float)2))
      {
        output = input2[newindex];
      }

      else
        if (whichmod == __BrtFloat1((float)3))
        {
          output = input3[newindex];
        }

        else
        {
          output = input4[newindex];
        }

}
void  __float4streamCombine5f_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtArray2d<__BrtFloat4  > arg2(
      (__BrtFloat4  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat4  > arg3(
      (__BrtFloat4  *)args[3], extents[3]);
  __BrtArray2d<__BrtFloat4  > arg4(
      (__BrtFloat4  *)args[4], extents[4]);
  __BrtFloat1 *arg5 = (__BrtFloat1 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  __BrtFloat1 *arg7 = (__BrtFloat1 *)args[7];
  __BrtFloat4 *arg8 = (__BrtFloat4 *)args[8];
  unsigned int dim=dims[8];
  unsigned int newline=extents[8][dim-1];
  arg8+=mapbegin;
  ;
__BrtFloat4 indexof8 = computeIndexOf(mapbegin, extents[8], dims[8], extents[8]);
  unsigned int i=0; 
  while (i<mapextent) {
    __float4streamCombine5f_cpu_inner (
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      *arg5,
      *arg6,
      *arg7,
      *arg8,
      indexof8);
    i++;
    ++arg8;
indexof8.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof8 = computeReferenceIndexOf(i+mapbegin, extents[8],dim);
    }
  }
}

void  float4streamCombine5f (::brook::stream input0,
		::brook::stream input1,
		::brook::stream input2,
		::brook::stream input3,
		::brook::stream input4,
		const float  modulus,
		const float  length,
		const float  lengthmodmodulus,
		::brook::stream output) {
  static const void *__float4streamCombine5f_fp[] = {
     "fp30", __float4streamCombine5f_fp30,
     "arb", __float4streamCombine5f_arb,
     "ps20", __float4streamCombine5f_ps20,
     "cpu", (void *) __float4streamCombine5f_cpu,
     NULL, NULL };
  static __BRTKernel k(__float4streamCombine5f_fp);

  k->PushGatherStream(input0);
  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushGatherStream(input3);
  k->PushGatherStream(input4);
  k->PushConstant(modulus);
  k->PushConstant(length);
  k->PushConstant(lengthmodmodulus);
  k->PushOutput(output);
  k->Map();

}


void  combineStreamsHelperfloat4(::brook::stream (**streams), unsigned int  num, ::brook::stream output, float  modulus, float  offset, float  length, float  lengthmodmodulus)
{
  switch (num)
  {
  case 1:
    float4streamCombine1(*streams[0],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 2:
    float4streamCombine2(*streams[0],*streams[1],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 3:
    float4streamCombine3(*streams[0],*streams[1],*streams[2],modulus,offset,length,lengthmodmodulus,output,output);
    break;
  case 4:
  default:
    float4streamCombine4(*streams[0],*streams[1],*streams[2],*streams[3],modulus,offset,length,lengthmodmodulus,output,output);
    if (num > 4)
    {
      combineStreamsHelperfloat4(streams + 4,num - 4,output,modulus,4 + offset,length,lengthmodmodulus);
    }

  }

}

void  combineStreamsfloat4(::brook::stream (**streams), unsigned int  num, unsigned int  width, unsigned int  length, ::brook::stream (*output))
{
  unsigned int  lengthmodmodulus = (num != 0) ? (length % num) : (0);
  ::brook::stream tmp=quickAllocStream(::brook::getStreamType(( float4  *)0), num * width , length,-1);

  streamSwap(tmp,*output);
  switch (num)
  {
  case 0:
    return;
  case 1:
    streamSwap(*output,*streams[0]);
    break;
  case 2:
    float4streamCombine2f(*streams[0],*streams[1],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 3:
    float4streamCombine3f(*streams[0],*streams[1],*streams[2],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 4:
    float4streamCombine4f(*streams[0],*streams[1],*streams[2],*streams[3],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    break;
  case 5:
  default:
    float4streamCombine5f(*streams[0],*streams[1],*streams[2],*streams[3],*streams[4],(float ) (num),(float ) (length),(float ) (lengthmodmodulus),*output);
    if (num > MAX_VOUT_STREAMS)
    {
      fprintf(stderr,"vout stream not reconstituted properly. %s%d streams","Too little precision for more than ",MAX_VOUT_STREAMS);
    }

    if (num > 5)
    {
      combineStreamsHelperfloat4(streams + 5,num - 5,*output,(float ) (num),(float ) (5 - 0.500000f),(float ) (length),(float ) (lengthmodmodulus));
    }

  }

}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat4_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c7, 0, 0.5, -0.5, 1\n"
				"    def c8, 0.25, 0, 0, 0\n"
				"    dcl t0.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r0.x, t0.x, c2.x, c2.z\n"
				"    mad r0.y, t0.y, c2.y, c2.w\n"
				"    add r0.w, -c3.x, r0.x\n"
				"    add r7.w, r0.w, c7.y\n"
				"    frc r2.w, r7.w\n"
				"    add r4.w, r7.w, -r2.w\n"
				"    rcp r11.w, c5.x\n"
				"    mul r6.w, r4.w, r11.w\n"
				"    mul r1.w, r7.w, r11.w\n"
				"    frc r8.w, r6.w\n"
				"    mul r3.w, r8.w, c5.x\n"
				"    add r10.w, r3.w, c7.y\n"
				"    frc r5.w, r10.w\n"
				"    add r2.w, r10.w, -r5.w\n"
				"    add r4.w, -r2.w, c7.z\n"
				"    add r11.w, r2.w, c5.x\n"
				"    cmp r6.w, r4.w, r11.w, r2.w\n"
				"    add r8.w, r6.w, c8.x\n"
				"    add r10.w, r8.w, -c5.x\n"
				"    cmp r1.x, r10.w, c7.x, r6.w\n"
				"    frc r5.w, r1.w\n"
				"    add r1.w, r1.w, -r5.w\n"
				"    add r9.w, r0.y, -c3.y\n"
				"    add r1.y, r1.w, r9.w\n"
				"    mad r9.x, r1.x, c1.x, c1.z\n"
				"    mad r9.y, r1.y, c1.y, c1.w\n"
				"    mad r11.x, r0.x, c0.x, c0.z\n"
				"    mad r11.y, r0.y, c0.y, c0.w\n"
				"    texld r6, r9, s1\n"
				"    texld r8, r11, s0\n"
				"    cmp_pp r1.w, r0.w, c7.w, c7.x\n"
				"    add r0.w, r1.x, -c4.x\n"
				"    cmp_pp r0.w, r0.w, c7.w, c7.x\n"
				"    add r10.w, r1.y, -c4.y\n"
				"    abs r7.w, r10.w\n"
				"    cmp_pp r4.w, -r7.w, c7.w, c7.x\n"
				"    mul r0.w, r0.w, r4.w\n"
				"    add r3.w, -r1.y, c4.y\n"
				"    cmp_pp r10.w, r3.w, c7.x, c7.w\n"
				"    add_pp r0.w, r0.w, r10.w\n"
				"    cmp r6, -r0.w, r6, c6.x\n"
				"    abs r0.w, r9.w\n"
				"    cmp_pp r0.w, -r0.w, c7.w, c7.x\n"
				"    mul r0.w, r1.w, r0.w\n"
				"    add r1.w, -r0.y, c3.y\n"
				"    cmp_pp r5.w, r1.w, c7.x, c7.w\n"
				"    add_pp r7.w, r0.w, r5.w\n"
				"    cmp r8, -r7.w, r8, r6\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//c:4:input1\n"
				"//c:4:input2\n"
				"//oi:4:output\n"
				"//c:2:startsecond\n"
				"//c:2:endsecond\n"
				"//c:2:maxinput2value\n"
				"//c:1:inf\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat4_ps20 = &__combinefloat4_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat4_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.input1 : TEXUNIT0\n"
				"#semantic main.__gatherconst_input1 : C0\n"
				"#semantic main.input2 : TEXUNIT1\n"
				"#semantic main.__gatherconst_input2 : C1\n"
				"#semantic main._const_output_invscalebias : C2\n"
				"#semantic main.startsecond : C3\n"
				"#semantic main.endsecond : C4\n"
				"#semantic main.maxinput2value : C5\n"
				"#semantic main.inf : C6\n"
				"#semantic main.__workspace : C7\n"
				"#var samplerRECT input1[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_input1 : C0 :  : 1 : 1\n"
				"#var samplerRECT input2[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_input2 : C1 :  : 3 : 1\n"
				"#var float4 _const_output_invscalebias : C2 :  : 5 : 1\n"
				"#var float2 startsecond : C3 :  : 7 : 1\n"
				"#var float2 endsecond : C4 :  : 8 : 1\n"
				"#var float2 maxinput2value : C5 :  : 9 : 1\n"
				"#var float inf : C6 :  : 10 : 1\n"
				"#var float4 __workspace : C7 :  : 11 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD0 : TEX0 : 6 : 1\n"
				"DECLARE __gatherconst_input1;\n"
				"DECLARE __gatherconst_input2;\n"
				"DECLARE _const_output_invscalebias;\n"
				"DECLARE startsecond;\n"
				"DECLARE endsecond;\n"
				"DECLARE maxinput2value;\n"
				"DECLARE inf;\n"
				"DECLARE __workspace;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"SGTR H0.x, R0.y, startsecond.y;\n"
				"SGER H0.y, R0.x, startsecond.x;\n"
				"SEQR H0.z, R0.y, startsecond.y;\n"
				"MADX H0.x, H0.z, H0.y, H0.x;\n"
				"MINX H0.x, H0.x, {1}.x;\n"
				"ADDX H0.y, -H0.x, {1}.x;\n"
				"ADDR R0.w, R0.y, -startsecond.y;\n"
				"MOVR R1.y, R0.w;\n"
				"MOVR R1.x, R0.x;\n"
				"TEX R0, R0.xyxx, TEX0, RECT;\n"
				"ADDR R1.w, R1.x, -startsecond.x;\n"
				"ADDR R2.x, {0.5}.x, R1.w;\n"
				"MOVR R3.x, R1.w;\n"
				"RCPR R1.w, maxinput2value.x;\n"
				"MULR R1.w, R2.x, R1.w;\n"
				"FLRR R1.w, R1.w;\n"
				"ADDR R1.w, R1.y, R1.w;\n"
				"MOVR R3.y, R1.w;\n"
				"ADDR R1.x, R3.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLTR H0.z, R1.x, {0}.x;\n"
				"RCPR R1.y, maxinput2value.x;\n"
				"MULR R1.y, R1.x, R1.y;\n"
				"FRCR R1.y, |R1.y|;\n"
				"MULR R1.y, R1.y, |maxinput2value.x|;\n"
				"MOVR R1.x, R1.y;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R1.x(GT.x), -R1.y;\n"
				"ADDR R1.x, R1.x, {0.5}.x;\n"
				"FLRR R1.x, R1.x;\n"
				"SLER H0.z, R1.x, {-0.5}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVR R3.x, R1.x;\n"
				"ADDR R1.x, R1.x, maxinput2value.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), R1.x;\n"
				"ADDR R1.x, R3.x, {0.25}.x;\n"
				"SGER H0.z, R1.x, maxinput2value.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R3.x(GT.x), {0}.x;\n"
				"SGTR H0.z, R3.y, endsecond.y;\n"
				"SGER H0.w, R3.x, endsecond.x;\n"
				"SEQR H1.x, R3.y, endsecond.y;\n"
				"MADX H0.z, H1.x, H0.w, H0.z;\n"
				"MINX H0.z, H0.z, {1}.x;\n"
				"ADDX H0.z, -H0.z, {1}.x;\n"
				"MULX H0.z, H0.x, H0.z;\n"
				"TEX R1, R3.xyxx, TEX1, RECT;\n"
				"MOVR o[COLR], inf.x;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR o[COLR](GT.x), R1;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR o[COLR](GT.x), R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##oi:4:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat4_fp30 = &__combinefloat4_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __combinefloat4_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = program.local[5];\n"
				"PARAM c6 = program.local[6];\n"
				"PARAM c7 = {0, 0.5, -0.5, 1};\n"
				"PARAM c8 = {0.25, 0, 0, 0};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"MAD r0.x, t0.x, c2.x, c2.z;\n"
				"MAD r0.y, t0.y, c2.y, c2.w;\n"
				"ADD r0.w, -c3.x, r0.x;\n"
				"ADD r7.w, r0.w, c7.y;\n"
				"FRC r2.w, r7.w;\n"
				"ADD r4.w, r7.w, -r2.w;\n"
				"RCP r11.w, c5.x;\n"
				"MUL r6.w, r4.w, r11.w;\n"
				"MUL r1.w, r7.w, r11.w;\n"
				"FRC r8.w, r6.w;\n"
				"MUL r3.w, r8.w, c5.x;\n"
				"ADD r10.w, r3.w, c7.y;\n"
				"FRC r5.w, r10.w;\n"
				"ADD r2.w, r10.w, -r5.w;\n"
				"ADD r4.w, -r2.w, c7.z;\n"
				"ADD r11.w, r2.w, c5.x;\n"
				"CMP r6.w, r4.w, r2.w, r11.w;\n"
				"ADD r8.w, r6.w, c8.x;\n"
				"ADD r10.w, r8.w, -c5.x;\n"
				"CMP r1.x, r10.w, r6.w, c7.x;\n"
				"FRC r5.w, r1.w;\n"
				"ADD r1.w, r1.w, -r5.w;\n"
				"ADD r9.w, r0.y, -c3.y;\n"
				"ADD r1.y, r1.w, r9.w;\n"
				"MAD r9.x, r1.x, c1.x, c1.z;\n"
				"MAD r9.y, r1.y, c1.y, c1.w;\n"
				"MAD r11.x, r0.x, c0.x, c0.z;\n"
				"MAD r11.y, r0.y, c0.y, c0.w;\n"
				"TEX r6, r9, texture[1], RECT;\n"
				"TEX r8, r11, texture[0], RECT;\n"
				"CMP r1.w, r0.w, c7.x, c7.w;\n"
				"ADD r0.w, r1.x, -c4.x;\n"
				"CMP r0.w, r0.w, c7.x, c7.w;\n"
				"ADD r10.w, r1.y, -c4.y;\n"
				"ABS r7.w, r10.w;\n"
				"CMP r4.w, -r7.w, c7.x, c7.w;\n"
				"MUL r0.w, r0.w, r4.w;\n"
				"ADD r3.w, -r1.y, c4.y;\n"
				"CMP r10.w, r3.w, c7.w, c7.x;\n"
				"ADD r0.w, r0.w, r10.w;\n"
				"CMP r6, -r0.w, c6.x, r6;\n"
				"ABS r0.w, r9.w;\n"
				"CMP r0.w, -r0.w, c7.x, c7.w;\n"
				"MUL r0.w, r1.w, r0.w;\n"
				"ADD r1.w, -r0.y, c3.y;\n"
				"CMP r5.w, r1.w, c7.w, c7.x;\n"
				"ADD r7.w, r0.w, r5.w;\n"
				"CMP r8, -r7.w, r6, r8;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##c:4:input1\n"
				"##c:4:input2\n"
				"##oi:4:output\n"
				"##c:2:startsecond\n"
				"##c:2:endsecond\n"
				"##c:2:maxinput2value\n"
				"##c:1:inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(3, kOutputConstant_Indexof)
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.constant(7, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(3, kOutputInterpolant_Position)
				.output(3, 0)
			)
		);
	static const void* __combinefloat4_arb = &__combinefloat4_arb_desc;
}

void __combinefloat4_cpu_inner (const __BrtArray2d<__BrtFloat4  > &input1,
                                 const __BrtArray2d<__BrtFloat4  > &input2,
                                 __BrtFloat4  &output,
                                 const __BrtFloat2  &startsecond,
                                 const __BrtFloat2  &endsecond,
                                 const __BrtFloat2  &maxinput2value,
                                 const __BrtFloat1  &inf,
                                 const __BrtFloat4 &__indexof_output){
  if ((__indexof_output).swizzle1(maskY) > startsecond.swizzle1(maskY) || (__indexof_output).swizzle1(maskY) == startsecond.swizzle1(maskY) && (__indexof_output).swizzle1(maskX) >= startsecond.swizzle1(maskX))
  {
    __BrtFloat2  secondindex;

    __getIndexAt_cpu_inner(__BrtFloat4 ((__indexof_output).swizzle1(maskX),(__indexof_output).swizzle1(maskY) - startsecond.swizzle1(maskY),__BrtFloat1((float)0),__BrtFloat1((float)0)),-startsecond.swizzle1(maskX),maxinput2value,secondindex);
    if (secondindex.swizzle1(maskY) > endsecond.swizzle1(maskY) || secondindex.swizzle1(maskY) == endsecond.swizzle1(maskY) && secondindex.swizzle1(maskX) >= endsecond.swizzle1(maskX))
    {
      output = inf;
    }

    else
    {
      output = input2[secondindex];
    }

  }

  else
  {
    output = input1[__indexof_output];
  }

}
void  __combinefloat4_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __BrtArray2d<__BrtFloat4  > arg0(
      (__BrtFloat4  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat4  > arg1(
      (__BrtFloat4  *)args[1], extents[1]);
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat1 *arg6 = (__BrtFloat1 *)args[6];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  ;
__BrtFloat4 indexof2 = computeIndexOf(mapbegin, extents[2], dims[2], extents[2]);
  unsigned int i=0; 
  while (i<mapextent) {
    __combinefloat4_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      indexof2);
    i++;
    ++arg2;
indexof2.unsafeGetAt(0)++;
    if ((mapbegin+i)%newline==0) {
      indexof2 = computeReferenceIndexOf(i+mapbegin, extents[2],dim);
    }
  }
}

void  combinefloat4 (::brook::stream input1,
		::brook::stream input2,
		::brook::stream output,
		const float2  startsecond,
		const float2  endsecond,
		const float2  maxinput2value,
		const float  inf) {
  static const void *__combinefloat4_fp[] = {
     "fp30", __combinefloat4_fp30,
     "arb", __combinefloat4_arb,
     "ps20", __combinefloat4_ps20,
     "cpu", (void *) __combinefloat4_cpu,
     NULL, NULL };
  static __BRTKernel k(__combinefloat4_fp);

  k->PushGatherStream(input1);
  k->PushGatherStream(input2);
  k->PushOutput(output);
  k->PushConstant(startsecond);
  k->PushConstant(endsecond);
  k->PushConstant(maxinput2value);
  k->PushConstant(inf);
  k->Map();

}


unsigned int  voutCombinefloat4(::brook::stream outleft_stream, float  maxshiftleft, unsigned int  LEFTWIDTH, ::brook::stream outright_stream, float  maxshiftright, unsigned int  RIGHTWIDTH, unsigned int  LENGTH, ::brook::stream (*output))
{
  unsigned int  totalsize;
  float2  maxleftvalue;
  float2  maxrightvalue;

  maxleftvalue.x = (float ) (LENGTH);
  maxleftvalue.y = (float ) (LEFTWIDTH);
  maxrightvalue.x = (float ) (LENGTH);
  maxrightvalue.y = (float ) (RIGHTWIDTH);
  totalsize = LEFTWIDTH * LENGTH + RIGHTWIDTH * LENGTH - (unsigned int ) (maxshiftleft) - (unsigned int ) (maxshiftright);
  if (1)
  {
    unsigned int  length = LENGTH;
    unsigned int  width = totalsize / length + ((totalsize % length != 0) ? (1) : (0));
    ::brook::stream output_stream=quickAllocStream(::brook::getStreamType(( float4  *)0), width , length,-1);
    float2  startsecond;
    float2  endsecond;

    cpuGetIndexAt(float2 (maxleftvalue.x,maxleftvalue.y - 1),-maxshiftleft,maxleftvalue,&startsecond);
    cpuGetIndexAt(float2 (maxrightvalue.x,maxrightvalue.y - 1),-maxshiftright,maxrightvalue,&endsecond);
    combinefloat4(outleft_stream,outright_stream,output_stream,startsecond,endsecond,maxrightvalue,1.000000f / (float ) (floor(0.500000f)));
    streamSwap(*output,output_stream);
  }

  return totalsize;
}

unsigned int  totalCombineVoutfloat4(::brook::stream list_stream, unsigned int  WIDTH, ::brook::stream list2_stream, unsigned int  WIDTH2, unsigned int  LENGTH, ::brook::stream (*output))
{
  ::brook::stream outleft_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH , LENGTH,-1);
  ::brook::stream outright_stream=quickAllocStream(::brook::getStreamType(( float  *)0), WIDTH2 , LENGTH,-1);
  float  maxshiftleft = shiftValuesfloat4(list_stream,&outleft_stream,WIDTH,LENGTH,-1);
  float  maxshiftright = shiftValuesfloat4(list2_stream,&outright_stream,WIDTH2,LENGTH,-1);

  return voutCombinefloat4(outleft_stream,maxshiftleft,WIDTH,outright_stream,maxshiftright,WIDTH2,LENGTH,output);
}

#undef VECTOR_TEMPLATIZED_FUNCTIONS


