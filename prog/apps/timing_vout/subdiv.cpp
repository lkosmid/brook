
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Mar 29 2004 17:20:37
////////////////////////////////////////////

#include <brook.hpp>
#include <stdio.h>

#include <stdlib.h>

typedef struct STri_t {
  float4  A;
  float4  B;
  float4  C;
} STri;typedef struct __cpustruct_STri_t {
__BrtFloat4 A;
__BrtFloat4 B;
__BrtFloat4 C;
}
__cpustruct_STri;

namespace brook {
	template<> const __BRTStreamType* getStreamType(STri*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct SplitTri_t {
  float4  A;
  float4  AB;
  float4  B;
  float4  BC;
  float4  C;
  float4  AC;
} SplitTri;typedef struct __cpustruct_SplitTri_t {
__BrtFloat4 A;
__BrtFloat4 AB;
__BrtFloat4 B;
__BrtFloat4 BC;
__BrtFloat4 C;
__BrtFloat4 AC;
}
__cpustruct_SplitTri;

namespace brook {
	template<> const __BRTStreamType* getStreamType(SplitTri*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct Neighbor_t {
  float4  AB;
  float4  BBC;
  float4  ABB;
  float4  BC;
  float4  ACC;
  float4  BCC;
  float4  AC;
  float4  AAB;
  float4  AAC;
} Neighbor;typedef struct __cpustruct_Neighbor_t {
__BrtFloat4 AB;
__BrtFloat4 BBC;
__BrtFloat4 ABB;
__BrtFloat4 BC;
__BrtFloat4 ACC;
__BrtFloat4 BCC;
__BrtFloat4 AC;
__BrtFloat4 AAB;
__BrtFloat4 AAC;
}
__cpustruct_Neighbor;

namespace brook {
	template<> const __BRTStreamType* getStreamType(Neighbor*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

extern unsigned char  debugLoop;
extern int  counterMax;
extern float  neighboreps;
extern int  low_texture_ram;
extern int  subdivisiondepth;
void  recomputeNeighbors(STri *, Neighbor *, unsigned int );
void  checkNeighbors(STri  *tri, Neighbor  *in, Neighbor *out , unsigned int );
void produceTriP(::brook::stream t,
                 ::brook::stream &__shouldProduce_stream,
                 ::brook::stream &__shouldNotProduce_stream);
void  writeFinalTriangles (::brook::stream triangles,
                           ::brook::stream indices,
                           ::brook::stream triList);
void  computeNeighbors (::brook::stream tgather,
                        ::brook::stream ugather,
                        ::brook::stream i,
                        ::brook::stream v);
void  splitTriangles (::brook::stream triangles,
                      ::brook::stream neighbors,
                      ::brook::stream i,
                      ::brook::stream splittri);
void  linearReorgSplitTriangles (::brook::stream splittri,
                                 ::brook::stream newnei,
                                 ::brook::stream tri,
                                 ::brook::stream neighbor,
                                 const float  epsilon,
                                 const float  stretchX);
void  copyFinalTriangles (::brook::stream tri,
                          ::brook::stream triList);
void  smallEnough (::brook::stream t,
                   ::brook::stream u,
                   ::brook::stream v,
                   ::brook::stream n,
                   const float  epsilon);
struct VertexArray {
  float3  *v;
  unsigned int  size;
  unsigned int  alloc;
};
void  initVertexArray(struct VertexArray  *v)
{
  v->v = 0;
  v->size = 0;
  v->alloc = 0;
}

void  destroyVertexArray(struct VertexArray  *v)
{
  if (v->v)
    free(v->v);
}

void  expandVertexArray(struct VertexArray  *v, unsigned int  more)
{
  v->size += more;
  while (v->size > v->alloc)
  {
    if (v->alloc == 0)
      v->alloc = 16;
    v->alloc *= 2;
    v->v = (float3 *) (realloc(v->v,v->alloc * sizeof(float3 ) ));
  }

}

void  pushBackVertexArray(struct VertexArray  *v, float3  f)
{
  if (++v->size > v->alloc)
  {
    if (v->alloc == 0)
      v->alloc = 16;
    v->alloc *= 2;
    v->v = (float3 *) (realloc(v->v,v->alloc * sizeof(float3 ) ));
  }

  v->v[v->size - 1] = f;
}

static int  toi(float  f)
{
  return (int ) (f);
}

void  subdivide(::brook::stream (*neighbors), ::brook::stream (*triangles), struct VertexArray  *output, float  epsilon, int  counter)
{
  unsigned int  streamY = toi(streamSize(*triangles).y);
  unsigned int  streamX = toi(streamSize(*triangles).x);
  unsigned char  snpSize = 0;

  subdivisiondepth++;
  {
    ::brook::stream shouldProduce(::brook::getStreamType(( float2  *)0), streamY , 0,-1);
    ::brook::stream shouldNotProduce(::brook::getStreamType(( float2  *)0), streamY , 0,-1);

    produceTriP(*triangles,shouldProduce,shouldNotProduce);
    assert((int ) (streamX) == toi(streamSize(shouldProduce).x));
    {
      int  wosizex = 3 * toi(streamSize(shouldNotProduce).x);
      int  wosizey = toi(streamSize(shouldNotProduce).y);
      ::brook::stream outputTri(::brook::getStreamType(( float3  *)0), wosizey , wosizex,-1);

      if (wosizex && wosizey)
        writeFinalTriangles(*triangles,shouldNotProduce,outputTri);
      streamY = toi(streamSize(shouldProduce).y);
      if (streamY && streamX)
      {
        float  stretchX = (streamY * 4 > 2048) ? (0.000000f) : (1.000000f);
        ::brook::stream sharedNeighbors(::brook::getStreamType(( Neighbor  *)0), streamY , streamX,-1);
        ::brook::stream sharedTriangles(::brook::getStreamType(( SplitTri  *)0), streamY , streamX,-1);
        ::brook::stream newNeighbors(::brook::getStreamType(( Neighbor  *)0), (stretchX) ? (streamY) : (streamY * 4) , (stretchX) ? (streamX * 4) : (streamX),-1);
        ::brook::stream newTriangles(::brook::getStreamType(( STri  *)0), (stretchX) ? (streamY) : (streamY * 4) , (stretchX) ? (streamX * 4) : (streamX),-1);

        computeNeighbors(*triangles,*neighbors,shouldProduce,sharedNeighbors);
        splitTriangles(*triangles,*neighbors,shouldProduce,sharedTriangles);
        linearReorgSplitTriangles(sharedTriangles,sharedNeighbors,newTriangles,newNeighbors,epsilon,stretchX);
        streamSwap(*triangles,newTriangles);
        streamSwap(*neighbors,newNeighbors);
        if (debugLoop)
        {
          STri  *tri;
          Neighbor  *neigh;
          Neighbor  *checknei;
          unsigned int  totalsize;

          totalsize = (unsigned int ) (streamSize(*triangles).x) * (unsigned int ) (streamSize(*triangles).y);
          tri = (STri *) (malloc(sizeof(STri )  * totalsize));
          neigh = (Neighbor *) (malloc(sizeof(Neighbor )  * totalsize));
          checknei = (Neighbor *) (malloc(sizeof(Neighbor )  * totalsize));
          streamWrite(*neighbors,neigh);
          streamWrite(*triangles,tri);
          recomputeNeighbors(tri,checknei,totalsize);
          checkNeighbors(tri,neigh,checknei,totalsize);
          free(tri);
          free(neigh);
          free(checknei);
        }

      }

      if (streamSize(shouldNotProduce).y)
      {
        snpSize = 1;
        if (!low_texture_ram && streamSize(shouldProduce).y && streamSize(shouldProduce).x && counter < counterMax)
        {
          subdivide(neighbors,triangles,output,epsilon,counter + 1);
        }

        wosizey = output->size;
        expandVertexArray(output,(unsigned int ) (streamSize(outputTri).x * streamSize(outputTri).y));
        streamWrite(outputTri,output->v + wosizey);
      }

    }

    if (counter >= counterMax)
    {
      ::brook::stream outputTri(::brook::getStreamType(( float3  *)0), toi(streamSize(*triangles).y) , toi(streamSize(*triangles).x * 3),-1);
      int  sizey = output->size;

      copyFinalTriangles(*triangles,outputTri);
      expandVertexArray(output,3 * toi(streamSize(*triangles).y) * toi(streamSize(*triangles).x));
      streamWrite(outputTri,output->v + sizey);
    }

  }

  if ((low_texture_ram || snpSize == 0) && streamY && streamX && counter < counterMax)
  {
    subdivide(neighbors,triangles,output,epsilon,counter + 1);
  }

}

extern unsigned int  loadModelData(const char  *filename, STri  **tris, Neighbor  **nei);
STri  *createTriangles(unsigned int  howMany)
{
  STri  *ret;

  ret = (STri *) (malloc(sizeof(STri )  * howMany));
  memset(ret,0,sizeof(STri )  * howMany);
  return ret;
}

Neighbor  *createNeighbors(STri  *tri, unsigned int  howMany)
{
  Neighbor  *ret;

  ret = (Neighbor *) (malloc(sizeof(Neighbor )  * howMany));
  memset(ret,0,sizeof(Neighbor )  * howMany);
  return ret;
}

void  bestHeiWid(unsigned int  totalSize, unsigned int  *hei, unsigned int  *wid)
{
  int  slop = totalSize * 2;
  int  maxy = 0;
  int  best = 11;
  unsigned int  i;

  for (i = 0; i < 12; ++i)
  {
    int  x = 1 << i;
    int  y = totalSize / x + ((totalSize % x == 0) ? (0) : (1));
    int  tslop;

    if (x > 2048 || y > 2048)
      continue;
    tslop = x * y - totalSize;
    if (tslop < 0)
      continue;
    if (tslop < slop && y > maxy || y > maxy && tslop < 2 * y / 3)
    {
      *hei = y;
      *wid = x;
      maxy = y;
      slop = tslop;
      best = i;
    }

  }

}

unsigned int  bestHeight(unsigned int  totalSize)
{
  unsigned int  hei = 0;
  unsigned int  wid = 0;

  bestHeiWid(totalSize,&hei,&wid);
  return hei;
}

unsigned int  bestWidth(unsigned int  totalSize)
{
  unsigned int  hei = 0;
  unsigned int  wid = 0;

  bestHeiWid(totalSize,&hei,&wid);
  return wid;
}

extern void  computeFunctionCallPattern(float  epsilon, int  argc, char  **argv, int  numTri, STri  *triangles, Neighbor  *neigh);
unsigned int  loadModelData(char  *file, STri  **triangles, Neighbor  **neighbors);
int  subdivision(int  argc, char  **argv)
{
  unsigned int  i = 0;
  unsigned int  vcount = 0;
  float  epsilon = 0.000100f;
  STri  *triangledata = 0;
  Neighbor  *neighbordata = 0;
  unsigned int  numTriangles;

  neighboreps = epsilon / 1024.000000f;
  for (i = 0; i < (unsigned int ) (argc); ++i)
  {
    char  match = 0;
    int  j;

    if (strcmp(argv[i],"-debug") == 0)
    {
      match = 1;
      debugLoop = 1;
    }

    if (strncmp(argv[i],"-epsilon",8) == 0)
    {
      epsilon = (float ) (atof(argv[i] + 8));
      match = 1;
    }

    if (strncmp(argv[i],"-counter",8) == 0)
    {
      counterMax = (int ) (atoi(argv[i] + 8));
      match = 1;
    }

    if (strncmp(argv[i],"-eps",4) == 0)
    {
      epsilon = (float ) (atof(argv[i] + 4));
      match = 1;
    }

    if (match)
    {
      for (j = i + 1; j < argc; ++j)
        argv[j - 1] = argv[j];
      argc--;
      i--;
    }

  }

  epsilon *= epsilon;
  numTriangles = loadModelData((argc > 1) ? (argv[1]) : ("dragon.ply"),&triangledata,&neighbordata);
  {
    ::brook::stream neighbors(::brook::getStreamType(( Neighbor  *)0), bestHeight(numTriangles) , bestWidth(numTriangles),-1);
    ::brook::stream triangles(::brook::getStreamType(( STri  *)0), bestHeight(numTriangles) , bestWidth(numTriangles),-1);
    struct VertexArray  v;

    streamRead(triangles,triangledata);
    streamRead(neighbors,neighbordata);
    initVertexArray(&v);
    smallEnough(triangles,neighbors,triangles,neighbors,epsilon);
    if (0)
    {
      for (i = 0; i < numTriangles; i++)
      {
        int  j;

        fprintf(stderr,"#\n");
        for (j = 0; j < 9; j++)
        {
          float4  *temp;

          temp = (float4 *) (&neighbordata[i]) + j;
          fprintf(stderr,"%f, %f, %f, %f\n",temp->x,temp->y,temp->z,temp->w);
        }

      }

    }

    if (1)
      subdivide(&neighbors,&triangles,&v,epsilon,0);
    else
    {
      ::brook::stream outputTri(::brook::getStreamType(( float3  *)0), toi(streamSize(triangles).y) , toi(streamSize(triangles).x * 3),-1);
      int  sizey = v.size;

      copyFinalTriangles(triangles,outputTri);
      expandVertexArray(&v,3 * toi(streamSize(triangles).y) * toi(streamSize(triangles).x));
      streamWrite(outputTri,v.v + sizey);
    }

    printf("%d\n",v.size);
    for (i = 0; i < v.size; i++)
    {
      printf("%3.3f, %3.3f, %3.3f\n",v.v[i].x,v.v[i].y,v.v[i].z);
    }

    vcount = numTriangles;
    for (i = 0; i < (unsigned int ) (subdivisiondepth); ++i)
    {
      vcount *= 4;
    }

    fprintf(stderr,"Num Rounds %d Adaptive Num Triangles %d Num Triangles %d\n",subdivisiondepth,v.size / 3,vcount);
    return 0;
  }

}


