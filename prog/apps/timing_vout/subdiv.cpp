
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Mar 29 2004 17:20:37
////////////////////////////////////////////

#include <brook.hpp>
#include "timing.h"
#include <stdio.h>

#include <stdlib.h>
static int rr=0;
using namespace std;
typedef struct STri_t {
  float4  A;
  float4  B;
  float4  C;
} STri;typedef struct __cpustruct_STri_t {
__BrtFloat4 A;
__BrtFloat4 B;
__BrtFloat4 C;
}
__cpustruct_STri;

namespace brook {
	template<> const __BRTStreamType* getStreamType(STri*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}
void Aggregate3(brook::stream threefloat, brook::stream in, brook::stream out);
void Aggregate2(brook::stream threefloat, brook::stream in, brook::stream out);
typedef struct SplitTri_t {
  float4  A;
  float4  AB;
  float4  B;
  float4  BC;
  float4  C;
  float4  AC;
} SplitTri;typedef struct __cpustruct_SplitTri_t {
__BrtFloat4 A;
__BrtFloat4 AB;
__BrtFloat4 B;
__BrtFloat4 BC;
__BrtFloat4 C;
__BrtFloat4 AC;
}
__cpustruct_SplitTri;

namespace brook {
	template<> const __BRTStreamType* getStreamType(SplitTri*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct Neighbor_t {
  float4  AB;
  float4  BBC;
  float4  ABB;
  float4  BC;
  float4  ACC;
  float4  BCC;
  float4  AC;
  float4  AAB;
  float4  AAC;
} Neighbor;typedef struct __cpustruct_Neighbor_t {
__BrtFloat4 AB;
__BrtFloat4 BBC;
__BrtFloat4 ABB;
__BrtFloat4 BC;
__BrtFloat4 ACC;
__BrtFloat4 BCC;
__BrtFloat4 AC;
__BrtFloat4 AAB;
__BrtFloat4 AAC;
}
__cpustruct_Neighbor;

namespace brook {
	template<> const __BRTStreamType* getStreamType(Neighbor*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

extern unsigned char  debugLoop;
extern int  counterMax;
extern float  neighboreps;
extern int  low_texture_ram;
extern int  subdivisiondepth;
void  recomputeNeighbors(STri *, Neighbor *, unsigned int );
void  checkNeighbors(STri  *tri, Neighbor  *in, Neighbor *out , unsigned int );
void produceTriP(::brook::stream t,
                 ::brook::stream &__shouldProduce_stream,
                 ::brook::stream &__shouldNotProduce_stream);
void  writeFinalTriangles (::brook::stream triangles,
                           ::brook::stream indices,
                           ::brook::stream triList);
void  computeNeighbors (::brook::stream tgather,
                        ::brook::stream ugather,
                        ::brook::stream i,
                        ::brook::stream v);
void  splitTriangles (::brook::stream triangles,
                      ::brook::stream neighbors,
                      ::brook::stream i,
                      ::brook::stream splittri);
void  linearReorgSplitTriangles (::brook::stream splittri,
                                 ::brook::stream newnei,
                                 ::brook::stream tri,
                                 ::brook::stream neighbor,
                                 const float  epsilon,
                                 const float  stretchX);
void  copyFinalTriangles (::brook::stream tri,
                          ::brook::stream triList);
void  smallEnough (::brook::stream t,
                   ::brook::stream u,
                   ::brook::stream v,
                   ::brook::stream n,
                   const float  epsilon);
struct VertexArray {
  float3  *v;
  unsigned int  size;
  unsigned int  alloc;
};
void  initVertexArray(struct VertexArray  *v)
{
  v->v = 0;
  v->size = 0;
  v->alloc = 0;
}

void  destroyVertexArray(struct VertexArray  *v)
{
  if (v->v)
    free(v->v);
}

void  expandVertexArray(struct VertexArray  *v, unsigned int  more)
{
  v->size += more;
  while (v->size > v->alloc)
  {
    if (v->alloc == 0)
      v->alloc = 16;
    v->alloc *= 2;
    v->v = (float3 *) (realloc(v->v,v->alloc * sizeof(float3 ) ));
  }

}

void  pushBackVertexArray(struct VertexArray  *v, float3  f)
{
  if (++v->size > v->alloc)
  {
    if (v->alloc == 0)
      v->alloc = 16;
    v->alloc *= 2;
    v->v = (float3 *) (realloc(v->v,v->alloc * sizeof(float3 ) ));
  }

  v->v[v->size - 1] = f;
}

static int  toi(float  f)
{
  return (int ) (f);
}
void  produceTriPNoCompact (::brook::stream t,
                            ::brook::stream shouldProduce,
                            ::brook::stream shouldNotProduce);
void  subdivide(::brook::stream (*neighbors), ::brook::stream (*triangles), struct VertexArray  *output, float  epsilon, int  counter)
{
  unsigned int  streamY = toi(streamSize(*triangles).y);
  unsigned int  streamX = toi(streamSize(*triangles).x);
  unsigned char  snpSize = 0;
  if (rr==0) {
     subdivisiondepth++;
  }
  static vector <brook::stream> spvec;
  static vector <brook::stream> snpvec;
  static vector <brook::stream> otvec;
  static vector <brook::stream> snvec;
  static vector <brook::stream> stvec;
  static vector <brook::stream> nnvec;
  static vector <brook::stream> ntvec;
  static vector <brook::stream> fotvec;
  static vector <brook::stream> vospvec;
  static vector <brook::stream> vosnpvec;

  static ::brook::stream acc (::brook::getStreamType((float*)0),1,1,-1);
  if (rr==0) {
     spvec.push_back(brook::stream());
     snpvec.push_back(brook::stream());

     otvec.push_back(brook::stream());
     snvec.push_back(brook::stream());
     stvec.push_back(brook::stream());
     nnvec.push_back(brook::stream());
     ntvec.push_back(brook::stream());
     fotvec.push_back(brook::stream());
     
     vospvec.push_back(brook::stream(::brook::getStreamType((float2*)0),streamY,streamX,-1));
  }
  {
    if (rr==0) spvec[counter]=brook::stream(::brook::getStreamType(( float2  *)0), streamY , 0,-1);
    if (rr==0) snpvec[counter]=brook::stream(::brook::getStreamType(( float2  *)0), streamY , 0,-1);
    if (rr<2) {
       if (rr==0) {
          TallyKernel("produceTriP",*triangles);
       }
       produceTriP(*triangles,spvec[counter],snpvec[counter]);
    }else {
       produceTriPNoCompact(*triangles,vospvec[counter],vospvec[counter])
          ;
       Aggregate2(vospvec[counter],acc,acc);
    }
    ::brook::stream shouldProduce=spvec[counter];
    ::brook::stream shouldNotProduce=snpvec[counter];
    assert((int ) (streamX) == toi(streamSize(shouldProduce).x));
    {
      int  wosizex = 3 * toi(streamSize(shouldNotProduce).x);
      int  wosizey = toi(streamSize(shouldNotProduce).y);
      if (rr==0) otvec[counter]=brook::stream(::brook::getStreamType(( float3  *)0), wosizey , wosizex,-1);
      ::brook::stream outputTri=otvec[counter];

      if (wosizex && wosizey) {
        if (rr==0) {
           TallyKernel("writeFinalTriangles",outputTri);
        }
        writeFinalTriangles(*triangles,shouldNotProduce,outputTri);
      }
      streamY = toi(streamSize(shouldProduce).y);
      if (streamY && streamX)
      {
        float  stretchX = (streamY * 4 > 2048) ? (0.000000f) : (1.000000f);
        if (rr==0) snvec[counter]=brook::stream(::brook::getStreamType(( Neighbor  *)0), streamY , streamX,-1);
        ::brook::stream sharedNeighbors=snvec[counter];
        if(rr==0) stvec[counter]=brook::stream(::brook::getStreamType(( SplitTri  *)0), streamY , streamX,-1);
        ::brook::stream sharedTriangles=stvec[counter];
        if (rr==0) nnvec[counter]=brook::stream(::brook::getStreamType(( Neighbor  *)0), (stretchX) ? (streamY) : (streamY * 4) , (stretchX) ? (streamX * 4) : (streamX),-1);
        ::brook::stream newNeighbors=nnvec[counter];
        if (rr==0) ntvec[counter]=brook::stream(::brook::getStreamType(( STri  *)0), (stretchX) ? (streamY) : (streamY * 4) , (stretchX) ? (streamX * 4) : (streamX),-1);
        ::brook::stream newTriangles=ntvec[counter];
        if (rr==0) {
           TallyKernel("computeNeighbors",sharedNeighbors);
           TallyKernel("splitTriangles",sharedTriangles);
           TallyKernel("linearReorgSplitTriangles",newTriangles);
        }
        computeNeighbors(*triangles,*neighbors,shouldProduce,sharedNeighbors);
        splitTriangles(*triangles,*neighbors,shouldProduce,sharedTriangles);
        linearReorgSplitTriangles(sharedTriangles,sharedNeighbors,newTriangles,newNeighbors,epsilon,stretchX);
        streamSwap(*triangles,newTriangles);
        streamSwap(*neighbors,newNeighbors);
      }

      if (streamSize(shouldNotProduce).y)
      {
        snpSize = 1;
        if (!low_texture_ram && streamSize(shouldProduce).y && streamSize(shouldProduce).x && counter < counterMax)
        {
          subdivide(neighbors,triangles,output,epsilon,counter + 1);
        }
        if (debugLoop) {
           wosizey = output->size;
           expandVertexArray(output,(unsigned int ) (streamSize(outputTri).x * streamSize(outputTri).y));
           streamWrite(outputTri,output->v + wosizey);
        }else {
           Aggregate3 (outputTri,acc,acc);
        }
      }

    }

    if (counter >= counterMax)
    {
       if (rr==0) fotvec[counter]=brook::stream(::brook::getStreamType(( float3  *)0), toi(streamSize(*triangles).y) , toi(streamSize(*triangles).x * 3),-1);
       ::brook::stream outputTri=fotvec[counter];
      int  sizey = output->size;
      if (rr==0) {
         TallyKernel("copyFinalTriangles",outputTri);
      }
      copyFinalTriangles(*triangles,outputTri);
      if (debugLoop) {
         expandVertexArray(output,3 * toi(streamSize(*triangles).y) * toi(streamSize(*triangles).x));
         streamWrite(outputTri,output->v + sizey);
      }else {
         Aggregate3 (outputTri,acc,acc);
         
      }
    }

  }
  if (!(counter<counterMax)) {
     float4 agg;
     streamWrite(acc,&agg);
  }
  if ((low_texture_ram || snpSize == 0) && streamY && streamX && counter < counterMax)
  {
    subdivide(neighbors,triangles,output,epsilon,counter + 1);
  }

}

extern unsigned int  loadModelData(const char  *filename, STri  **tris, Neighbor  **nei);
STri  *createTriangles(unsigned int  howMany)
{
  STri  *ret;

  ret = (STri *) (malloc(sizeof(STri )  * howMany));
  memset(ret,0,sizeof(STri )  * howMany);
  return ret;
}

Neighbor  *createNeighbors(STri  *tri, unsigned int  howMany)
{
  Neighbor  *ret;

  ret = (Neighbor *) (malloc(sizeof(Neighbor )  * howMany));
  memset(ret,0,sizeof(Neighbor )  * howMany);
  return ret;
}

void  bestHeiWid(unsigned int  totalSize, unsigned int  *hei, unsigned int  *wid)
{
  int  slop = totalSize * 2;
  int  maxy = 0;
  int  best = 11;
  unsigned int  i;

  for (i = 0; i < 12; ++i)
  {
    int  x = 1 << i;
    int  y = totalSize / x + ((totalSize % x == 0) ? (0) : (1));
    int  tslop;

    if (x > 2048 || y > 2048)
      continue;
    tslop = x * y - totalSize;
    if (tslop < 0)
      continue;
    if (tslop < slop && y > maxy || y > maxy && tslop < 2 * y / 3)
    {
      *hei = y;
      *wid = x;
      maxy = y;
      slop = tslop;
      best = i;
    }

  }

}

unsigned int  bestHeight(unsigned int  totalSize)
{
  unsigned int  hei = 0;
  unsigned int  wid = 0;

  bestHeiWid(totalSize,&hei,&wid);
  return hei;
}

unsigned int  bestWidth(unsigned int  totalSize)
{
  unsigned int  hei = 0;
  unsigned int  wid = 0;

  bestHeiWid(totalSize,&hei,&wid);
  return wid;
}

extern void  computeFunctionCallPattern(float  epsilon, int  argc, char  **argv, int  numTri, STri  *triangles, Neighbor  *neigh);
unsigned int  loadModelData(char  *file, STri  **triangles, Neighbor  **neighbors);
int  subdivision(int  argc, char  **argv)
{
  unsigned int  i = 0;
  unsigned int  vcount = 0;
  float  epsilon = 0.000100f;
  STri  *triangledata = 0;
  Neighbor  *neighbordata = 0;
  unsigned int  numTriangles;

  neighboreps = epsilon / 1024.000000f;
  for (i = 0; i < (unsigned int ) (argc); ++i)
  {
    char  match = 0;
    int  j;

    if (strcmp(argv[i],"-debug") == 0)
    {
      match = 1;
      debugLoop = 1;
    }

    if (strncmp(argv[i],"-epsilon",8) == 0)
    {
      epsilon = (float ) (atof(argv[i] + 8));
      match = 1;
    }

    if (strncmp(argv[i],"-counter",8) == 0)
    {
      counterMax = (int ) (atoi(argv[i] + 8));
      match = 1;
    }

    if (strncmp(argv[i],"-eps",4) == 0)
    {
      epsilon = (float ) (atof(argv[i] + 4));
      match = 1;
    }

    if (match)
    {
      for (j = i + 1; j < argc; ++j)
        argv[j - 1] = argv[j];
      argc--;
      i--;
    }

  }

  epsilon *= epsilon;
  numTriangles = loadModelData((argc > 1) ? (argv[1]) : ("dragon.ply"),&triangledata,&neighbordata);
  {
    for (rr=0;rr<6;++rr) {
       ::brook::stream neighbors(::brook::getStreamType(( Neighbor  *)0), bestHeight(numTriangles) , bestWidth(numTriangles),-1);
       ::brook::stream triangles(::brook::getStreamType(( STri  *)0), bestHeight(numTriangles) , bestWidth(numTriangles),-1);

       streamRead(triangles,triangledata);
       streamRead(neighbors,neighbordata);
       struct VertexArray  v;
       initVertexArray(&v);
       if (rr==0) {
          TallyKernel("smallEnough",triangles);
       }
       start = GetTimeMillis();
       smallEnough(triangles,neighbors,triangles,neighbors,epsilon);
       subdivide(&neighbors,&triangles,&v,epsilon,0);
       stop = GetTimeMillis();
       if (debugLoop) {
          fprintf (stderr,"Time %f\n",(float)(stop-start));
       }else {
          printf ("Time %f\n",(float)(stop-start));
       }
       if (debugLoop&&rr==2) {
          printf("%d\n",v.size);
          for (i = 0; i < v.size; i++)
             {
                printf("%3.3f, %3.3f, %3.3f\n",v.v[i].x,v.v[i].y,v.v[i].z);
             }
       
       }
       vcount = numTriangles;
       for (i = 0; i < (unsigned int ) (subdivisiondepth); ++i)
          {
             vcount *= 4;
          }
       if (debugLoop) {
          fprintf(stderr,"Num Rounds %d Adaptive Num Triangles %d Num Triangles %d\n",subdivisiondepth,v.size / 3,vcount);
       }else {
          printf("Num Rounds %d Adaptive Num Triangles %d Num Triangles %d\n",subdivisiondepth,v.size / 3,vcount);
       }
    }
    return 0;
  }

}


