
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Mar 29 2004 17:20:37
////////////////////////////////////////////

#include <brook.hpp>

::brook::stream & quickAllocStream (const __BRTStreamType *t, int wid, int len, int gar);

__BrtFloat1 __test_cpu_inner (const __BrtFloat1  &vol,
                        const __BrtFloat1  &index){
  return (vol > __BrtFloat1(0.500000f)).questioncolon(index,__BrtFloat1((float)0));
}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSlice_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
"    ps_2_0\n"

				"    def c5, 1, 2, 4, 8\n"

				"    def c6, 0.5, 0, 1, -254.5\n"

				"    def c7, 16, 32, 64, 128\n"

				"    def c8, -1, 0, 0, 0\n"

				"    dcl t0.xy\n"

				"    dcl t1.xy\n"

				"    dcl t2.xy\n"

				"    dcl t3.xy\n"

				"    dcl_2d s0\n"

				"    dcl_2d s1\n"

				"    dcl_2d s2\n"

				"    mad r5.x, t0.x, c0.x, c0.z\n"

				"    mad r5.y, t0.y, c0.y, c0.w\n"

				"    mad r8.x, t1.x, c0.x, c0.z\n"

				"    mad r8.y, t1.y, c0.y, c0.w\n"

				"    mad r7.x, t3.x, c0.x, c0.z\n"

				"    mad r7.y, t3.y, c0.y, c0.w\n"

				"    mad r6.x, t2.x, c0.x, c0.z\n"

				"    mad r6.y, t2.y, c0.y, c0.w\n"

				"    mad r1.x, t0.x, c1.x, c1.z\n"

				"    mad r1.y, t0.y, c1.y, c1.w\n"

				"    mad r4.x, t1.x, c1.x, c1.z\n"

				"    mad r4.y, t1.y, c1.y, c1.w\n"

				"    mad r3.x, t3.x, c1.x, c1.z\n"

				"    mad r3.y, t3.y, c1.y, c1.w\n"

				"    mad r2.x, t2.x, c1.x, c1.z\n"

				"    mad r2.y, t2.y, c1.y, c1.w\n"

				"    mov r0.xy, c4.z\n"

				"    texld r5, r5, s0\n"

				"    texld r8, r8, s0\n"

				"    texld r7, r7, s0\n"

				"    texld r6, r6, s0\n"

				"    texld r1, r1, s1\n"

				"    texld r4, r4, s1\n"

				"    texld r3, r3, s1\n"

				"    texld r2, r2, s1\n"

				"    texld r0, r0, s2\n"

				"    mov r5.x, -r5.x\n"

				"    mov r5.y, -r8.x\n"

				"    mov r5.z, -r7.x\n"

				"    mov r5.w, -r6.x\n"

				"    add r5, r5, c6.x\n"

				"    mov r0.z, c6.y\n"

				"    cmp r5, r5, r0.z, c5\n"

				"    dp4 r0.w, r5, c6.z\n"

				"    mov r1.x, -r1.x\n"

				"    mov r1.y, -r4.x\n"

				"    mov r1.z, -r3.x\n"

				"    mov r1.w, -r2.x\n"

				"    add r1, r1, c6.x\n"

				"    cmp r1, r1, r0.z, c7\n"

				"    dp4 r1.w, r1, c6.z\n"

				"    add r1.w, r0.w, r1.w\n"

				"    add r0.w, -r1.w, c6.x\n"

				"    cmp_pp r0.w, r0.w, c6.y, c6.z\n"

				"    add r2.w, r1.w, c6.w\n"

				"    cmp_pp r2.w, r2.w, c6.y, c6.z\n"

				"    mul_pp r0.w, r0.w, r2.w\n"

				"    mov r2.w, c8.x\n"

				"    add r2.w, r2.w, c3.x\n"

				"    add r2.w, -r2.w, c8.x\n"

				"    mov r1.xy, t0\n"

				"    mul r2.w, r2.w, r2.w\n"

				"    mov r1.z, c2.x\n"

				"    cmp r1, -r2.w, r1, r0.x\n"

				"    cmp r0, -r0.w, r0.x, r1\n"

				"    mov oC0, r0\n"

				"\n"

				" \n"

				"//!!BRCC\n"

				"//narg:10\n"

				"//c:1:curgather\n"

				"//c:1:nextslice\n"

				"//o:4:__vertex_stream\n"

				"//s:2:center\n"

				"//s:2:up\n"

				"//s:2:forward\n"

				"//s:2:upforward\n"

				"//c:2:slice\n"

				"//c:1:__vout_counter\n"

				"//c:1:__inf\n"

				"//workspace:1024\n"

				"//!!multipleOutputInfo:0:1:\n"

				"//!!fullAddressTrans:0:\n"

				"//!!reductionFactor:0:\n"

				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.constant(9, 0)
				.constant(10, kGatherConstant_Shape)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(10, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSlice_ps20 = &__processSlice_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSlice_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.curgather : TEXUNIT0\n"
				"#semantic main.__gatherconst_curgather : C0\n"
				"#semantic main.nextslice : TEXUNIT1\n"
				"#semantic main.__gatherconst_nextslice : C1\n"
				"#semantic main.slice : C2\n"
				"#semantic main.__vout_counter : C3\n"
				"#semantic main.__inf : TEXUNIT2\n"
				"#semantic main.__gatherconst___inf : C4\n"
				"#semantic main.__workspace : C5\n"
				"#var samplerRECT curgather[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_curgather : C0 :  : 1 : 1\n"
				"#var samplerRECT nextslice[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_nextslice : C1 :  : 3 : 1\n"
				"#var float2 slice : C2 :  : 9 : 1\n"
				"#var float __vout_counter : C3 :  : 10 : 1\n"
				"#var samplerRECT __inf[0] : TEXUNIT2 : texunit 2 : 11 : 1\n"
				"#var float4 __gatherconst___inf : C4 :  : 12 : 1\n"
				"#var float4 __workspace : C5 :  : 13 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 center : $vin.TEXCOORD0 : TEX0 : 5 : 1\n"
				"#var float2 up : $vin.TEXCOORD1 : TEX1 : 6 : 1\n"
				"#var float2 forward : $vin.TEXCOORD2 : TEX2 : 7 : 1\n"
				"#var float2 upforward : $vin.TEXCOORD3 : TEX3 : 8 : 1\n"
				"DECLARE __gatherconst_curgather;\n"
				"DECLARE __gatherconst_nextslice;\n"
				"DECLARE slice;\n"
				"DECLARE __vout_counter;\n"
				"DECLARE __gatherconst___inf;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R0.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), {2}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {4}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {8}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX0].xyxx, TEX1, RECT;\n"
				"TEX R2.x, f[TEX1].xyxx, TEX1, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {16}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {32}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX3].xyxx, TEX1, RECT;\n"
				"TEX R2.x, f[TEX2].xyxx, TEX1, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {64}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {128}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"SLTR H0.x, R0.y, {254.5}.x;\n"
				"SGTR H0.y, R0.y, {0.5}.x;\n"
				"MULX H0.x, H0.y, H0.x;\n"
				"MOVR R0.w, R0.y;\n"
				"MOVR R0.z, slice.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVR R1.x, {1}.x;\n"
				"ADDR R1.x, __vout_counter.x, -R1.x;\n"
				"SEQR H0.y, {-1}.x, R1.x;\n"
				"TEX R1.x, {0, 0}.xyxx, TEX2, RECT;\n"
				"MOVR R2, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2(GT.x), R0;\n"
				"MOVR o[COLR], R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR o[COLR](GT.x), R2;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:1:curgather\n"
				"##c:1:nextslice\n"
				"##o:4:__vertex_stream\n"
				"##s:2:center\n"
				"##s:2:up\n"
				"##s:2:forward\n"
				"##s:2:upforward\n"
				"##c:2:slice\n"
				"##c:1:__vout_counter\n"
				"##c:1:__inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.constant(9, 0)
				.constant(10, kGatherConstant_Shape)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(10, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSlice_fp30 = &__processSlice_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSlice_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = program.local[4];\n"
				"PARAM c5 = {0.5, 1, 2, 0};\n"
				"PARAM c6 = {4, 16, 32, 8};\n"
				"PARAM c7 = {64, -254.5, -1, 128};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, t1.x, c0.x, c0.z;\n"
				"MAD r9.y, t1.y, c0.y, c0.w;\n"
				"MAD r11.x, t3.x, c0.x, c0.z;\n"
				"MAD r11.y, t3.y, c0.y, c0.w;\n"
				"MAD r1.x, t2.x, c0.x, c0.z;\n"
				"MAD r1.y, t2.y, c0.y, c0.w;\n"
				"MAD r3.x, t0.x, c1.x, c1.z;\n"
				"MAD r3.y, t0.y, c1.y, c1.w;\n"
				"MAD r5.x, t1.x, c1.x, c1.z;\n"
				"MAD r5.y, t1.y, c1.y, c1.w;\n"
				"MAD r2.x, t3.x, c1.x, c1.z;\n"
				"MAD r2.y, t3.y, c1.y, c1.w;\n"
				"MAD r6.x, t2.x, c1.x, c1.z;\n"
				"MAD r6.y, t2.y, c1.y, c1.w;\n"
				"MOV r8.xy, c4.z;\n"
				"TEX r7, r7, texture[0], RECT;\n"
				"TEX r9, r9, texture[0], RECT;\n"
				"TEX r11, r11, texture[0], RECT;\n"
				"TEX r1, r1, texture[0], RECT;\n"
				"TEX r3, r3, texture[1], RECT;\n"
				"TEX r10, r5, texture[1], RECT;\n"
				"TEX r5, r2, texture[1], RECT;\n"
				"TEX r0, r6, texture[1], RECT;\n"
				"TEX r2, r8, texture[2], RECT;\n"
				"ADD r9.w, -r7.x, c5.x;\n"
				"CMP r11.w, r9.w, c5.y, c5.w;\n"
				"ADD r1.w, -r9.x, c5.x;\n"
				"CMP r1.w, r1.w, c5.z, c5.w;\n"
				"ADD r1.w, r11.w, r1.w;\n"
				"ADD r3.w, -r11.x, c5.x;\n"
				"MOV r11.w, c6.x;\n"
				"CMP r3.w, r3.w, r11.w, c5.w;\n"
				"ADD r3.w, r1.w, r3.w;\n"
				"ADD r10.w, -r1.x, c5.x;\n"
				"MOV r11.w, c6.w;\n"
				"CMP r10.w, r10.w, r11.w, c5.w;\n"
				"ADD r10.w, r3.w, r10.w;\n"
				"ADD r5.w, -r3.x, c5.x;\n"
				"MOV r11.w, c6.y;\n"
				"CMP r5.w, r5.w, r11.w, c5.w;\n"
				"ADD r5.w, r10.w, r5.w;\n"
				"ADD r0.w, -r10.x, c5.x;\n"
				"MOV r11.w, c6.z;\n"
				"CMP r0.w, r0.w, r11.w, c5.w;\n"
				"ADD r0.w, r5.w, r0.w;\n"
				"ADD r2.w, -r5.x, c5.x;\n"
				"MOV r11.w, c7.x;\n"
				"CMP r2.w, r2.w, r11.w, c5.w;\n"
				"ADD r0.w, r0.w, r2.w;\n"
				"ADD r2.w, -r0.x, c5.x;\n"
				"MOV r11.w, c7.w;\n"
				"CMP r2.w, r2.w, r11.w, c5.w;\n"
				"ADD r4.w, r0.w, r2.w;\n"
				"ADD r2.w, -r4.w, c5.x;\n"
				"CMP r2.w, r2.w, c5.y, c5.w;\n"
				"ADD r6.w, r4.w, c7.y;\n"
				"CMP r8.w, r6.w, c5.y, c5.w;\n"
				"MUL r2.w, r2.w, r8.w;\n"
				"MOV r11.w, c3.x;\n"
				"ADD r7.w, c7.z, r11.w;\n"
				"ADD r11.w, -r7.w, c7.z;\n"
				"ABS r3.w, r11.w;\n"
				"MOV r4.xy, t0;\n"
				"MOV r4.z, c2.x;\n"
				"CMP r5, -r3.w, r2.x, r4;\n"
				"CMP r0, -r2.w, r5, r2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:10\n"
				"##c:1:curgather\n"
				"##c:1:nextslice\n"
				"##o:4:__vertex_stream\n"
				"##s:2:center\n"
				"##s:2:up\n"
				"##s:2:forward\n"
				"##s:2:upforward\n"
				"##c:2:slice\n"
				"##c:1:__vout_counter\n"
				"##c:1:__inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.constant(9, 0)
				.constant(10, kGatherConstant_Shape)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(10, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSlice_arb = &__processSlice_arb_desc;
}

void __processSlice_cpu_inner (const __BrtArray2d<__BrtFloat1  > &curgather,
                                const __BrtArray2d<__BrtFloat1  > &nextslice,
                                __BrtFloat4  &__vertex_stream,
                                const __BrtFloat2  &center,
                                const __BrtFloat2  &up,
                                const __BrtFloat2  &forward,
                                const __BrtFloat2  &upforward,
                                const __BrtFloat2  &slice,
                                __BrtFloat1  __vout_counter,
                                const __BrtArray1d<__BrtFloat1  > &__inf){
  __vertex_stream = __inf[__BrtFloat1(0.000000f)];
  {
    __BrtFloat4  vertex;
    __BrtFloat1  a = __test_cpu_inner(curgather[center],__BrtFloat1(1.000000f)) + __test_cpu_inner(curgather[up],__BrtFloat1(2.000000f)) + __test_cpu_inner(curgather[upforward],__BrtFloat1(4.000000f)) + __test_cpu_inner(curgather[forward],__BrtFloat1(8.000000f)) + __test_cpu_inner(nextslice[center],__BrtFloat1(16.000000f)) + __test_cpu_inner(nextslice[up],__BrtFloat1(32.000000f)) + __test_cpu_inner(nextslice[upforward],__BrtFloat1(64.000000f)) + __test_cpu_inner(nextslice[forward],__BrtFloat1(128.000000f));

    if (a > __BrtFloat1(0.500000f) && a < __BrtFloat1(2.000000f) + __BrtFloat1(4.000000f) + __BrtFloat1(8.000000f) + __BrtFloat1(16.000000f) + __BrtFloat1(32.000000f) + __BrtFloat1(64.000000f) + __BrtFloat1(128.000000f) + __BrtFloat1(0.500000f))
    {
      vertex = __BrtFloat4 (center.swizzle1(maskX),center.swizzle1(maskY),slice.swizzle1(maskX),a);
      __vertex_stream = (__BrtFloat1(-1.000000f) == (__vout_counter -= __BrtFloat1((float)1))).questioncolon(vertex,__vertex_stream);
    }

  }

}
void  __processSlice_cpu (const std::vector<void *>&args,
                          const std::vector<const unsigned int *>&extents,
                          const std::vector<unsigned int>&dims,
                          unsigned int mapbegin, 
                          unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat2 *arg6 = (__BrtFloat2 *)args[6];
  __BrtFloat2 *arg7 = (__BrtFloat2 *)args[7];
  __BrtFloat1 *arg8 = (__BrtFloat1 *)args[8];
  __BrtArray1d<__BrtFloat1  > arg9(
      (__BrtFloat1  *)args[9], extents[9]);
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  arg3+=mapbegin;
  arg4+=mapbegin;
  arg5+=mapbegin;
  arg6+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __processSlice_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7,
      *arg8,
      arg9);
    i++;
    ++arg2;
    ++arg3;
    ++arg4;
    ++arg5;
    ++arg6;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

extern int finiteValueProduced1dfloat (brook::stream input);
extern float shiftValues1dfloat(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat (brook::stream input);
extern float shiftValuesfloat(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat2 (brook::stream input);
extern float shiftValues1dfloat2(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat2(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat2 (brook::stream input);
extern float shiftValuesfloat2(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat2(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat3 (brook::stream input);
extern float shiftValues1dfloat3(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat3(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat3 (brook::stream input);
extern float shiftValuesfloat3(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat3(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat4 (brook::stream input);
extern float shiftValues1dfloat4(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat4(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat4 (brook::stream input);
extern float shiftValuesfloat4(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat4(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
void  processSlice (::brook::stream curgather,
		::brook::stream nextslice,
		::brook::stream &__vertex_stream,
		const __BRTIter& center,
		const __BRTIter& up,
		const __BRTIter& forward,
		const __BRTIter& upforward,
		const float2  slice) {
  static const void *__processSlice_fp[] = {
     "fp30", __processSlice_fp30,
     "arb", __processSlice_arb,
     "ps20", __processSlice_ps20,
     "cpu", (void *) __processSlice_cpu,
     NULL, NULL };
  static __BRTKernel k(__processSlice_fp);

  float __vout_counter=0.0f;
  brook::Stream * __inf = *sentinelStream(1);
  int maxextents[2]={0,0};
  unsigned int __dimension = center->getDimension();
  assert (center->getDimension()<=2);
  maxDimension(maxextents,center->getExtents(),center->getDimension());
  assert (up->getDimension()<=2);
  maxDimension(maxextents,up->getExtents(),up->getDimension());
  assert (forward->getDimension()<=2);
  maxDimension(maxextents,forward->getExtents(),forward->getDimension());
  assert (upforward->getDimension()<=2);
  maxDimension(maxextents,upforward->getExtents(),upforward->getDimension());
  std:: vector <__BRTStreamType> __vertex_types;
  for (int __vertex_iter = 0; __vertex_iter < __vertex_stream->getFieldCount(); ++__vertex_iter) 
    __vertex_types.push_back(__vertex_stream->getIndexedFieldType(__vertex_iter));
  __vertex_types.push_back(__BRTNONE);
  std::vector<brook::stream*> __vertex_outputs;
  bool __vertex_values = true;
  while (__vertex_values) {
    if (__vertex_values) {
       static brook::stream bleh (&__vertex_types[0],maxextents[0],maxextents[1],-1);
       __vertex_outputs.push_back (new brook::stream(bleh));
    }
    k->PushGatherStream(curgather);
    k->PushGatherStream(nextslice);
    k->PushOutput(*__vertex_outputs.back());
    k->PushIter(center);
    k->PushIter(up);
    k->PushIter(forward);
    k->PushIter(upforward);
    k->PushConstant(slice);
    k->PushConstant(__vout_counter);
    k->PushGatherStream(__inf);
    k->Map();
    __vout_counter+=1.0f;
     if ((__vout_counter >= 1)) {
      __vertex_outputs.push_back(0);
      break;
    }
  }
  if (__vertex_stream->getDimension()==2) {
    static ::brook::stream __vertex_temp(&__vertex_types[0],1, 1, -1);
    combineStreamsfloat4 (&__vertex_outputs[0],
                   __vertex_outputs.size()-1,
                   maxextents[0],
                   maxextents[1],
                   &__vertex_temp);
    shiftValuesfloat4(__vertex_temp,
                &__vertex_stream,
                __vertex_temp->getExtents()[0],
                __vertex_temp->getExtents()[1],
                -1);
  }else {
    ::brook::stream __vertex_temp(&__vertex_types[0],1, -1);
    combineStreams1dfloat4 (&__vertex_outputs[0],
                   __vertex_outputs.size()-1,
                   maxextents[0],
                   maxextents[1],
                   &__vertex_temp);
    shiftValues1dfloat4(__vertex_temp,
                &__vertex_stream,
                __vertex_temp->getExtents()[0],
                 1,                -1);
  }
  while (__vertex_outputs.size()) {
    if (__vertex_outputs.back())
       delete __vertex_outputs.back();
    __vertex_outputs.pop_back();
  }

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSliceNoCompact_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c3, 0.5, 1, 2, 0\n"
				"    def c4, 4, 16, 32, 8\n"
				"    def c5, 64, -254.5, -1, 128\n"
				"    dcl t0\n"
				"    dcl t1\n"
				"    dcl t2\n"
				"    dcl t3\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7, t0, c0, c0\n"
				"    mad r7, t0, c0, c0\n"
				"    mad r9, t1, c0, c0\n"
				"    mad r9, t1, c0, c0\n"
				"    mad r11, t3, c0, c0\n"
				"    mad r11, t3, c0, c0\n"
				"    mad r1, t2, c0, c0\n"
				"    mad r1, t2, c0, c0\n"
				"    mad r3, t0, c1, c1\n"
				"    mad r3, t0, c1, c1\n"
				"    mad r5, t1, c1, c1\n"
				"    mad r5, t1, c1, c1\n"
				"    mad r2, t3, c1, c1\n"
				"    mad r2, t3, c1, c1\n"
				"    mad r6, t2, c1, c1\n"
				"    mad r6, t2, c1, c1\n"
				"    texld r7, r7, s0\n"
				"    texld r9, r9, s0\n"
				"    texld r11, r11, s0\n"
				"    texld r1, r1, s0\n"
				"    texld r8, r3, s1\n"
				"    texld r3, r5, s1\n"
				"    texld r10, r2, s1\n"
				"    texld r5, r6, s1\n"
				"    mad r9, -r7, c3, r1\n"
				"    mad r11, r9, c3, c3\n"
				"    mad r1, -r9, c3, r2\n"
				"    mad r1, r1, c3, c3\n"
				"    mad r1, r11, r1,r3\n"
				"    mad r8, -r11, c3,r11\n"
				"    mad r11, c4, r5, r6\n"
				"    mad r8, r8, c3, r11\n"
				"    mad r8, r1, r8, r8\n"
				"    mad r3, -r1, c3,r9\n"
				"    mad r11, c4,r10,r11\n"
				"    mad r3, r3, c3, r11\n"
				"    mad r3, r8, r3, r10\n"
				"    mad r10, -r8, c3,r9\n"
				"    mad r11, c4, r8,r7\n"
				"    mad r10, r10, c3, r11\n"
				"    mad r10, r3, r10,r6\n"
				"    mad r5, -r3, c3,r5\n"
				"    mad r11, c4,r10,r3\n"
				"    mad r5, r5, c3, r11\n"
				"    mad r5, r10, r5,r2\n"
				"    mad r2, -r10, c3,r1\n"
				"    mad r11, c5,r2,r1\n"
				"    mad r4, r2, c3, r11\n"
				"    mad r5, r5, r4,r2\n"
				"    mad r7, -r5, c3,r3\n"
				"    mad r11, c5,r4,r5\n"
				"    mad r9, r7, c3, r11\n"
				"    mad r11, r5, r9,r6\n"
				"    mad r8, -r11, c3,r7\n"
				"    mad r3, r8, c3, c3\n"
				"    mad r10, r11, c5,r8\n"
				"    mad r0, r10, c3, c3\n"
				"    mad r2, r3, r0,r10\n"
				"    mad r11, t0,r11,r10\n"
				"    mad r11, c2,r9,r8\n"
				"    mad r5, -r2, c5, r11\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:1:curgather\n"
				"//c:1:nextslice\n"
				"//o:4:vertex\n"
				"//s:2:center\n"
				"//s:2:up\n"
				"//s:2:forward\n"
				"//s:2:upforward\n"
				"//c:2:slice\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				""
                                             /*
				"    ps_2_0\n"
				"    def c3, 0.5, 1, 2, 0\n"
				"    def c4, 4, 16, 32, 8\n"
				"    def c5, 64, -254.5, -1, 128\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl t2.xy\n"
				"    dcl t3.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    mad r7.x, t0.x, c0.x, c0.z\n"
				"    mad r7.y, t0.y, c0.y, c0.w\n"
				"    mad r9.x, t1.x, c0.x, c0.z\n"
				"    mad r9.y, t1.y, c0.y, c0.w\n"
				"    mad r11.x, t3.x, c0.x, c0.z\n"
				"    mad r11.y, t3.y, c0.y, c0.w\n"
				"    mad r1.x, t2.x, c0.x, c0.z\n"
				"    mad r1.y, t2.y, c0.y, c0.w\n"
				"    mad r3.x, t0.x, c1.x, c1.z\n"
				"    mad r3.y, t0.y, c1.y, c1.w\n"
				"    mad r5.x, t1.x, c1.x, c1.z\n"
				"    mad r5.y, t1.y, c1.y, c1.w\n"
				"    mad r2.x, t3.x, c1.x, c1.z\n"
				"    mad r2.y, t3.y, c1.y, c1.w\n"
				"    mad r6.x, t2.x, c1.x, c1.z\n"
				"    mad r6.y, t2.y, c1.y, c1.w\n"
				"    texld r7, r7, s0\n"
				"    texld r9, r9, s0\n"
				"    texld r11, r11, s0\n"
				"    texld r1, r1, s0\n"
				"    texld r8, r3, s1\n"
				"    texld r3, r5, s1\n"
				"    texld r10, r2, s1\n"
				"    texld r5, r6, s1\n"
				"    add r9.w, -r7.x, c3.x\n"
				"    cmp_pp r11.w, r9.w, c3.w, c3.y\n"
				"    add r1.w, -r9.x, c3.x\n"
				"    cmp r1.w, r1.w, c3.w, c3.z\n"
				"    add r1.w, r11.w, r1.w\n"
				"    add r8.w, -r11.x, c3.x\n"
				"    mov r11.w, c4.x\n"
				"    cmp r8.w, r8.w, c3.w, r11.w\n"
				"    add r8.w, r1.w, r8.w\n"
				"    add r3.w, -r1.x, c3.x\n"
				"    mov r11.w, c4.w\n"
				"    cmp r3.w, r3.w, c3.w, r11.w\n"
				"    add r3.w, r8.w, r3.w\n"
				"    add r10.w, -r8.x, c3.x\n"
				"    mov r11.w, c4.y\n"
				"    cmp r10.w, r10.w, c3.w, r11.w\n"
				"    add r10.w, r3.w, r10.w\n"
				"    add r5.w, -r3.x, c3.x\n"
				"    mov r11.w, c4.z\n"
				"    cmp r5.w, r5.w, c3.w, r11.w\n"
				"    add r5.w, r10.w, r5.w\n"
				"    add r2.w, -r10.x, c3.x\n"
				"    mov r11.w, c5.x\n"
				"    cmp r4.w, r2.w, c3.w, r11.w\n"
				"    add r5.w, r5.w, r4.w\n"
				"    add r7.w, -r5.x, c3.x\n"
				"    mov r11.w, c5.w\n"
				"    cmp r9.w, r7.w, c3.w, r11.w\n"
				"    add r11.w, r5.w, r9.w\n"
				"    add r8.w, -r11.w, c3.x\n"
				"    cmp_pp r3.w, r8.w, c3.w, c3.y\n"
				"    add r10.w, r11.w, c5.y\n"
				"    cmp_pp r0.w, r10.w, c3.w, c3.y\n"
				"    mul_pp r2.w, r3.w, r0.w\n"
				"    mov r11.xy, t0\n"
				"    mov r11.z, c2.x\n"
				"    cmp r5, -r2.w, c5.z, r11\n"
				"    mov oC0, r5\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:8\n"
				"//c:1:curgather\n"
				"//c:1:nextslice\n"
				"//o:4:vertex\n"
				"//s:2:center\n"
				"//s:2:up\n"
				"//s:2:forward\n"
				"//s:2:upforward\n"
				"//c:2:slice\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				""*/
                                )
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSliceNoCompact_ps20 = &__processSliceNoCompact_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSliceNoCompact_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main.curgather : TEXUNIT0\n"
				"#semantic main.__gatherconst_curgather : C0\n"
				"#semantic main.nextslice : TEXUNIT1\n"
				"#semantic main.__gatherconst_nextslice : C1\n"
				"#semantic main.slice : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var samplerRECT curgather[0] : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float4 __gatherconst_curgather : C0 :  : 1 : 1\n"
				"#var samplerRECT nextslice[0] : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_nextslice : C1 :  : 3 : 1\n"
				"#var float2 slice : C2 :  : 9 : 1\n"
				"#var float4 __workspace : C3 :  : 10 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 4 : 1\n"
				"#var float2 center : $vin.TEXCOORD0 : TEX0 : 5 : 1\n"
				"#var float2 up : $vin.TEXCOORD1 : TEX1 : 6 : 1\n"
				"#var float2 forward : $vin.TEXCOORD2 : TEX2 : 7 : 1\n"
				"#var float2 upforward : $vin.TEXCOORD3 : TEX3 : 8 : 1\n"
				"DECLARE __gatherconst_curgather;\n"
				"DECLARE __gatherconst_nextslice;\n"
				"DECLARE slice;\n"
				"DECLARE __workspace;\n"
				"TEX R0.x, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, f[TEX1].xyxx, TEX0, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R0.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.x(GT.x), {1}.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.y(GT.x), {2}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX3].xyxx, TEX0, RECT;\n"
				"TEX R2.x, f[TEX2].xyxx, TEX0, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {4}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {8}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX0].xyxx, TEX1, RECT;\n"
				"TEX R2.x, f[TEX1].xyxx, TEX1, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {16}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {32}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"TEX R1.x, f[TEX3].xyxx, TEX1, RECT;\n"
				"TEX R2.x, f[TEX2].xyxx, TEX1, RECT;\n"
				"SGTR H0.x, R1.x, {0.5}.x;\n"
				"SGTR H0.y, R2.x, {0.5}.x;\n"
				"MOVR R0.x, {0}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0.x(GT.x), {64}.x;\n"
				"ADDR R0.x, R0.y, R0.x;\n"
				"MOVR R0.y, {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R0.y(GT.x), {128}.x;\n"
				"ADDR R0.y, R0.x, R0.y;\n"
				"SLTR H0.x, R0.y, {254.5}.x;\n"
				"SGTR H0.y, R0.y, {0.5}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVR R0.w, R0.y;\n"
				"MOVR R0.z, slice.x;\n"
				"MOVR R0.xy, f[TEX0].xyxx;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R0(GT.x), {-1, -1, -1, -1};\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:curgather\n"
				"##c:1:nextslice\n"
				"##o:4:vertex\n"
				"##s:2:center\n"
				"##s:2:up\n"
				"##s:2:forward\n"
				"##s:2:upforward\n"
				"##c:2:slice\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSliceNoCompact_fp30 = &__processSliceNoCompact_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processSliceNoCompact_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = {0.5, 1, 2, 0};\n"
				"PARAM c4 = {4, 16, 32, 8};\n"
				"PARAM c5 = {64, -254.5, -1, 128};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"ATTRIB t2 = fragment.texcoord[2];\n"
				"ATTRIB t3 = fragment.texcoord[3];\n"
				"MAD r7.x, t0.x, c0.x, c0.z;\n"
				"MAD r7.y, t0.y, c0.y, c0.w;\n"
				"MAD r9.x, t1.x, c0.x, c0.z;\n"
				"MAD r9.y, t1.y, c0.y, c0.w;\n"
				"MAD r11.x, t3.x, c0.x, c0.z;\n"
				"MAD r11.y, t3.y, c0.y, c0.w;\n"
				"MAD r1.x, t2.x, c0.x, c0.z;\n"
				"MAD r1.y, t2.y, c0.y, c0.w;\n"
				"MAD r3.x, t0.x, c1.x, c1.z;\n"
				"MAD r3.y, t0.y, c1.y, c1.w;\n"
				"MAD r5.x, t1.x, c1.x, c1.z;\n"
				"MAD r5.y, t1.y, c1.y, c1.w;\n"
				"MAD r2.x, t3.x, c1.x, c1.z;\n"
				"MAD r2.y, t3.y, c1.y, c1.w;\n"
				"MAD r6.x, t2.x, c1.x, c1.z;\n"
				"MAD r6.y, t2.y, c1.y, c1.w;\n"
				"TEX r7, r7, texture[0], RECT;\n"
				"TEX r9, r9, texture[0], RECT;\n"
				"TEX r11, r11, texture[0], RECT;\n"
				"TEX r1, r1, texture[0], RECT;\n"
				"TEX r8, r3, texture[1], RECT;\n"
				"TEX r3, r5, texture[1], RECT;\n"
				"TEX r10, r2, texture[1], RECT;\n"
				"TEX r5, r6, texture[1], RECT;\n"
				"ADD r9.w, -r7.x, c3.x;\n"
				"CMP r11.w, r9.w, c3.y, c3.w;\n"
				"ADD r1.w, -r9.x, c3.x;\n"
				"CMP r1.w, r1.w, c3.z, c3.w;\n"
				"ADD r1.w, r11.w, r1.w;\n"
				"ADD r8.w, -r11.x, c3.x;\n"
				"MOV r11.w, c4.x;\n"
				"CMP r8.w, r8.w, r11.w, c3.w;\n"
				"ADD r8.w, r1.w, r8.w;\n"
				"ADD r3.w, -r1.x, c3.x;\n"
				"MOV r11.w, c4.w;\n"
				"CMP r3.w, r3.w, r11.w, c3.w;\n"
				"ADD r3.w, r8.w, r3.w;\n"
				"ADD r10.w, -r8.x, c3.x;\n"
				"MOV r11.w, c4.y;\n"
				"CMP r10.w, r10.w, r11.w, c3.w;\n"
				"ADD r10.w, r3.w, r10.w;\n"
				"ADD r5.w, -r3.x, c3.x;\n"
				"MOV r11.w, c4.z;\n"
				"CMP r5.w, r5.w, r11.w, c3.w;\n"
				"ADD r5.w, r10.w, r5.w;\n"
				"ADD r2.w, -r10.x, c3.x;\n"
				"MOV r11.w, c5.x;\n"
				"CMP r4.w, r2.w, r11.w, c3.w;\n"
				"ADD r5.w, r5.w, r4.w;\n"
				"ADD r7.w, -r5.x, c3.x;\n"
				"MOV r11.w, c5.w;\n"
				"CMP r9.w, r7.w, r11.w, c3.w;\n"
				"ADD r11.w, r5.w, r9.w;\n"
				"ADD r8.w, -r11.w, c3.x;\n"
				"CMP r3.w, r8.w, c3.y, c3.w;\n"
				"ADD r10.w, r11.w, c5.y;\n"
				"CMP r0.w, r10.w, c3.y, c3.w;\n"
				"MUL r2.w, r3.w, r0.w;\n"
				"MOV r11.xy, t0;\n"
				"MOV r11.z, c2.x;\n"
				"CMP r5, -r2.w, r11, c5.z;\n"
				"MOV oC0, r5;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:8\n"
				"##c:1:curgather\n"
				"##c:1:nextslice\n"
				"##o:4:vertex\n"
				"##s:2:center\n"
				"##s:2:up\n"
				"##s:2:forward\n"
				"##s:2:upforward\n"
				"##c:2:slice\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kGatherConstant_Shape)
				.constant(2, kGatherConstant_Shape)
				.constant(8, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.interpolant(4, kIteratorInterpolant_Value)
				.interpolant(5, kIteratorInterpolant_Value)
				.interpolant(6, kIteratorInterpolant_Value)
				.interpolant(7, kIteratorInterpolant_Value)
				.output(3, 0)
			)
		);
	static const void* __processSliceNoCompact_arb = &__processSliceNoCompact_arb_desc;
}

void __processSliceNoCompact_cpu_inner (const __BrtArray2d<__BrtFloat1  > &curgather,
                                         const __BrtArray2d<__BrtFloat1  > &nextslice,
                                         __BrtFloat4  &vertex,
                                         const __BrtFloat2  &center,
                                         const __BrtFloat2  &up,
                                         const __BrtFloat2  &forward,
                                         const __BrtFloat2  &upforward,
                                         const __BrtFloat2  &slice){
  __BrtFloat1  a = __test_cpu_inner(curgather[center],__BrtFloat1(1.000000f)) + __test_cpu_inner(curgather[up],__BrtFloat1(2.000000f)) + __test_cpu_inner(curgather[upforward],__BrtFloat1(4.000000f)) + __test_cpu_inner(curgather[forward],__BrtFloat1(8.000000f)) + __test_cpu_inner(nextslice[center],__BrtFloat1(16.000000f)) + __test_cpu_inner(nextslice[up],__BrtFloat1(32.000000f)) + __test_cpu_inner(nextslice[upforward],__BrtFloat1(64.000000f)) + __test_cpu_inner(nextslice[forward],__BrtFloat1(128.000000f));

  if (a > __BrtFloat1(0.500000f) && a < __BrtFloat1(2.000000f) + __BrtFloat1(4.000000f) + __BrtFloat1(8.000000f) + __BrtFloat1(16.000000f) + __BrtFloat1(32.000000f) + __BrtFloat1(64.000000f) + __BrtFloat1(128.000000f) + __BrtFloat1(0.500000f))
  {
    vertex = __BrtFloat4 (center.swizzle1(maskX),center.swizzle1(maskY),slice.swizzle1(maskX),a);
  }

  else
  {
    vertex = __BrtFloat4 (-__BrtFloat1((float)1),-__BrtFloat1((float)1),-__BrtFloat1((float)1),-__BrtFloat1((float)1));
  }

}
void  __processSliceNoCompact_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtArray2d<__BrtFloat1  > arg0(
      (__BrtFloat1  *)args[0], extents[0]);
  __BrtArray2d<__BrtFloat1  > arg1(
      (__BrtFloat1  *)args[1], extents[1]);
  __BrtFloat4 *arg2 = (__BrtFloat4 *)args[2];
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat2 *arg4 = (__BrtFloat2 *)args[4];
  __BrtFloat2 *arg5 = (__BrtFloat2 *)args[5];
  __BrtFloat2 *arg6 = (__BrtFloat2 *)args[6];
  __BrtFloat2 *arg7 = (__BrtFloat2 *)args[7];
  unsigned int dim=dims[2];
  unsigned int newline=extents[2][dim-1];
  arg2+=mapbegin;
  arg3+=mapbegin;
  arg4+=mapbegin;
  arg5+=mapbegin;
  arg6+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __processSliceNoCompact_cpu_inner (
      arg0,
      arg1,
      *arg2,
      *arg3,
      *arg4,
      *arg5,
      *arg6,
      *arg7);
    i++;
    ++arg2;
    ++arg3;
    ++arg4;
    ++arg5;
    ++arg6;
    if ((mapbegin+i)%newline==0) {
    }
  }
}

void  processSliceNoCompact (::brook::stream curgather,
		::brook::stream nextslice,
		::brook::stream vertex,
		const __BRTIter& center,
		const __BRTIter& up,
		const __BRTIter& forward,
		const __BRTIter& upforward,
		const float2  slice) {
  static const void *__processSliceNoCompact_fp[] = {
     "fp30", __processSliceNoCompact_fp30,
     "arb", __processSliceNoCompact_arb,
     "ps20", __processSliceNoCompact_ps20,
     "cpu", (void *) __processSliceNoCompact_cpu,
     NULL, NULL };
  static __BRTKernel k(__processSliceNoCompact_fp);

  k->PushGatherStream(curgather);
  k->PushGatherStream(nextslice);
  k->PushOutput(vertex);
  k->PushIter(center);
  k->PushIter(up);
  k->PushIter(forward);
  k->PushIter(upforward);
  k->PushConstant(slice);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompact_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 0, 0, 1\n"
				"    def c3, 0.333333, 0.5, -256, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.x, r7.w, r3.w, c2.x\n"
				"    add r2.w, r0.w, c3.z\n"
				"    cmp_pp r2.w, r2.w, c2.x, c2.w\n"
				"    cmp_pp r9.w, r0.w, c2.w, c2.x\n"
				"    mul_pp r2.w, r2.w, r9.w\n"
				"    cmp r2.y, -r2.w, c2.x, r0.w\n"
				"    mad r11.x, r2.x, c1.x, c1.z\n"
				"    mad r11.y, r2.y, c1.y, c1.w\n"
				"    texld r6, r11, s1\n"
				"    add r0.xyz, r0, r6\n"
				"    mov r0.w, c2.x\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:trianglesA\n"
				"//o:3:trianglesB\n"
				"//o:3:trianglesC\n"
				"//o:3:trianglesD\n"
				"//o:3:trianglesE\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(1, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 0, 0, 1\n"
				"    def c3, 0.333333, 0.5, -256, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.w, r7.w, r3.w, c2.x\n"
				"    add r9.x, r2.w, c3.w\n"
				"    add r9.w, r0.w, c3.z\n"
				"    cmp_pp r9.w, r9.w, c2.x, c2.w\n"
				"    cmp_pp r4.w, r0.w, c2.w, c2.x\n"
				"    mul_pp r9.w, r9.w, r4.w\n"
				"    cmp r9.y, -r9.w, c2.x, r0.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    texld r1, r6, s1\n"
				"    add r0.xyz, r0, r1\n"
				"    mov r0.w, c2.x\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:trianglesA\n"
				"//o:3:trianglesB\n"
				"//o:3:trianglesC\n"
				"//o:3:trianglesD\n"
				"//o:3:trianglesE\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:1:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 6, 0, 1\n"
				"    def c3, 0.333333, 0.5, -256, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.w, r7.w, r3.w, c2.x\n"
				"    add r9.x, r2.w, c2.y\n"
				"    add r9.w, r0.w, c3.z\n"
				"    cmp_pp r9.w, r9.w, c2.x, c2.w\n"
				"    cmp_pp r4.w, r0.w, c2.w, c2.x\n"
				"    mul_pp r9.w, r9.w, r4.w\n"
				"    cmp r9.y, -r9.w, c2.x, r0.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    texld r1, r6, s1\n"
				"    add r0.xyz, r0, r1\n"
				"    mov r0.w, c2.x\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:trianglesA\n"
				"//o:3:trianglesB\n"
				"//o:3:trianglesC\n"
				"//o:3:trianglesD\n"
				"//o:3:trianglesE\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:2:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 9, 0, 1\n"
				"    def c3, 0.333333, 0.5, -256, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.w, r7.w, r3.w, c2.x\n"
				"    add r9.x, r2.w, c2.y\n"
				"    add r9.w, r0.w, c3.z\n"
				"    cmp_pp r9.w, r9.w, c2.x, c2.w\n"
				"    cmp_pp r4.w, r0.w, c2.w, c2.x\n"
				"    mul_pp r9.w, r9.w, r4.w\n"
				"    cmp r9.y, -r9.w, c2.x, r0.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    texld r1, r6, s1\n"
				"    add r0.xyz, r0, r1\n"
				"    mov r0.w, c2.x\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:trianglesA\n"
				"//o:3:trianglesB\n"
				"//o:3:trianglesC\n"
				"//o:3:trianglesD\n"
				"//o:3:trianglesE\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:3:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(4, 0)
			)
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 0, 12, 0, 1\n"
				"    def c3, 0.333333, 0.5, -256, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.w, r7.w, r3.w, c2.x\n"
				"    add r9.x, r2.w, c2.y\n"
				"    add r9.w, r0.w, c3.z\n"
				"    cmp_pp r9.w, r9.w, c2.x, c2.w\n"
				"    cmp_pp r4.w, r0.w, c2.w, c2.x\n"
				"    mul_pp r9.w, r9.w, r4.w\n"
				"    cmp r9.y, -r9.w, c2.x, r0.w\n"
				"    mad r6.x, r9.x, c1.x, c1.z\n"
				"    mad r6.y, r9.y, c1.y, c1.w\n"
				"    texld r1, r6, s1\n"
				"    add r0.xyz, r0, r1\n"
				"    mov r0.w, c2.x\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:7\n"
				"//oi:3:trianglesA\n"
				"//o:3:trianglesB\n"
				"//o:3:trianglesC\n"
				"//o:3:trianglesD\n"
				"//o:3:trianglesE\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:4:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(5, 0)
			)
		);
	static const void* __processTrianglesNoCompact_ps20 = &__processTrianglesNoCompact_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompact_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVR R1.xy, R2;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.x(GT.x), {0}.x;\n"
				"TEX R1.xyz, R1.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(1, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 0 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_1 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"MOVR R1.y, R2.yyzw;\n"
				"ADDR R1.w, R2.x, {3}.x;\n"
				"MOVR R1.x, R1.w;\n"
				"TEX R1.xyz, R1.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 0 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_2 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"MOVR R1.yzw, R2.yyzw;\n"
				"ADDR R2.x, R2.x, {3}.x;\n"
				"MOVR R1.x, R2.x;\n"
				"MOVR R2.y, R1.yyzw;\n"
				"ADDR R1.x, R1.x, {3}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 0 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_3 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"MOVR R1.yzw, R2.yyzw;\n"
				"ADDR R2.x, R2.x, {3}.x;\n"
				"MOVR R1.x, R2.x;\n"
				"MOVR R2.yzw, R1.yyzw;\n"
				"ADDR R1.x, R1.x, {3}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"MOVR R1.y, R2.yyzw;\n"
				"ADDR R1.w, R2.x, {3}.x;\n"
				"MOVR R1.x, R1.w;\n"
				"TEX R1.xyz, R1.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(4, 0)
			)
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 0 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float4 __output_4 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"MOVR R1.yzw, R2.yyzw;\n"
				"ADDR R2.x, R2.x, {3}.x;\n"
				"MOVR R1.x, R2.x;\n"
				"MOVR R2.yzw, R1.yyzw;\n"
				"ADDR R1.x, R1.x, {3}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"MOVR R1.yzw, R2.yyzw;\n"
				"ADDR R2.x, R2.x, {3}.x;\n"
				"MOVR R1.x, R2.x;\n"
				"MOVR R2.y, R1.yyzw;\n"
				"ADDR R1.x, R1.x, {3}.x;\n"
				"MOVR R2.x, R1.x;\n"
				"TEX R1.xyz, R2.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:4:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(5, 0)
			)
		);
	static const void* __processTrianglesNoCompact_fp30 = &__processTrianglesNoCompact_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompact_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 0, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, -256, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.x, r7.w, c2.x, r3.w;\n"
				"ADD r2.w, r0.w, c3.z;\n"
				"CMP r2.w, r2.w, c2.w, c2.x;\n"
				"CMP r9.w, r0.w, c2.x, c2.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"CMP r2.y, -r2.w, r0.w, c2.x;\n"
				"MAD r11.x, r2.x, c1.x, c1.z;\n"
				"MAD r11.y, r2.y, c1.y, c1.w;\n"
				"TEX r6, r11, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r6;\n"
				"MOV r0.w, c2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(1, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 0, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, -256, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.w, r7.w, c2.x, r3.w;\n"
				"ADD r9.x, r2.w, c3.w;\n"
				"ADD r9.w, r0.w, c3.z;\n"
				"CMP r9.w, r9.w, c2.w, c2.x;\n"
				"CMP r4.w, r0.w, c2.x, c2.w;\n"
				"MUL r9.w, r9.w, r4.w;\n"
				"CMP r9.y, -r9.w, r0.w, c2.x;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"TEX r1, r6, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r1;\n"
				"MOV r0.w, c2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:1:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(2, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 6, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, -256, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.w, r7.w, c2.x, r3.w;\n"
				"ADD r9.x, r2.w, c2.y;\n"
				"ADD r9.w, r0.w, c3.z;\n"
				"CMP r9.w, r9.w, c2.w, c2.x;\n"
				"CMP r4.w, r0.w, c2.x, c2.w;\n"
				"MUL r9.w, r9.w, r4.w;\n"
				"CMP r9.y, -r9.w, r0.w, c2.x;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"TEX r1, r6, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r1;\n"
				"MOV r0.w, c2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:2:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(3, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 9, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, -256, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.w, r7.w, c2.x, r3.w;\n"
				"ADD r9.x, r2.w, c2.y;\n"
				"ADD r9.w, r0.w, c3.z;\n"
				"CMP r9.w, r9.w, c2.w, c2.x;\n"
				"CMP r4.w, r0.w, c2.x, c2.w;\n"
				"MUL r9.w, r9.w, r4.w;\n"
				"CMP r9.y, -r9.w, r0.w, c2.x;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"TEX r1, r6, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r1;\n"
				"MOV r0.w, c2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:3:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(4, 0)
			)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {0, 12, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, -256, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.w, r7.w, c2.x, r3.w;\n"
				"ADD r9.x, r2.w, c2.y;\n"
				"ADD r9.w, r0.w, c3.z;\n"
				"CMP r9.w, r9.w, c2.w, c2.x;\n"
				"CMP r4.w, r0.w, c2.x, c2.w;\n"
				"MUL r9.w, r9.w, r4.w;\n"
				"CMP r9.y, -r9.w, r0.w, c2.x;\n"
				"MAD r6.x, r9.x, c1.x, c1.z;\n"
				"MAD r6.y, r9.y, c1.y, c1.w;\n"
				"TEX r1, r6, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r1;\n"
				"MOV r0.w, c2.x;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##oi:3:trianglesA\n"
				"##o:3:trianglesB\n"
				"##o:3:trianglesC\n"
				"##o:3:trianglesD\n"
				"##o:3:trianglesE\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:4:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(7, kGatherConstant_Shape)
				.sampler(6, 0)
				.sampler(7, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(6, kStreamInterpolant_Position)
				.output(5, 0)
			)
		);
	static const void* __processTrianglesNoCompact_arb = &__processTrianglesNoCompact_arb_desc;
}

void __processTrianglesNoCompact_cpu_inner (__BrtFloat3  &trianglesA,
                                             __BrtFloat3  &trianglesB,
                                             __BrtFloat3  &trianglesC,
                                             __BrtFloat3  &trianglesD,
                                             __BrtFloat3  &trianglesE,
                                             const __BrtFloat4  &vertices1,
                                             const __BrtArray2d<__BrtFloat3  > &volumeTriangles,
                                             const __BrtFloat4 &__indexof_trianglesA){
  __BrtFloat4  whichVolumeTriangle = __BrtFloat4(__round_cpu_inner(__fmod_cpu_inner((__indexof_trianglesA).swizzle1(maskX),__BrtFloat1((float)3))), vertices1.swizzle1(maskW), __BrtFloat1((float)0), __BrtFloat1((float)0));
  __BrtFloat3  vertices = vertices1.swizzle3(maskX, maskY, maskZ);

  if (!(whichVolumeTriangle.swizzle1(maskY) < __BrtFloat1((float)256) && whichVolumeTriangle.swizzle1(maskY) >= __BrtFloat1((float)0)))
    whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskY);
  if (whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1(0.500000f) > __BrtFloat1((float)3))
    whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskX);
  trianglesA = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)3),maskX);
  trianglesB = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)3),maskX);
  trianglesC = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)3),maskX);
  trianglesD = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
  whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)3),maskX);
  trianglesE = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
}
void  __processTrianglesNoCompact_cpu (const std::vector<void *>&args,
                                       const std::vector<const unsigned int *>&extents,
                                       const std::vector<unsigned int>&dims,
                                       unsigned int mapbegin, 
                                       unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat3 *arg1 = (__BrtFloat3 *)args[1];
  __BrtFloat3 *arg2 = (__BrtFloat3 *)args[2];
  __BrtFloat3 *arg3 = (__BrtFloat3 *)args[3];
  __BrtFloat3 *arg4 = (__BrtFloat3 *)args[4];
  __BrtFloat4 *arg5 = (__BrtFloat4 *)args[5];
  __BrtArray2d<__BrtFloat3  > arg6(
      (__BrtFloat3  *)args[6], extents[6]);
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio1 = extents[0][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[0][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[0]);
  unsigned int ratio2 = extents[0][dim-1]/extents[2][dim-1];
  unsigned int scale2=extents[2][dim-1]/extents[0][dim-1];
  if (scale2<1) scale2 = 1;
  unsigned int ratioiter2 = 0;
  if (ratio2) ratioiter2 = mapbegin%ratio2;
  unsigned int iter2 = getIndexOf(mapbegin,extents[2], dim, extents[0]);
  unsigned int ratio3 = extents[0][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[0][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[0]);
  unsigned int ratio4 = extents[0][dim-1]/extents[4][dim-1];
  unsigned int scale4=extents[4][dim-1]/extents[0][dim-1];
  if (scale4<1) scale4 = 1;
  unsigned int ratioiter4 = 0;
  if (ratio4) ratioiter4 = mapbegin%ratio4;
  unsigned int iter4 = getIndexOf(mapbegin,extents[4], dim, extents[0]);
  unsigned int ratio5 = extents[0][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[0][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __processTrianglesNoCompact_cpu_inner (
      *arg0,
      *(arg1 + iter1),
      *(arg2 + iter2),
      *(arg3 + iter3),
      *(arg4 + iter4),
      *(arg5 + iter5),
      arg6,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if (++ratioiter2>=ratio2){
      ratioiter2=0;
      iter2+=scale2;
    }
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    if (++ratioiter4>=ratio4){
      ratioiter4=0;
      iter4+=scale4;
    }
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[0]);
      iter2=getIndexOf(i+mapbegin,extents[2],dim, extents[0]);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[0]);
      iter4=getIndexOf(i+mapbegin,extents[4],dim, extents[0]);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[0]);
    }
  }
}

void  processTrianglesNoCompact (::brook::stream trianglesA,
		::brook::stream trianglesB,
		::brook::stream trianglesC,
		::brook::stream trianglesD,
		::brook::stream trianglesE,
		::brook::stream vertices1,
		::brook::stream volumeTriangles) {
  static const void *__processTrianglesNoCompact_fp[] = {
     "fp30", __processTrianglesNoCompact_fp30,
     "arb", __processTrianglesNoCompact_arb,
     "ps20", __processTrianglesNoCompact_ps20,
     "cpu", (void *) __processTrianglesNoCompact_cpu,
     NULL, NULL };
  static __BRTKernel k(__processTrianglesNoCompact_fp);

  k->PushOutput(trianglesA);
  k->PushOutput(trianglesB);
  k->PushOutput(trianglesC);
  k->PushOutput(trianglesD);
  k->PushOutput(trianglesE);
  k->PushStream(vertices1);
  k->PushGatherStream(volumeTriangles);
  k->Map();

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTriangles_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c3, 15, 0, 1, -256\n"
				"    def c4, 0.25, 3, 3.5, 12\n"
				"    def c5, -0.5, -1, -2, -0.75\n"
				"    def c6, 2, 0, 0, -3\n"
				"    dcl t0.xy\n"
				"    dcl t1.x\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    texld r0, t0, s0\n"
				"    mul r7.w, t1.x, c4.x\n"
				"    frc r2.w, r7.w\n"
				"    mul r9.w, r2.w, c4.w\n"
				"    add r4.w, r9.w, c4.z\n"
				"    add r11.w, r9.w, c4.y\n"
				"    add r1.w, -r4.w, c3.x\n"
				"    cmp r8.z, r1.w, r11.w, c4.y\n"
				"    add r3.w, r0.w, c3.w\n"
				"    cmp_pp r10.w, r3.w, c3.y, c3.z\n"
				"    cmp_pp r5.w, r0.w, c3.z, c3.y\n"
				"    mul_pp r7.w, r10.w, r5.w\n"
				"    cmp r8.w, -r7.w, c3.y, r0.w\n"
				"    mad r4.x, r8.z, c0.x, c0.z\n"
				"    mad r4.y, r8.w, c0.y, c0.w\n"
				"    mov r11.xy, c2.z\n"
				"    add r8.y, r8.z, c3.z\n"
				"    add r8.x, r8.z, c6.x\n"
				"    mad r3.x, r8.y, c0.x, c0.z\n"
				"    mad r3.y, r8.w, c0.y, c0.w\n"
				"    mad r10.x, r8.x, c0.x, c0.z\n"
				"    mad r10.y, r8.w, c0.y, c0.w\n"
				"    texld r5, r4, s1\n"
				"    texld r7, r11, s2\n"
				"    texld r2, r3, s1\n"
				"    texld r9, r10, s1\n"
				"    mov r1.w, c1.x\n"
				"    add r5.w, c6.w, r1.w\n"
				"    add r5.w, -r5.w, c5.y\n"
				"    abs r5.w, r5.w\n"
				"    mov r0.w, -r5.w\n"
				"    add r5.w, c5.z, r1.w\n"
				"    add r5.w, -r5.w, c5.y\n"
				"    abs r5.w, r5.w\n"
				"    mov r9.w, -r5.w\n"
				"    add r5.w, c5.y, r1.w\n"
				"    add r5.w, -r5.w, c5.y\n"
				"    abs r5.w, r5.w\n"
				"    add r4.xyz, r0, r5\n"
				"    add r4.w, r5.x, c5.x\n"
				"    cmp r4.xyz, -r5.w, r4, r7.x\n"
				"    add r11.xyz, r0, r2\n"
				"    cmp r4.xyz, r9.w, r11, r4\n"
				"    add r0.xyz, r0, r9\n"
				"    cmp r4.xyz, r0.w, r0, r4\n"
				"    abs r4.w, r4.w\n"
				"    add r4.w, r4.w, c5.w\n"
				"    cmp r8.xyz, r4.w, r7.x, r4\n"
				"    mov r8.w, c3.y\n"
				"    mov oC0, r8\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:6\n"
				"//o:3:__triangles_stream\n"
				"//s:4:vertices\n"
				"//c:3:volumeTriangles\n"
				"//s:2:streamsize\n"
				"//c:1:__vout_counter\n"
				"//c:1:__inf\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kStreamInterpolant_Position)
				.interpolant(4, kIteratorInterpolant_Value)
				.output(1, 0)
			)
		);
	static const void* __processTriangles_ps20 = &__processTriangles_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTriangles_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._tex_vertices : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C0\n"
				"#semantic main.__vout_counter : C1\n"
				"#semantic main.__inf : TEXUNIT2\n"
				"#semantic main.__gatherconst___inf : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var samplerRECT _tex_vertices : TEXUNIT0 : texunit 0 : 1 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C0 :  : 4 : 1\n"
				"#var float __vout_counter : C1 :  : 6 : 1\n"
				"#var samplerRECT __inf[0] : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float4 __gatherconst___inf : C2 :  : 8 : 1\n"
				"#var float4 __workspace : C3 :  : 9 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_vertices_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 streamsize : $vin.TEXCOORD1 : TEX1 : 5 : 1\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __vout_counter;\n"
				"DECLARE __gatherconst___inf;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX0].xyxx, TEX0, RECT;\n"
				"TEX R1.x, {0, 0}.xyxx, TEX2, RECT;\n"
				"SLTR H0.x, f[TEX1].x, {0}.x;\n"
				"MULR R2.x, f[TEX1].x, {0.25}.x;\n"
				"FRCR R2.x, |R2.x|;\n"
				"MULR R2.x, R2.x, {4}.x;\n"
				"MOVR R2.y, R2.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), -R2.x;\n"
				"MADR R2.y, R2.y, {3}.x, {3}.x;\n"
				"MOVR R3.w, R0;\n"
				"MOVR R3.y, R3.w;\n"
				"MOVR R3.x, R2.y;\n"
				"MOVR R3.zw, {0, 0, 0, 0}.zzzw;\n"
				"ADDR R2.x, R3.x, {0.5}.x;\n"
				"SGTR H0.x, R2.x, {15}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.x(GT.x), {3}.x;\n"
				"SGER H0.x, R3.y, {0}.x;\n"
				"SLTR H0.y, R3.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R3.y(GT.x), {0}.x;\n"
				"MOVR R2.x, {1}.x;\n"
				"ADDR R2.x, __vout_counter.x, -R2.x;\n"
				"SEQR H0.x, {-1}.x, R2.x;\n"
				"ADDR R2.x, R2.x, -{1}.x;\n"
				"SEQR H0.y, {-1}.x, R2.x;\n"
				"ADDR R2.x, R2.x, -{1}.x;\n"
				"SEQR H0.z, {-1}.x, R2.x;\n"
				"TEX R2.xyz, R3.xyxx, TEX1, RECT;\n"
				"ADDR R4.xyz, R0.xyzx, R2.xyzx;\n"
				"ADDR R2.x, R2.x, -{0.5}.x;\n"
				"SLTR H0.w, |R2.x|, {0.75}.x;\n"
				"MOVR R2.xyz, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.xyz(GT.x), R4.xyzx;\n"
				"MOVR R1.xyz, R1.x;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR R1.xyz(GT.x), R2.xyzx;\n"
				"MOVR R2.yzw, R3.yyzw;\n"
				"ADDR R1.w, R3.x, {1}.x;\n"
				"MOVR R2.x, R1.w;\n"
				"TEX R3.xyz, R2.xyxx, TEX1, RECT;\n"
				"ADDR R3.xyz, R0.xyzx, R3.xyzx;\n"
				"MOVR R4.xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R4.xyz(GT.x), R3.xyzx;\n"
				"MOVR R3.y, R2.yyzw;\n"
				"ADDR R1.w, R2.x, {1}.x;\n"
				"MOVR R3.x, R1.w;\n"
				"TEX R2.xyz, R3.xyxx, TEX1, RECT;\n"
				"ADDR R0.xyz, R0.xyzx, R2.xyzx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR R1.xyz(GT.x), R4.xyzx;\n"
				"MOVR R2.xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.z;\n"
				"MOVR R2.xyz(GT.x), R0.xyzx;\n"
				"MOVR R0.xyz, R1.xyzx;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR R0.xyz(GT.x), R2.xyzx;\n"
				"MOVR R0.w, {0, 0, 0, 0}.w;\n"
				"MOVR o[COLR], R0;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##o:3:__triangles_stream\n"
				"##s:4:vertices\n"
				"##c:3:volumeTriangles\n"
				"##s:2:streamsize\n"
				"##c:1:__vout_counter\n"
				"##c:1:__inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kStreamInterpolant_Position)
				.interpolant(4, kIteratorInterpolant_Value)
				.output(1, 0)
			)
		);
	static const void* __processTriangles_fp30 = &__processTriangles_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTriangles_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = {15, 0, 1, -256};\n"
				"PARAM c4 = {0.25, 3, 3.5, 12};\n"
				"PARAM c5 = {-0.5, -1, -2, -0.75};\n"
				"PARAM c6 = {2, 0, 0, -3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t0, texture[0], RECT;\n"
				"MUL r7.w, t1.x, c4.x;\n"
				"FRC r2.w, r7.w;\n"
				"MUL r9.w, r2.w, c4.w;\n"
				"ADD r4.w, r9.w, c4.z;\n"
				"ADD r11.w, r9.w, c4.y;\n"
				"ADD r1.w, -r4.w, c3.x;\n"
				"CMP r8.z, r1.w, c4.y, r11.w;\n"
				"ADD r3.w, r0.w, c3.w;\n"
				"CMP r10.w, r3.w, c3.z, c3.y;\n"
				"CMP r5.w, r0.w, c3.y, c3.z;\n"
				"MUL r7.w, r10.w, r5.w;\n"
				"CMP r8.w, -r7.w, r0.w, c3.y;\n"
				"MAD r4.x, r8.z, c0.x, c0.z;\n"
				"MAD r4.y, r8.w, c0.y, c0.w;\n"
				"MOV r11.xy, c2.z;\n"
				"ADD r8.y, r8.z, c3.z;\n"
				"ADD r8.x, r8.z, c6.x;\n"
				"MAD r3.x, r8.y, c0.x, c0.z;\n"
				"MAD r3.y, r8.w, c0.y, c0.w;\n"
				"MAD r10.x, r8.x, c0.x, c0.z;\n"
				"MAD r10.y, r8.w, c0.y, c0.w;\n"
				"TEX r5, r4, texture[1], RECT;\n"
				"TEX r7, r11, texture[2], RECT;\n"
				"TEX r2, r3, texture[1], RECT;\n"
				"TEX r9, r10, texture[1], RECT;\n"
				"MOV r1.w, c1.x;\n"
				"ADD r5.w, c6.w, r1.w;\n"
				"ADD r5.w, -r5.w, c5.y;\n"
				"ABS r5.w, r5.w;\n"
				"MOV r0.w, -r5.w;\n"
				"ADD r5.w, c5.z, r1.w;\n"
				"ADD r5.w, -r5.w, c5.y;\n"
				"ABS r5.w, r5.w;\n"
				"MOV r9.w, -r5.w;\n"
				"ADD r5.w, c5.y, r1.w;\n"
				"ADD r5.w, -r5.w, c5.y;\n"
				"ABS r5.w, r5.w;\n"
				"ADD r4.xyz, r0, r5;\n"
				"ADD r4.w, r5.x, c5.x;\n"
				"CMP r4.xyz, -r5.w, r7.x, r4;\n"
				"ADD r11.xyz, r0, r2;\n"
				"CMP r4.xyz, r9.w, r4, r11;\n"
				"ADD r0.xyz, r0, r9;\n"
				"CMP r4.xyz, r0.w, r4, r0;\n"
				"ABS r4.w, r4.w;\n"
				"ADD r4.w, r4.w, c5.w;\n"
				"CMP r8.xyz, r4.w, r4, r7.x;\n"
				"MOV r8.w, c3.y;\n"
				"MOV oC0, r8;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:6\n"
				"##o:3:__triangles_stream\n"
				"##s:4:vertices\n"
				"##c:3:volumeTriangles\n"
				"##s:2:streamsize\n"
				"##c:1:__vout_counter\n"
				"##c:1:__inf\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(3, kGatherConstant_Shape)
				.constant(5, 0)
				.constant(6, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(6, 0)
				.interpolant(2, kStreamInterpolant_Position)
				.interpolant(4, kIteratorInterpolant_Value)
				.output(1, 0)
			)
		);
	static const void* __processTriangles_arb = &__processTriangles_arb_desc;
}

void __processTriangles_cpu_inner (__BrtFloat3  &__triangles_stream,
                                    const __BrtFloat4  &vertices,
                                    const __BrtArray2d<__BrtFloat3  > &volumeTriangles,
                                    const __BrtFloat2  &streamsize,
                                    __BrtFloat1  __vout_counter,
                                    const __BrtArray1d<__BrtFloat1  > &__inf){
  __triangles_stream = __inf[__BrtFloat1(0.000000f)];
  {
    __BrtFloat3  triangles;
    __BrtFloat4  whichVolumeTriangle = __BrtFloat4(__fmod_cpu_inner(streamsize.swizzle1(maskX),__BrtFloat1(4.000000f)) * __BrtFloat1(3.000000f) + __BrtFloat1(3.000000f), vertices.swizzle1(maskW), __BrtFloat1((float)0), __BrtFloat1((float)0));
    __BrtFloat3  firstTrianglePos;

    if (whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1(0.500000f) > __BrtFloat1(15.000000f))
      whichVolumeTriangle.mask1(__BrtFloat1(3.000000f),maskX);
    if (!(whichVolumeTriangle.swizzle1(maskY) < __BrtFloat1((float)256) && whichVolumeTriangle.swizzle1(maskY) >= __BrtFloat1((float)0)))
      whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskY);
    firstTrianglePos = volumeTriangles[whichVolumeTriangle];
    if (__abs_cpu_inner(firstTrianglePos.swizzle1(maskX) - __BrtFloat1(0.500000f)) < __BrtFloat1(0.750000f))
    {
      triangles = vertices.swizzle3(maskX, maskY, maskZ) + firstTrianglePos;
      __triangles_stream = (__BrtFloat1(-1.000000f) == (__vout_counter -= __BrtFloat1((float)1))).questioncolon(triangles,__triangles_stream);
      whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)1),maskX);
      triangles = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
      __triangles_stream = (__BrtFloat1(-1.000000f) == (__vout_counter -= __BrtFloat1((float)1))).questioncolon(triangles,__triangles_stream);
      whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1((float)1),maskX);
      triangles = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
      __triangles_stream = (__BrtFloat1(-1.000000f) == (__vout_counter -= __BrtFloat1((float)1))).questioncolon(triangles,__triangles_stream);
    }

  }

}
void  __processTriangles_cpu (const std::vector<void *>&args,
                              const std::vector<const unsigned int *>&extents,
                              const std::vector<unsigned int>&dims,
                              unsigned int mapbegin, 
                              unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtFloat2 *arg3 = (__BrtFloat2 *)args[3];
  __BrtFloat1 *arg4 = (__BrtFloat1 *)args[4];
  __BrtArray1d<__BrtFloat1  > arg5(
      (__BrtFloat1  *)args[5], extents[5]);
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio1 = extents[0][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[0][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[0]);
  arg3+=mapbegin;
  unsigned int i=0; 
  while (i<mapextent) {
    __processTriangles_cpu_inner (
      *arg0,
      *(arg1 + iter1),
      arg2,
      *arg3,
      *arg4,
      arg5);
    i++;
    ++arg0;
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg3;
    if ((mapbegin+i)%newline==0) {
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[0]);
    }
  }
}

extern int finiteValueProduced1dfloat (brook::stream input);
extern float shiftValues1dfloat(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat (brook::stream input);
extern float shiftValuesfloat(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat2 (brook::stream input);
extern float shiftValues1dfloat2(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat2(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat2 (brook::stream input);
extern float shiftValuesfloat2(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat2(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat3 (brook::stream input);
extern float shiftValues1dfloat3(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat3(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat3 (brook::stream input);
extern float shiftValuesfloat3(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat3(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProduced1dfloat4 (brook::stream input);
extern float shiftValues1dfloat4(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreams1dfloat4(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
extern int finiteValueProducedfloat4 (brook::stream input);
extern float shiftValuesfloat4(brook::stream list_stream,
                         brook::stream *output_stream,
                         int WIDTH, 
                         int LENGTH, 
                         int sign);
void combineStreamsfloat4(brook::stream **streams,
                     unsigned int num,
                     unsigned int width, 
                     unsigned int length,
                     brook::stream *output) ;
void  processTriangles (::brook::stream &__triangles_stream,
		::brook::stream vertices,
		::brook::stream volumeTriangles,
		const __BRTIter& streamsize) {
  static const void *__processTriangles_fp[] = {
     "fp30", __processTriangles_fp30,
     "arb", __processTriangles_arb,
     "ps20", __processTriangles_ps20,
     "cpu", (void *) __processTriangles_cpu,
     NULL, NULL };
  static __BRTKernel k(__processTriangles_fp);

  float __vout_counter=0.0f;
  brook::Stream * __inf = *sentinelStream(1);
  int maxextents[2]={0,0};
  unsigned int __dimension = vertices->getDimension();
  assert (vertices->getDimension()<=2);
  maxDimension(maxextents,vertices->getExtents(),vertices->getDimension());
  assert (streamsize->getDimension()<=2);
  maxDimension(maxextents,streamsize->getExtents(),streamsize->getDimension());
  std:: vector <__BRTStreamType> __triangles_types;
  for (int __triangles_iter = 0; __triangles_iter < __triangles_stream->getFieldCount(); ++__triangles_iter) 
    __triangles_types.push_back(__triangles_stream->getIndexedFieldType(__triangles_iter));
  __triangles_types.push_back(__BRTNONE);
  std::vector<brook::stream*> __triangles_outputs;
  bool __triangles_values = true;
  while (__triangles_values) {
    if (__triangles_values)
       __triangles_outputs.push_back (new brook::stream
                                      //(quickAllocStream
                                       (&__triangles_types[0],maxextents[0],maxextents[1],-1))
                                      ;
                                      //);
    k->PushOutput(*__triangles_outputs.back());
    k->PushStream(vertices);
    k->PushGatherStream(volumeTriangles);
    k->PushIter(streamsize);
    k->PushConstant(__vout_counter);
    k->PushGatherStream(__inf);
    k->Map();
    __vout_counter+=1.0f;
     if ((__vout_counter >= 3)) {
      __triangles_outputs.push_back(0);
      break;
    }
  }
  if (__triangles_stream->getDimension()==2) {
    ::brook::stream __triangles_temp=quickAllocStream(&__triangles_types[0],1, 1, -1);
    combineStreamsfloat3 (&__triangles_outputs[0],
                   __triangles_outputs.size()-1,
                   maxextents[0],
                   maxextents[1],
                   &__triangles_temp);
    shiftValuesfloat3(__triangles_temp,
                &__triangles_stream,
                __triangles_temp->getExtents()[0],
                __triangles_temp->getExtents()[1],
                -1);
  }else {
    ::brook::stream __triangles_temp(&__triangles_types[0],1, -1);
    combineStreams1dfloat3 (&__triangles_outputs[0],
                   __triangles_outputs.size()-1,
                   maxextents[0],
                   maxextents[1],
                   &__triangles_temp);
    shiftValues1dfloat3(__triangles_temp,
                &__triangles_stream,
                __triangles_temp->getExtents()[0],
                 1,                -1);
  }
  while (__triangles_outputs.size()) {
    if (__triangles_outputs.back())
       delete __triangles_outputs.back();
    __triangles_outputs.pop_back();
  }

}



namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processFirstTriangles_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, -256, 0, 0, 1\n"
				"    def c3, 0.333333, 0.5, 0, 3\n"
				"    dcl t0.x\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.w, t0.x, c0.x, c0.z\n"
				"    mul r9.w, r2.w, c3.x\n"
				"    frc r4.w, r9.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.x, r7.w, r3.w, c3.z\n"
				"    add r2.w, r0.w, c2.x\n"
				"    mov r1.w, c2.w\n"
				"    cmp_pp r2.w, r2.w, c3.z, r1.w\n"
				"    mov r1.w, c3.z\n"
				"    cmp_pp r9.w, r0.w, c2.w, r1.w\n"
				"    mul_pp r2.w, r2.w, r9.w\n"
				"    cmp r2.y, -r2.w, c3.z, r0.w\n"
				"    mad r11.x, r2.x, c1.x, c1.z\n"
				"    mad r11.y, r2.y, c1.y, c1.w\n"
				"    texld r6, r11, s1\n"
				"    add r0.xyz, r0, r6\n"
				"    mov r0.w, c3.z\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//oi:3:triangles\n"
				"//s:4:vertices\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processFirstTriangles_ps20 = &__processFirstTriangles_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processFirstTriangles_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_triangles_invscalebias : C0\n"
				"#semantic main._tex_vertices : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_triangles_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT _tex_vertices : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_triangles_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_vertices_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_triangles_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.x, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"MULR R1.x, R1.x, {0.33333334}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {3}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.y, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.y, H0.x, {1}.x;\n"
				"MOVR R1.xy, R2;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), {0}.x;\n"
				"TEX R1.xyz, R1.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##oi:3:triangles\n"
				"##s:4:vertices\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processFirstTriangles_fp30 = &__processFirstTriangles_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processFirstTriangles_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {-256, 0, 0, 1};\n"
				"PARAM c3 = {0.333333, 0.5, 0, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.w, t0.x, c0.x, c0.z;\n"
				"MUL r9.w, r2.w, c3.x;\n"
				"FRC r4.w, r9.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.x, r7.w, c3.z, r3.w;\n"
				"ADD r2.w, r0.w, c2.x;\n"
				"MOV r1.w, c2.w;\n"
				"CMP r2.w, r2.w, r1.w, c3.z;\n"
				"MOV r1.w, c3.z;\n"
				"CMP r9.w, r0.w, r1.w, c2.w;\n"
				"MUL r2.w, r2.w, r9.w;\n"
				"CMP r2.y, -r2.w, r0.w, c3.z;\n"
				"MAD r11.x, r2.x, c1.x, c1.z;\n"
				"MAD r11.y, r2.y, c1.y, c1.w;\n"
				"TEX r6, r11, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r6;\n"
				"MOV r0.w, c3.z;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##oi:3:triangles\n"
				"##s:4:vertices\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processFirstTriangles_arb = &__processFirstTriangles_arb_desc;
}

void __processFirstTriangles_cpu_inner (__BrtFloat3  &triangles,
                                         const __BrtFloat4  &vertices,
                                         const __BrtArray2d<__BrtFloat3  > &volumeTriangles,
                                         const __BrtFloat4 &__indexof_triangles){
  __BrtFloat4  whichVolumeTriangle = __BrtFloat4(__round_cpu_inner(__fmod_cpu_inner((__indexof_triangles).swizzle1(maskX),__BrtFloat1(3.000000f))), vertices.swizzle1(maskW), __BrtFloat1((float)0), __BrtFloat1((float)0));

  if (whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1(0.500000f) > __BrtFloat1(3.000000f))
    whichVolumeTriangle.mask1(__BrtFloat1(0.000000f),maskX);
  if (!(whichVolumeTriangle.swizzle1(maskY) < __BrtFloat1((float)256) && whichVolumeTriangle.swizzle1(maskY) >= __BrtFloat1((float)0)))
    whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskY);
  triangles = vertices.swizzle3(maskX, maskY, maskZ);
  triangles += volumeTriangles[whichVolumeTriangle];
}
void  __processFirstTriangles_cpu (const std::vector<void *>&args,
                                   const std::vector<const unsigned int *>&extents,
                                   const std::vector<unsigned int>&dims,
                                   unsigned int mapbegin, 
                                   unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio1 = extents[0][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[0][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __processFirstTriangles_cpu_inner (
      *arg0,
      *(arg1 + iter1),
      arg2,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[0]);
    }
  }
}

void  processFirstTriangles (::brook::stream triangles,
		::brook::stream vertices,
		::brook::stream volumeTriangles) {
  static const void *__processFirstTriangles_fp[] = {
     "fp30", __processFirstTriangles_fp30,
     "arb", __processFirstTriangles_arb,
     "ps20", __processFirstTriangles_ps20,
     "cpu", (void *) __processFirstTriangles_cpu,
     NULL, NULL };
  static __BRTKernel k(__processFirstTriangles_fp);

  k->PushOutput(triangles);
  k->PushStream(vertices);
  k->PushGatherStream(volumeTriangles);
  k->Map();

}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c4, -256, 1, 0.39, 0\n"
				"    def c5, 0.333333, 0.2, 0, 0.5\n"
				"    def c6, 3, 5, 0, -0.5\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    dcl_2d s2\n"
				"    dcl_2d s3\n"
				"    texld r0, t1, s0\n"
				"    mad r2.x, t0.x, c0.x, c0.z\n"
				"    mad r2.y, t0.y, c0.y, c0.w\n"
				"    mul r9.xy, r2, c5\n"
				"    frc r4.xy, r9\n"
				"    mul r11.xy, r4, c6\n"
				"    add r6.xy, r11, c5.w\n"
				"    frc r1.xy, r6\n"
				"    add r3.xy, r6, -r1\n"
				"    add r10.xy, r3, c5.w\n"
				"    add r7.xy, -r10, c6\n"
				"    cmp r2.xy, r7, r3, c4.w\n"
				"    mad r9.x, r2.y, c6.x, r2.x\n"
				"    add r4, r0, c4.x\n"
				"    cmp_pp r11, r4, c4.w, c4.y\n"
				"    cmp_pp r6, r0, c4.y, c4.w\n"
				"    mul_pp r1, r11, r6\n"
				"    cmp r0, -r1, c4.w, r0\n"
				"    mov r9.y, r0.w\n"
				"    mad r10.x, r9.x, c1.x, c1.z\n"
				"    mad r10.y, r9.y, c1.y, c1.w\n"
				"    texld r5, r10, s1\n"
				"    add r7.xyz, r5, c4.x\n"
				"    cmp r2.xyz, r7, c4.w, r5\n"
				"    add r4.xyz, r2, c6.w\n"
				"    add r11.xy, r0, r2\n"
				"    abs r1.xyz, r4\n"
				"    mov r8.xyz, -r1\n"
				"    mov r9.xz, r11.x\n"
				"    add r11.w, r0.x, c4.y\n"
				"    add r9.w, r0.y, c4.y\n"
				"    mov r11.z, r0.x\n"
				"    mov r9.y, r0.y\n"
				"    cmp r3.yw, r8.x, r11.y, r9\n"
				"    cmp r3.z, r8.x, r11.w, r9.z\n"
				"    cmp r3.x, r8.x, r11.z, r9.x\n"
				"    mad r7.x, r3.x, c2.x, c2.z\n"
				"    mad r7.y, r3.y, c2.y, c2.w\n"
				"    mad r4.x, r3.z, c2.x, c2.z\n"
				"    mad r4.y, r3.w, c2.y, c2.w\n"
				"    mad r1.x, r3.x, c3.x, c3.z\n"
				"    mad r1.y, r3.y, c3.y, c3.w\n"
				"    mad r9.x, r3.z, c3.x, c3.z\n"
				"    mad r9.y, r3.w, c3.y, c3.w\n"
				"    mad r2.x, r11.x, c2.x, c2.z\n"
				"    mad r2.y, r11.y, c2.y, c2.w\n"
				"    mad r3.x, r11.x, c3.x, c3.z\n"
				"    mad r3.y, r11.y, c3.y, c3.w\n"
				"    texld r7, r7, s2\n"
				"    texld r4, r4, s2\n"
				"    texld r6, r1, s3\n"
				"    texld r1, r9, s3\n"
				"    texld r9, r2, s2\n"
				"    texld r10, r3, s3\n"
				"    mov r7.y, r4.x\n"
				"    mov r6.y, r1.x\n"
				"    abs r8.w, r5.z\n"
				"    cmp r11.xy, -r8.w, r7, r6\n"
				"    mov r9.y, r10.x\n"
				"    cmp r2.xy, r8.z, r9, r11\n"
				"    add r5.w, r2.y, -r2.x\n"
				"    add r8.w, -r2.x, c4.z\n"
				"    rcp r5.w, r5.w\n"
				"    mul r8.w, r8.w, r5.w\n"
				"    cmp r3.xyz, r8, r8.w, r5\n"
				"    add r0.xyz, r0, r3\n"
				"    mov r0.w, c4.w\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:5\n"
				"//oi:3:trianglesA\n"
				"//s:4:verticesinf\n"
				"//c:3:volumeTriangles\n"
				"//c:1:curgather\n"
				"//c:1:nextgather\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_ps20 = &__processTrianglesNoCompactOneOut_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1 -DCGC=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_verticesinf : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.curgather : TEXUNIT2\n"
				"#semantic main.__gatherconst_curgather : C2\n"
				"#semantic main.nextgather : TEXUNIT3\n"
				"#semantic main.__gatherconst_nextgather : C3\n"
				"#semantic main.__workspace : C4\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT _tex_verticesinf : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var samplerRECT curgather[0] : TEXUNIT2 : texunit 2 : 7 : 1\n"
				"#var float4 __gatherconst_curgather : C2 :  : 8 : 1\n"
				"#var samplerRECT nextgather[0] : TEXUNIT3 : texunit 3 : 9 : 1\n"
				"#var float4 __gatherconst_nextgather : C3 :  : 10 : 1\n"
				"#var float4 __workspace : C4 :  : 11 : 1\n"
				"#var float3 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_verticesinf_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __gatherconst_curgather;\n"
				"DECLARE __gatherconst_nextgather;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"SGER H0, R0, {0, 0, 0, 0};\n"
				"SLTR H1, R0, {256, 256, 256, 256};\n"
				"MULX H0, H1, H0;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"SLTR H1.xy, R1.xyxx, {0, 0}.x;\n"
				"MULR R1.xy, R1.xyxx, {0.33333334, 0.2}.xyxx;\n"
				"FRCR R1.xy, |R1.xyxx|;\n"
				"MULR R1.xy, R1.xyxx, {3, 5}.xyxx;\n"
				"MOVR R2.xy, R1.xyxx;\n"
				"MOVXC HC.xy, H1.xyxx;\n"
				"MOVR R2.xy(GT.xyxx), -R1.xyxx;\n"
				"ADDR R2.xy, R2.xyxx, {0.5}.x;\n"
				"FLRR R2.xy, R2.xyxx;\n"
				"ADDR R1.xy, R2.xyxx, {0.5, 0.5}.xyxx;\n"
				"SGTR H1.xy, R1.xyxx, {3, 5}.xyxx;\n"
				"MOVR R1, {0, 0, 0, 0};\n"
				"MOVXC HC, H0;\n"
				"MOVR R1(GT), R0;\n"
				"MOVXC HC.xy, H1.xyxx;\n"
				"MOVR R2.xy(GT.xyxx), {0, 0}.xyxx;\n"
				"MOVR R0.y, R1.w;\n"
				"MADR R0.w, R2.y, {3}.x, R2.x;\n"
				"MOVR R0.x, R0.w;\n"
				"TEX R0.xyz, R0.xyxx, TEX1, RECT;\n"
				"SLTR H0.xyz, R0.xyzx, {256, 256, 256}.xyzx;\n"
				"SEQR H0.w, R0.z, {0}.x;\n"
				"ADDX H1.x, -H0.w, {1}.x;\n"
				"MOVR R2.xyz, {0, 0, 0}.xyzx;\n"
				"MOVXC HC.xyz, H0.xyzx;\n"
				"MOVR R2.xyz(GT.xyzx), R0.xyzx;\n"
				"SEQR H0.xyz, R2.xyzx, {0.5, 0.5, 0.5}.xyzx;\n"
				"SNER H1.y, H0.x, {0}.x;\n"
				"ADDX H1.y, -H1.y, {1}.x;\n"
				"SNER H1.z, H0.z, {0}.x;\n"
				"ADDX H1.w, -H1.z, {1}.x;\n"
				"MULX H1.y, H1.w, H1.y;\n"
				"ADDX H1.w, -H1.z, {1}.x;\n"
				"MULX H0.w, H1.w, H0.w;\n"
				"ADDX H1.z, -H1.z, {1}.x;\n"
				"MULX H1.x, H1.z, H1.x;\n"
				"ADDR R0.w, R1.y, R2.y;\n"
				"ADDR R2.w, R1.y, R2.y;\n"
				"ADDR R3.x, R1.y, {1}.x;\n"
				"MOVR R3.y, R3.x;\n"
				"MOVR R4.y, R2.w;\n"
				"MOVR R5.y, R0.w;\n"
				"MOVR R5.x, R1.x;\n"
				"ADDR R0.w, R1.x, R2.x;\n"
				"ADDR R2.w, R1.x, R2.x;\n"
				"MOVR R3.x, R2.w;\n"
				"ADDR R2.xy, R1.xyxx, R2.xyxx;\n"
				"MOVR R6.y, R1.y;\n"
				"MOVR R6.x, R0.w;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R5.xy(GT.x), R6.xyxx;\n"
				"ADDR R0.w, R1.x, {1}.x;\n"
				"MOVR R4.x, R0.w;\n"
				"MOVXC HC.x, H1.y;\n"
				"MOVR R4.xy(GT.x), R3.xyxx;\n"
				"TEX R3.x, R2.xyxx, TEX2, RECT;\n"
				"TEX R2.x, R2.xyxx, TEX3, RECT;\n"
				"MOVR R0.w, R2.x;\n"
				"MOVR R2.x, R3.x;\n"
				"TEX R3.x, R4.xyxx, TEX2, RECT;\n"
				"TEX R4.x, R4.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR R0.w(GT.x), R3.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R0.w(GT.x), R4.x;\n"
				"TEX R3.x, R5.xyxx, TEX2, RECT;\n"
				"TEX R4.x, R5.xyxx, TEX3, RECT;\n"
				"MOVXC HC.x, H0.w;\n"
				"MOVR R2.x(GT.x), R3.x;\n"
				"MOVXC HC.x, H1.x;\n"
				"MOVR R2.x(GT.x), R4.x;\n"
				"ADDR R0.w, R0.w, -R2.x;\n"
				"RCPR R0.w, R0.w;\n"
				"ADDR R2.x, {0.38999999}.x, -R2.x;\n"
				"MULR R0.w, R2.x, R0.w;\n"
				"MOVXC HC.xyz, H0.xyzx;\n"
				"MOVR R0.xyz(GT.xyzx), R0.w;\n"
				"ADDR o[COLR].xyz, R1.xyzx, R0.xyzx;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##oi:3:trianglesA\n"
				"##s:4:verticesinf\n"
				"##c:3:volumeTriangles\n"
				"##c:1:curgather\n"
				"##c:1:nextgather\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_fp30 = &__processTrianglesNoCompactOneOut_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = program.local[2];\n"
				"PARAM c3 = program.local[3];\n"
				"PARAM c4 = {-256, 1, 0.39, 0};\n"
				"PARAM c5 = {0.333333, 0.2, 0, 0.5};\n"
				"PARAM c6 = {3, 5, 0, -0.5};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.x, t0.x, c0.x, c0.z;\n"
				"MAD r2.y, t0.y, c0.y, c0.w;\n"
				"MUL r9.xy, r2, c5;\n"
				"FRC r4.xy, r9;\n"
				"MUL r11.xy, r4, c6;\n"
				"ADD r6.xy, r11, c5.w;\n"
				"FRC r1.xy, r6;\n"
				"ADD r3.xy, r6, -r1;\n"
				"ADD r10.xy, r3, c5.w;\n"
				"ADD r7.xy, -r10, c6;\n"
				"CMP r2.xy, r7, c4.w, r3;\n"
				"MAD r9.x, r2.y, c6.x, r2.x;\n"
				"ADD r4, r0, c4.x;\n"
				"CMP r11, r4, c4.y, c4.w;\n"
				"CMP r6, r0, c4.w, c4.y;\n"
				"MUL r1, r11, r6;\n"
				"CMP r0, -r1, r0, c4.w;\n"
				"MOV r9.y, r0.w;\n"
				"MAD r10.x, r9.x, c1.x, c1.z;\n"
				"MAD r10.y, r9.y, c1.y, c1.w;\n"
				"TEX r5, r10, texture[1], RECT;\n"
				"ADD r7.xyz, r5, c4.x;\n"
				"CMP r2.xyz, r7, r5, c4.w;\n"
				"ADD r4.xyz, r2, c6.w;\n"
				"ADD r11.xy, r0, r2;\n"
				"ABS r1.xyz, r4;\n"
				"MOV r8.xyz, -r1;\n"
				"MOV r9.xz, r11.x;\n"
				"ADD r11.w, r0.x, c4.y;\n"
				"ADD r9.w, r0.y, c4.y;\n"
				"MOV r11.z, r0.x;\n"
				"MOV r9.y, r0.y;\n"
				"CMP r3.yw, r8.x, r9, r11.y;\n"
				"CMP r3.z, r8.x, r9.z, r11.w;\n"
				"CMP r3.x, r8.x, r9.x, r11.z;\n"
				"MAD r7.x, r3.x, c2.x, c2.z;\n"
				"MAD r7.y, r3.y, c2.y, c2.w;\n"
				"MAD r4.x, r3.z, c2.x, c2.z;\n"
				"MAD r4.y, r3.w, c2.y, c2.w;\n"
				"MAD r1.x, r3.x, c3.x, c3.z;\n"
				"MAD r1.y, r3.y, c3.y, c3.w;\n"
				"MAD r9.x, r3.z, c3.x, c3.z;\n"
				"MAD r9.y, r3.w, c3.y, c3.w;\n"
				"MAD r2.x, r11.x, c2.x, c2.z;\n"
				"MAD r2.y, r11.y, c2.y, c2.w;\n"
				"MAD r3.x, r11.x, c3.x, c3.z;\n"
				"MAD r3.y, r11.y, c3.y, c3.w;\n"
				"TEX r7, r7, texture[2], RECT;\n"
				"TEX r4, r4, texture[2], RECT;\n"
				"TEX r6, r1, texture[3], RECT;\n"
				"TEX r1, r9, texture[3], RECT;\n"
				"TEX r9, r2, texture[2], RECT;\n"
				"TEX r10, r3, texture[3], RECT;\n"
				"MOV r7.y, r4.x;\n"
				"MOV r6.y, r1.x;\n"
				"ABS r8.w, r5.z;\n"
				"CMP r11.xy, -r8.w, r6, r7;\n"
				"MOV r9.y, r10.x;\n"
				"CMP r2.xy, r8.z, r11, r9;\n"
				"ADD r5.w, r2.y, -r2.x;\n"
				"ADD r8.w, -r2.x, c4.z;\n"
				"RCP r5.w, r5.w;\n"
				"MUL r8.w, r8.w, r5.w;\n"
				"CMP r3.xyz, r8, r5, r8.w;\n"
				"ADD r0.xyz, r0, r3;\n"
				"MOV r0.w, c4.w;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##oi:3:trianglesA\n"
				"##s:4:verticesinf\n"
				"##c:3:volumeTriangles\n"
				"##c:1:curgather\n"
				"##c:1:nextgather\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.constant(4, kGatherConstant_Shape)
				.constant(5, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.sampler(4, 0)
				.sampler(5, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_arb = &__processTrianglesNoCompactOneOut_arb_desc;
}

void __processTrianglesNoCompactOneOut_cpu_inner (__BrtFloat3  &trianglesA,
                                                   const __BrtFloat4  &verticesinf,
                                                   const __BrtArray2d<__BrtFloat3  > &volumeTriangles,
                                                   const __BrtArray2d<__BrtFloat1  > &curgather,
                                                   const __BrtArray2d<__BrtFloat1  > &nextgather,
                                                   const __BrtFloat4 &__indexof_trianglesA){
  __BrtFloat1  isovalue = __BrtFloat1(0.390000f);
  __BrtFloat2  threefive = __BrtFloat2(__BrtFloat1(3.000000f), __BrtFloat1(5.000000f));
  __BrtFloat3  onehalf = __BrtFloat1(0.500000f);
  __BrtFloat2  onehalf2 = __BrtFloat1(0.500000f);
  __BrtFloat2  zero2 = __BrtFloat1((float)0);
  __BrtFloat4  four256 = __BrtFloat1((float)256);
  __BrtFloat4  curiso;
  __BrtFloat4  nextiso;
  __BrtFloat4  vertices1 = (verticesinf < four256 && verticesinf >= zero2.swizzle4(maskX, maskX, maskX, maskX)).questioncolon(verticesinf,zero2.swizzle4(maskX, maskX, maskX, maskX));
  __BrtFloat2  whichVolumeTriangle = __BrtFloat2(__BrtFloat1((float)0), vertices1.swizzle1(maskW));
  __BrtFloat3  vertices = vertices1.swizzle3(maskX, maskY, maskZ);
  __BrtFloat2  mod35 = __round_cpu_inner(__fmod_cpu_inner((__indexof_trianglesA).swizzle2(maskX, maskY),threefive));

  mod35 = (mod35 + onehalf2 > threefive).questioncolon(zero2,mod35);
  whichVolumeTriangle.mask1(mod35.swizzle1(maskX) + mod35.swizzle1(maskY) * __BrtFloat1((float)3),maskX);
  {
    __BrtFloat3  configinf = volumeTriangles[whichVolumeTriangle].swizzle3(maskX, maskY, maskZ);
    __BrtFloat3  config = (configinf < four256.swizzle3(maskX, maskX, maskX)).questioncolon(configinf,zero2.swizzle3(maskX, maskX, maskX));
    __BrtFloat1  low;
    __BrtFloat1  high;
    __BrtFloat3  ishalf;
    __BrtFloat3  tmp;

    ishalf = (__BrtFloat3 ) (config) == onehalf;
    if (ishalf.swizzle1(maskZ))
    {
      __BrtFloat2  lhGather = vertices.swizzle2(maskX, maskY) + config.swizzle2(maskX, maskY);

      low = curgather[lhGather];
      high = nextgather[lhGather];
    }

    else
    {
      __BrtFloat2  lowGather;
      __BrtFloat2  highGather;

      if (ishalf.swizzle1(maskX))
      {
        lowGather = __BrtFloat2 (vertices.swizzle1(maskX),vertices.swizzle1(maskY) + config.swizzle1(maskY));
        highGather = __BrtFloat2 (vertices.swizzle1(maskX) + __BrtFloat1(1.000000f),vertices.swizzle1(maskY) + config.swizzle1(maskY));
      }

      else
      {
        lowGather = __BrtFloat2 (vertices.swizzle1(maskX) + config.swizzle1(maskX),vertices.swizzle1(maskY));
        highGather = __BrtFloat2 (vertices.swizzle1(maskX) + config.swizzle1(maskX),vertices.swizzle1(maskY) + __BrtFloat1(1.000000f));
      }

      if (configinf.swizzle1(maskZ) == __BrtFloat1((float)0))
      {
        low = curgather[lowGather];
        high = curgather[highGather];
      }

      else
      {
        low = nextgather[lowGather];
        high = nextgather[highGather];
      }

    }

    tmp = (isovalue - low) / (high - low);
    config = ishalf.questioncolon(tmp,configinf);
    trianglesA = vertices + config;
  }

}
void  __processTrianglesNoCompactOneOut_cpu (const std::vector<void *>&args,
                                             const std::vector<const unsigned int *>&extents,
                                             const std::vector<unsigned int>&dims,
                                             unsigned int mapbegin, 
                                             unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  __BrtArray2d<__BrtFloat1  > arg3(
      (__BrtFloat1  *)args[3], extents[3]);
  __BrtArray2d<__BrtFloat1  > arg4(
      (__BrtFloat1  *)args[4], extents[4]);
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio1 = extents[0][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[0][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __processTrianglesNoCompactOneOut_cpu_inner (
      *arg0,
      *(arg1 + iter1),
      arg2,
      arg3,
      arg4,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[0]);
    }
  }
}

void  processTrianglesNoCompactOneOut (::brook::stream trianglesA,
		::brook::stream verticesinf,
		::brook::stream volumeTriangles,
		::brook::stream curgather,
		::brook::stream nextgather) {
  static const void *__processTrianglesNoCompactOneOut_fp[] = {
     "fp30", __processTrianglesNoCompactOneOut_fp30,
     "arb", __processTrianglesNoCompactOneOut_arb,
     "ps20", __processTrianglesNoCompactOneOut_ps20,
     "cpu", (void *) __processTrianglesNoCompactOneOut_cpu,
     NULL, NULL };
  static __BRTKernel k(__processTrianglesNoCompactOneOut_fp);

  k->PushOutput(trianglesA);
  k->PushStream(verticesinf);
  k->PushGatherStream(volumeTriangles);
  k->PushGatherStream(curgather);
  k->PushGatherStream(nextgather);
  k->Map();

}


/*
 //this one commented out cus it does both wid and hei
namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_ps20_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"    ps_2_0\n"
				"    def c2, 5, -256, 1, 0\n"
				"    def c3, 0.333333, 0.5, 0.2, 3\n"
				"    dcl t0.xy\n"
				"    dcl t1.xy\n"
				"    dcl_2d s0\n"
				"    dcl_2d s1\n"
				"    texld r0, t1, s0\n"
				"    mad r2.x, t0.x, c0.x, c0.z\n"
				"    mad r2.y, t0.y, c0.y, c0.w\n"
				"    mul r2.w, r2.x, c3.x\n"
				"    mul r9.w, r2.y, c3.z\n"
				"    frc r4.w, r2.w\n"
				"    mad r6.w, r4.w, c3.w, c3.y\n"
				"    frc r1.w, r6.w\n"
				"    add r3.w, r6.w, -r1.w\n"
				"    add r10.w, r3.w, c3.y\n"
				"    add r7.w, -r10.w, c3.w\n"
				"    cmp r2.w, r7.w, r3.w, c2.w\n"
				"    frc r9.w, r9.w\n"
				"    mul r4.w, r9.w, c2.x\n"
				"    add r11.w, r4.w, c3.y\n"
				"    add r1.w, -r11.w, c2.x\n"
				"    cmp r8.w, r1.w, r4.w, c2.w\n"
				"    mad r10.x, r8.w, c3.w, r2.w\n"
				"    add r10.w, r0.w, c2.y\n"
				"    cmp_pp r10.w, r10.w, c2.w, c2.z\n"
				"    cmp_pp r5.w, r0.w, c2.z, c2.w\n"
				"    mul_pp r10.w, r10.w, r5.w\n"
				"    cmp r10.y, -r10.w, c2.w, r0.w\n"
				"    mad r2.x, r10.x, c1.x, c1.z\n"
				"    mad r2.y, r10.y, c1.y, c1.w\n"
				"    texld r9, r2, s1\n"
				"    add r0.xyz, r0, r9\n"
				"    mov r0.w, c2.w\n"
				"    mov oC0, r0\n"
				"\n"
				" \n"
				"//!!BRCC\n"
				"//narg:3\n"
				"//oi:3:trianglesA\n"
				"//s:4:vertices1\n"
				"//c:3:volumeTriangles\n"
				"//workspace:1024\n"
				"//!!multipleOutputInfo:0:1:\n"
				"//!!fullAddressTrans:0:\n"
				"//!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_ps20 = &__processTrianglesNoCompactOneOut_ps20_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_fp30_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!FP1.0\n"
				"# NV_fragment_program generated by NVIDIA Cg compiler\n"
				"# cgc version 1.2.0001, build date Jan  5 2004  12:33:41\n"
				"# command line args: -quiet -profile fp30 -DUSERECT=1\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile fp30\n"
				"#program main\n"
				"#semantic main._const_trianglesA_invscalebias : C0\n"
				"#semantic main._tex_vertices1 : TEXUNIT0\n"
				"#semantic main.volumeTriangles : TEXUNIT1\n"
				"#semantic main.__gatherconst_volumeTriangles : C1\n"
				"#semantic main.__workspace : C2\n"
				"#var float4 _const_trianglesA_invscalebias : C0 :  : 1 : 1\n"
				"#var samplerRECT _tex_vertices1 : TEXUNIT0 : texunit 0 : 3 : 1\n"
				"#var samplerRECT volumeTriangles[0] : TEXUNIT1 : texunit 1 : 5 : 1\n"
				"#var float4 __gatherconst_volumeTriangles : C1 :  : 6 : 1\n"
				"#var float4 __workspace : C2 :  : 7 : 1\n"
				"#var float4 __output_0 : $vout.COLOR0 : COL : 0 : 1\n"
				"#var float2 _tex_trianglesA_pos : $vin.TEXCOORD0 : TEX0 : 2 : 1\n"
				"#var float2 _tex_vertices1_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"DECLARE _const_trianglesA_invscalebias;\n"
				"DECLARE __gatherconst_volumeTriangles;\n"
				"DECLARE __workspace;\n"
				"TEX R0, f[TEX1].xyxx, TEX0, RECT;\n"
				"MOVR R1.xy, f[TEX0].xyxx;\n"
				"SLTR H0.x, R1.x, {0}.x;\n"
				"SLTR H0.y, R1.y, {0}.x;\n"
				"MULR R1.w, R1.x, {0.33333334}.x;\n"
				"FRCR R1.w, |R1.w|;\n"
				"MULR R1.w, R1.w, {3}.x;\n"
				"MULR R1.x, R1.y, {0.2}.x;\n"
				"FRCR R1.x, |R1.x|;\n"
				"MULR R1.x, R1.x, {5}.x;\n"
				"MOVR R1.y, R1.w;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), -R1.w;\n"
				"ADDR R1.y, R1.y, {0.5}.x;\n"
				"FLRR R1.y, R1.y;\n"
				"MOVR R2.w, R0;\n"
				"MOVR R2.y, R2.w;\n"
				"MOVR R2.x, R1.y;\n"
				"MOVR R2.zw, {0, 0, 0, 0}.zzzw;\n"
				"SGER H0.x, R2.y, {0}.x;\n"
				"SLTR H0.z, R2.y, {256}.x;\n"
				"MADX H0.x, -H0.z, H0.x, {1}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R2.y(GT.x), {0}.x;\n"
				"MOVR R1.y, R1.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R1.y(GT.x), -R1.x;\n"
				"ADDR R1.x, R1.y, {0.5}.x;\n"
				"SGTR H0.x, R1.x, {5}.x;\n"
				"ADDR R1.x, R2.x, {0.5}.x;\n"
				"SGTR H0.y, R1.x, {3}.x;\n"
				"MOVXC HC.x, H0.x;\n"
				"MOVR R1.y(GT.x), {0}.x;\n"
				"MOVXC HC.x, H0.y;\n"
				"MOVR R2.x(GT.x), {0}.x;\n"
				"MADR R1.y, R1.y, {3}.x, R2.x;\n"
				"MOVR R2.x, R1.y;\n"
				"TEX R1.xyz, R2.xyxx, TEX1, RECT;\n"
				"ADDR o[COLR].xyz, R0.xyzx, R1.xyzx;\n"
				"MOVR o[COLR].w, {0, 0, 0, 0}.w;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##oi:3:trianglesA\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_fp30 = &__processTrianglesNoCompactOneOut_fp30_desc;
}


namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __processTrianglesNoCompactOneOut_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"PARAM c0 = program.local[0];\n"
				"PARAM c1 = program.local[1];\n"
				"PARAM c2 = {5, -256, 1, 0};\n"
				"PARAM c3 = {0.333333, 0.5, 0.2, 3};\n"
				"OUTPUT oC0 = result.color;\n"
				"TEMP r0;\n"
				"TEMP r1;\n"
				"TEMP r10;\n"
				"TEMP r11;\n"
				"TEMP r2;\n"
				"TEMP r3;\n"
				"TEMP r4;\n"
				"TEMP r5;\n"
				"TEMP r6;\n"
				"TEMP r7;\n"
				"TEMP r8;\n"
				"TEMP r9;\n"
				"ATTRIB t0 = fragment.texcoord[0];\n"
				"ATTRIB t1 = fragment.texcoord[1];\n"
				"TEX r0, t1, texture[0], RECT;\n"
				"MAD r2.x, t0.x, c0.x, c0.z;\n"
				"MAD r2.y, t0.y, c0.y, c0.w;\n"
				"MUL r2.w, r2.x, c3.x;\n"
				"MUL r9.w, r2.y, c3.z;\n"
				"FRC r4.w, r2.w;\n"
				"MAD r6.w, r4.w, c3.w, c3.y;\n"
				"FRC r1.w, r6.w;\n"
				"ADD r3.w, r6.w, -r1.w;\n"
				"ADD r10.w, r3.w, c3.y;\n"
				"ADD r7.w, -r10.w, c3.w;\n"
				"CMP r2.w, r7.w, c2.w, r3.w;\n"
				"FRC r9.w, r9.w;\n"
				"MUL r4.w, r9.w, c2.x;\n"
				"ADD r11.w, r4.w, c3.y;\n"
				"ADD r1.w, -r11.w, c2.x;\n"
				"CMP r8.w, r1.w, c2.w, r4.w;\n"
				"MAD r10.x, r8.w, c3.w, r2.w;\n"
				"ADD r10.w, r0.w, c2.y;\n"
				"CMP r10.w, r10.w, c2.z, c2.w;\n"
				"CMP r5.w, r0.w, c2.w, c2.z;\n"
				"MUL r10.w, r10.w, r5.w;\n"
				"CMP r10.y, -r10.w, r0.w, c2.w;\n"
				"MAD r2.x, r10.x, c1.x, c1.z;\n"
				"MAD r2.y, r10.y, c1.y, c1.w;\n"
				"TEX r9, r2, texture[1], RECT;\n"
				"ADD r0.xyz, r0, r9;\n"
				"MOV r0.w, c2.w;\n"
				"MOV oC0, r0;\n"
				"END\n"
				" \n"
				"##!!BRCC\n"
				"##narg:3\n"
				"##oi:3:trianglesA\n"
				"##s:4:vertices1\n"
				"##c:3:volumeTriangles\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(1, kOutputConstant_Indexof)
				.constant(3, kGatherConstant_Shape)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kOutputInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.output(1, 0)
			)
		);
	static const void* __processTrianglesNoCompactOneOut_arb = &__processTrianglesNoCompactOneOut_arb_desc;
}

void __processTrianglesNoCompactOneOut_cpu_inner (__BrtFloat3  &trianglesA,
                                                   const __BrtFloat4  &vertices1,
                                                   const __BrtArray2d<__BrtFloat3  > &volumeTriangles,
                                                   const __BrtFloat4 &__indexof_trianglesA){
  __BrtFloat4  whichVolumeTriangle = __BrtFloat4(__round_cpu_inner(__fmod_cpu_inner((__indexof_trianglesA).swizzle1(maskX),__BrtFloat1((float)3))), vertices1.swizzle1(maskW), __BrtFloat1((float)0), __BrtFloat1((float)0));
  __BrtFloat3  vertices = vertices1.swizzle3(maskX, maskY, maskZ);
  __BrtFloat1  mod5 = __fmod_cpu_inner((__indexof_trianglesA).swizzle1(maskY),__BrtFloat1((float)5));

  if (mod5 + __BrtFloat1(0.500000f) > __BrtFloat1((float)5))
    mod5 = __BrtFloat1((float)0);
  if (!(whichVolumeTriangle.swizzle1(maskY) < __BrtFloat1((float)256) && whichVolumeTriangle.swizzle1(maskY) >= __BrtFloat1((float)0)))
    whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskY);
  if (whichVolumeTriangle.swizzle1(maskX) + __BrtFloat1(0.500000f) > __BrtFloat1((float)3))
    whichVolumeTriangle.mask1(__BrtFloat1((float)0),maskX);
  whichVolumeTriangle.mask1(whichVolumeTriangle.swizzle1(maskX) + mod5 * __BrtFloat1((float)3),maskX);
  trianglesA = vertices.swizzle3(maskX, maskY, maskZ) + volumeTriangles[whichVolumeTriangle];
}
void  __processTrianglesNoCompactOneOut_cpu (const std::vector<void *>&args,
                                             const std::vector<const unsigned int *>&extents,
                                             const std::vector<unsigned int>&dims,
                                             unsigned int mapbegin, 
                                             unsigned int mapextent) {
  __BrtFloat3 *arg0 = (__BrtFloat3 *)args[0];
  __BrtFloat4 *arg1 = (__BrtFloat4 *)args[1];
  __BrtArray2d<__BrtFloat3  > arg2(
      (__BrtFloat3  *)args[2], extents[2]);
  unsigned int dim=dims[0];
  unsigned int newline=extents[0][dim-1];
  arg0+=mapbegin;
  unsigned int ratio1 = extents[0][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[0][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[0]);
  ;
__BrtFloat4 indexof0 = computeIndexOf(mapbegin, extents[0], dims[0], extents[0]);
  unsigned int i=0; 
  while (i<mapextent) {
    __processTrianglesNoCompactOneOut_cpu_inner (
      *arg0,
      *(arg1 + iter1),
      arg2,
      indexof0);
    i++;
    ++arg0;
indexof0.unsafeGetAt(0)++;
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if ((mapbegin+i)%newline==0) {
      indexof0 = computeReferenceIndexOf(i+mapbegin, extents[0],dim);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[0]);
    }
  }
}

void  processTrianglesNoCompactOneOut (::brook::stream trianglesA,
		::brook::stream vertices1,
		::brook::stream volumeTriangles) {
  static const void *__processTrianglesNoCompactOneOut_fp[] = {
     "fp30", __processTrianglesNoCompactOneOut_fp30,
     "arb", __processTrianglesNoCompactOneOut_arb,
     "ps20", __processTrianglesNoCompactOneOut_ps20,
     "cpu", (void *) __processTrianglesNoCompactOneOut_cpu,
     NULL, NULL };
  static __BRTKernel k(__processTrianglesNoCompactOneOut_fp);

  k->PushOutput(trianglesA);
  k->PushStream(vertices1);
  k->PushGatherStream(volumeTriangles);
  k->Map();

}

*/
