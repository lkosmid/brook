//all matrices stored in row major order
//[Rotationx.x Rotationx.y Rotationx.z] [Vec.x]
//[Rotationy.x Rotationy.y Rotationy.z] [Vec.y]
//[Rotationz.x Rotationz.y Rotationz.z] [Vec.z]
// Rotation * Vec is
// float3 (dot(Rotationx,Vec),dot(Rotationy,Vec),dot(Rotationz,Vec));
typedef struct traverser_t {
  float4 index;//.xy is index into the aTree  .zw is index into bTree
  float3 Translation; 
  float3 Rotationx;
  float3 Rotationy;
}Traverser;

typedef struct transposedbbox_t{
  float3 transp_rotx;
  float3 transp_roty;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float4 Radius; // if it's a leaf Radius.w is 1 else Radius.w = 0

  // if leaf, the Children.xy is an index to the Triangle
  // if node, the Children.xy is an index to left child
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float2 Children;  
}TransposedBBox;


typedef struct bbox_t{
  float3 Rotationx;
  float3 Rotationy;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float4 Radius;// if it's a leaf Radius.w is 1 else Radius.w = 0

  // if leaf, the Children.xy is an index to the Triangle
  // if node, the Children.xy is an index to left child
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float2 Children;  
}BBox;


typedef struct tri_t {
  float3 A;
  float3 B;
  float3 C;
} Tri;

kernel float modTwo(float who) {
  float tmp = fmod(who,2.0);
  return (tmp>.5&&tmp<1.5)?1.0:0.0;
}
kernel void getMatrixTranspose(float3 rX<>, float3 rY<>, float3 rZ <>,
                               out float3 oX<>, out float3 oY<>, out float3 oZ<>) {
  oX.x=rX.x;
  oX.y=rY.x;
  oX.z=rZ.x;
  oY.x=rX.y;
  oY.y=rY.y;
  oY.z=rZ.y;
  oZ.x=rX.z;
  oZ.y=rY.z;
  oZ.z=rZ.z;
}
kernel void matMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                    float3 bX<>, float3 bY<>, float3 bZ<>,
                    out float3 oX<>, out float3 oY<>) {
  float3 t_bX,t_bY,t_bZ;
  getMatrixTranspose(bX,bY,bZ,t_bX,t_bY,t_bZ);
  oX = float3(dot(aX,t_bX), dot(aX,t_bY), dot(aX,t_bZ));
  oY = float3(dot(aY,t_bX), dot(aY,t_bY), dot(aY,t_bZ));
}
kernel float3 matVecMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                         float3 v<>) {
  float3 temp;
  return temp=float3(dot(v,aX),
                     dot(v,aY),
                     dot(v,aZ));
}

kernel void ISECT(float3 VV<>, float3 D, out float2 isect<>) {
  isect =float2(VV[0] + (VV[1]-VV[0])*D[0]/(D[0]-D[1]),
                VV[1] + (VV[2]-VV[0])*D[0]/(D[0]-D[2]));
}
kernel float COMPUTE_INTERVALS (float3 VV<>,
                                float3 D<>,
                                float DOD1<>, float DOD2<>,
                                out float2 isect<>) {
  float ret = 1;
  float pred;
  float3 VVord;
  float3 Dord;
  pred= (float)(ret&&DOD1>0.0f);
  
  VVord = VV.zxy; 
  Dord = D.zxy;  
  ret=pred?0:ret;
  pred = (float)(ret&&DOD2>0.0f);
  VVord = pred?VV.yxz:VVord; Dord = pred?D.yxz:Dord;
  ret=pred?0:ret;
  
  pred=(float) (ret&&(D[1] * D[2] > 0.0f || D[0] != 0.0f));
  VVord = pred?VV:VVord; Dord=  pred?D:Dord;
  ret=pred?0:ret;
  
  pred= (float)(ret&&D[1]!=0.0f);
  VVord = pred?VV.yxz:VVord; Dord = pred?D.yxz:Dord;
  ret=pred?0:ret;
  
  pred=  (float)(ret&&D[2]!=0.0f);
  VVord = pred?VV.zxy:VVord; Dord = pred?D.zxy:Dord;
  ret=pred?0:ret;
  ISECT(VVord,Dord,isect);
  return ret;
}
kernel float2 sort2(float2 input) {
  return (input.x>input.y)?input.yx:input;
}
kernel float coplanar_tri_tri(float3 N<>,
                              float3 V0<>,float3 V1<>,float3 V2<>,
                              float3 U0<>,float3 U1<>,float3 U2<>) {
  return 0;
}
kernel float3 make_float3 (float a, float b, float c) {
  float3 temp={a,b,c};
  return temp;
}
kernel float tri_contact(float3 V0<>, float3 V1<>, float3 V2<>,
                         float3 U0<>, float3 U1<>, float3 U2<>) {

  float3 E1,E2;
  float3 N1,N2;
  float d1,d2;
  float3 du;
  float3 dv;
  float3 D;
  float2 isect1;
  float2 isect2;
  float du0du1;
  float du0du2;
  float dv0dv1;
  float dv0dv2;
  float index;
  float3 vp;
  float3 up;
  float EPSILON=.000001;
  float b,c,max;
  float ret,coplanar;
  float b_biggest,c_biggest;
  E1 = V1-V0;
  E2 = V2-V0;
  N1 = cross(E1,E2);
  d1 = -dot(N1,V0);
  du = float3(dot(N1,U0)+d1,
              dot(N1,U1)+d1,
              dot(N1,U2)+d1);
  du=du*(float3)(abs(du)>=EPSILON);
  du0du1 = du[0] *du[1];
  du0du2 = du[0] *du[2];
  
  ret= (float) (du0du1<= 0.0f||du0du2<= 0.0f);
  E1 = U1-U0;
  E2 = U2-U0;
  N2 = cross(E1,E2);
  d2 = -dot(N2,U0);
  dv = float3(dot(N2,V0)+d2,
              dot(N2,V1)+d2,
              dot(N2,V2)+d2);
  dv *= (float3)(abs(dv)>=EPSILON);
  dv0dv1 = dv[0]*dv[1];
  dv0dv2 = dv[0]*dv[2];
  ret= (float)(ret&&(dv0dv1<= 0.0f || dv0dv2 <=0.0f));
      
  D = cross(N2,N1);
  // compute and index to the largest component of D 
  max = abs  (D [0]);
  index = 0;
  vp=float3(V0.x,V1.x,V2.x);
  up=float3(U0.x,U1.x,U2.x);
  b = abs  (D [1]);
  c = abs  (D [2]);
  b_biggest = (float)(b>max&&!(c>b));
  c_biggest = (float)(c>max);
  vp  = ((float3)b_biggest)? make_float3(V0.y,V1.y,V2.y)
                          : (((float3)c_biggest) ? make_float3(V0.z,V1.z,V2.z)
                                                 : vp);
  up  = ((float3)b_biggest)? make_float3(U0.y,U1.y,U2.y)
                          : (((float3)c_biggest) ? make_float3(U0.z,U1.z,U2.z)
                                                : up);

    
  max = b_biggest? b : (c_biggest?c:max);
 
  // this is the simplified projection onto L
  // compute interval for triangle 1 
  coplanar= (float)(COMPUTE_INTERVALS (vp,dv,dv0dv1,dv0dv2,isect1)
                    ||COMPUTE_INTERVALS (up,du,du0du1,du0du2,isect2));
  ret= (ret&&coplanar)?coplanar_tri_tri (N1, V0,V1,V2, U0,U1,U2):ret;
  // compute interval for triangle 2
  isect1 = sort2 (isect1);
  isect2 = sort2 (isect2);
    
  ret= (ret&&!coplanar)?(float) !(isect1 [1] < isect2 [0] || isect2 [1] < isect1 [0]):ret;    
  
  return ret;
}


kernel float TrianglesHaveContact (float3 mRx,
                                   float3 mRy,
                                   float3 mRz,
                                   float3 mT,
                                   Tri t1<>, 
                                   Tri t2<>) {
  float3 i1 = matVecMult(mRx,mRy,mRz,t1.A)+mT;
  float3 i2 = matVecMult(mRx,mRy,mRz,t1.B)+mT;
  float3 i3 = matVecMult(mRx,mRy,mRz,t1.C)+mT;
  return tri_contact(i1,i2,i3,t2.A,t2.B,t2.C);

}
kernel float obb_disjoint (float3 Bx<>,
                           float3 By<>,
                           float3 Bz<>,
                           float3 T,
                           float3 a,
                           float3 b) {
  
  return 1;
}


kernel void CheckTriangleCollide(float3 mRx,
                                 float3 mRy,
                                 float3 mRz,
                                 float3 mT,
                                 float4 collisions<>,
                                 Tri t1List[][],
                                 Tri t2List[][],
                                 vout [1] float4 hits<>) {
  Tri t1 = t1List[collisions.xy];
  Tri t2 = t2List[collisions.zw];
  if (TrianglesHaveContact(mRx,mRy,mRz,mT,
                           t1,t2)) {
    hits= collisions;
    push(hits);
  }
}
kernel float GetBBSize (float3 Radius ) {
  return Radius.x;
}
kernel void Collide (float3 mRx,
                     float3 mRy,
                     float3 mRz,
                     float3 mT,
                     Traverser currentNode<>,
                     TransposedBBox b1Tree[][], 
                     BBox b2Tree[][], 
                     vout [1]float4 nextNode<>,//xy is parent yz is first of two childs
                                               //additionally if it's <0 then it's -b-1
                     vout [1]float4 collisions<>//index into triangle list
                     ) {
  //push nextNode if currentNode has collision
  TransposedBBox b1=b1Tree[currentNode.index.xy];
  BBox b2=b2Tree[currentNode.index.xy];
  if (!obb_disjoint(currentNode.Rotationx,
                    currentNode.Rotationy,
                    cross (currentNode.Rotationx,
                           currentNode.Rotationy),
                    currentNode.Translation,
                    b1.Radius.xyz,
                    b2.Radius.xyz)) {
    if (b1.Radius.w!=0 && b2.Radius.w!=0) {
      // it's a leaf node yo
      // check ye olde triangles
      collisions.xy = b1.Children;
      collisions.zw = b2.Children;
      push(collisions);
    }else {
      nextNode.xy = (indexof currentNode).xy;
      if (b1.Radius.w!=0 
          || (b1.Radius.w==0 && (GetBBSize(b1.Radius.xyz)
                                 >
                                 GetBBSize(b2.Radius.xyz)))) {
        nextNode.zw = b1.Children;       
      }else {
        nextNode.zw = -b2.Children-1;
      }
      push(nextNode);
    }
  }
}
                       
                       
kernel void updateCurrentNode(float4 curNodeIndices<>,
                              TransposedBBox aTree[][],
                              BBox bTree[][],
                              Traverser nodes[][],
                              out Traverser nextNode<>) {
  float leftOrRightChild = modTwo((indexof nextNode).x);
  Traverser lastNode = nodes[curNodeIndices.xy];
  float2 aTreeIndex = (curNodeIndices.z>=0)
                        ?curNodeIndices.zw+leftOrRightChild
                        :lastNode.index.xy;
  float2 bTreeIndex = (curNodeIndices.z>=0)
                         ?lastNode.index.zw
                         :-curNodeIndices.zw-1+leftOrRightChild;
  float3 lastNodeRotationz = cross(lastNode.Rotationx,
                                   lastNode.Rotationy);
  if (curNodeIndices.z>=0) {
    TransposedBBox a =aTree[aTreeIndex];
    /*
    float3 rot_transpX;
    float3 rot_transpY;
    float3 rot_transpZ;
    float3 aRotationz = cross(a.Rotationx,a.Rotationy);
    getMatrixTranspose (a.Rotationx,
                        a.Rotationy,
                        aRotationz,
                        rot_transpX,rot_transpY,rot_transpZ);    
    */
    float3 atransp_rotz = cross(a.transp_rotx,a.transp_roty);
    matMult(//rot_transpX,rot_transpY,rot_transpZ,
            a.transp_rotx,a.transp_roty,atransp_rotz,
            lastNode.Rotationx,lastNode.Rotationy,lastNodeRotationz,
            nextNode.Rotationx,nextNode.Rotationy);
            
    nextNode.Translation=matVecMult(//rot_transpX,rot_transpY,rot_transpZ,
                                    a.transp_rotx,a.transp_roty,atransp_rotz,
                                    lastNode.Translation-a.Translation);
  }else {
    BBox b =bTree[bTreeIndex];
    float3 bRotationz = cross(b.Rotationx,b.Rotationy);
    matMult(lastNode.Rotationx,
            lastNode.Rotationy,
            lastNodeRotationz,
            b.Rotationx,
            b.Rotationy,
            bRotationz,
            nextNode.Rotationx,
            nextNode.Rotationy);            
    nextNode.Translation=lastNode.Translation+matVecMult(lastNode.Rotationx,
                                                         lastNode.Rotationy,
                                                         lastNodeRotationz,
                                                         b.Translation);
    
  }
  nextNode.index=float4 (aTreeIndex.x,aTreeIndex.y,bTreeIndex.x,bTreeIndex.y);

}




int main(int argc , char * argv[] ) {
  void * blah = malloc (65536);
  float4 curNodeIndices<1,1>;
  BBox aTree<1,1>;
  BBox bTree<1,1>;
  Traverser nodes<1,1>;
  Traverser nextNode<1,1>;
  memset(blah,0,65536);
  
  updateCurrentNode(curNodeIndices,
                    aTree,
                    bTree,
                    nodes,
                    nextNode);
  
  return 0;
}
kernel void SimpleCheckTriangleCollide(float3 mRx,
                                       float3 mRy,
                                       float3 mRz,
                                       float3 mT,
                                       float4 collisions<>,
                                       Tri t1List[][],
                                       Tri t2List[][],
                                       out float4 hits<>) {
  Tri t1 = t1List[collisions.xy];
  Tri t2 = t2List[collisions.zw];
  float4 neg1=-1;
  hits= TrianglesHaveContact(mRx,mRy,mRz,mT,
                             t1,t2)?collisions:neg1;
}

kernel void test (float3 mRx,
                                   float3 mRy,
                                   float3 mRz,
                                   float3 mT,
                                   Tri t1<>, 
                                   Tri t2<>, out float blah<>) {
  float3 i1 = matVecMult(mRx,mRy,mRz,t1.A)+mT;
  float3 i2 = matVecMult(mRx,mRy,mRz,t1.B)+mT;
  float3 i3 = matVecMult(mRx,mRy,mRz,t1.C)+mT;
  blah= tri_contact(i1,i2,i3,t2.A,t2.B,t2.C);

}

