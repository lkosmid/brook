//all matrices stored in row major order
//[Rotationx.x Rotationx.y Rotationx.z] [Vec.x]
//[Rotationy.x Rotationy.y Rotationy.z] [Vec.y]
//[Rotationz.x Rotationz.y Rotationz.z] [Vec.z]
// Rotation * Vec is
// float3 (dot(Rotationx,Vec),dot(Rotationy,Vec),dot(Rotationz,Vec));
typedef struct traverser_t {
  float3 Rotationx;
  float3 Rotationy;
  float3 Translation;
  float4 index;//.xy is index into the aTree  .zw is index into bTree
  
}Traverser;

typedef struct transposedbbox_t{
  float3 transp_rotx;
  float3 transp_roty;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float3 Radius;

  // if leaf, the Children.xy is an index to the Triangle Children.zw is{-1,-1}
  // if node, the Children.xy is an index to left child .zw is right
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float4 Children;  
}TransposedBBox;


typedef struct bbox_t{
  float3 Rotationx;
  float3 Rotationy;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float3 Radius;

  // if leaf, the Children.xy is an index to the Triangle Children.zw is{-1,-1}
  // if node, the Children.xy is an index to left child .zw is right
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float4 Children;  
}BBox;


typedef struct tri_t {
  float3 A;
  float3 B;
  float3 C;
} Tri;

kernel float TrianglesHaveContact (float3 mRx,
                                   float3 mRy,
                                   float3 mRz,
                                   float3 mT,
                                   Tri a<>, 
                                   Tri b<>) {
  return 1;
}
kernel float obb_disjoint (float3 Bx<>,
                           float3 By<>,
                           float3 Bz<>,
                           float3 T,
                           float3 a,
                           float3 b) {
  return 1;
}
kernel float isLeaf(BBox a<>) {
  return a.Children.z==-1;
}
kernel float isLeafT(TransposedBBox a<>) {
  return a.Children.z==-1;
}

kernel float modTwo(float who) {
  float tmp = fmod(who,2.0);
  return (tmp>.5&&tmp<1.5)?1.0:0.0;
}
kernel void getMatrixTranspose(float3 rX<>, float3 rY<>, float3 rZ <>,
                               out float3 oX<>, out float3 oY<>, out float3 oZ<>) {
  oX.x=rX.x;
  oX.y=rY.x;
  oX.z=rZ.x;
  oY.x=rX.y;
  oY.y=rY.y;
  oY.z=rZ.y;
  oZ.x=rX.z;
  oZ.y=rY.z;
  oZ.z=rZ.z;
}
kernel void matMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                    float3 bX<>, float3 bY<>, float3 bZ<>,
                    out float3 oX<>, out float3 oY<>) {
  float3 t_bX,t_bY,t_bZ;
  getMatrixTranspose(bX,bY,bZ,t_bX,t_bY,t_bZ);
  oX = float3(dot(aX,t_bX), dot(aX,t_bY), dot(aX,t_bZ));
  oY = float3(dot(aY,t_bX), dot(aY,t_bY), dot(aY,t_bZ));
}
kernel float3 matVecMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                         float3 vec<>) {
  float3 temp;
  return temp=float3(dot(vec,aX),
                     dot(vec,aY),
                     dot(vec,aZ));
}
                       
                       
kernel void updateCurrentNode(float4 curNodeIndices<>,
                              TransposedBBox aTree[][],
                              BBox bTree[][],
                              Traverser nodes[][],
                              out Traverser nextNode<>) {
  float leftOrRightChild = modTwo((indexof nextNode).x);
  Traverser lastNode = nodes[curNodeIndices.xy];
  float2 aTreeIndex = (curNodeIndices.z>=0)
                        ?curNodeIndices.zw+leftOrRightChild
                        :lastNode.index.xy;
  float2 bTreeIndex = (curNodeIndices.z>=0)
                         ?lastNode.index.zw
                         :-curNodeIndices.zw-1+leftOrRightChild;
  float3 lastNodeRotationz = cross(lastNode.Rotationx,
                                   lastNode.Rotationy);
  if (curNodeIndices.z>=0) {
    TransposedBBox a =aTree[aTreeIndex];
    /*
    float3 rot_transpX;
    float3 rot_transpY;
    float3 rot_transpZ;
    float3 aRotationz = cross(a.Rotationx,a.Rotationy);
    getMatrixTranspose (a.Rotationx,
                        a.Rotationy,
                        aRotationz,
                        rot_transpX,rot_transpY,rot_transpZ);    
    */
    float3 atransp_rotz = cross(a.transp_rotx,a.transp_roty);
    matMult(//rot_transpX,rot_transpY,rot_transpZ,
            a.transp_rotx,a.transp_roty,atransp_rotz,
            lastNode.Rotationx,lastNode.Rotationy,lastNodeRotationz,
            nextNode.Rotationx,nextNode.Rotationy);
            
    nextNode.Translation=matVecMult(//rot_transpX,rot_transpY,rot_transpZ,
                                    a.transp_rotx,a.transp_roty,atransp_rotz,
                                    lastNode.Translation-a.Translation);
  }else {
    BBox b =bTree[bTreeIndex];
    float3 bRotationz = cross(b.Rotationx,b.Rotationy);
    matMult(lastNode.Rotationx,
            lastNode.Rotationy,
            lastNodeRotationz,
            b.Rotationx,
            b.Rotationy,
            bRotationz,
            nextNode.Rotationx,
            nextNode.Rotationy);            
    nextNode.Translation=lastNode.Translation+matVecMult(lastNode.Rotationx,
                                                         lastNode.Rotationy,
                                                         lastNodeRotationz,
                                                         b.Translation);
    
  }
  nextNode.index=float4 (aTreeIndex.x,aTreeIndex.y,bTreeIndex.x,bTreeIndex.y);

}

kernel void Collide (float3 mRx,
                     float3 mRy,
                     float3 mRz,
                     float3 mT,
                     Traverser currentNode<>,
                     BBox a[][], 
                     BBox b[][], 
                     vout [1]float4 nextNode<>//xy is parent yz is first of two childs
                                               //additionally if it's <0 then it's -b-1
                     ) {
  //push nextNode if currentNode has collision
  
}



int main(int argc , char * argv[] ) {
  
  return 0;
}
