//all matrices stored in row major order
//[Rotationx.x Rotationx.y Rotationx.z] [Vec.x]
//[Rotationy.x Rotationy.y Rotationy.z] [Vec.y]
//[Rotationz.x Rotationz.y Rotationz.z] [Vec.z]
// Rotation * Vec is
// float3 (dot(Rotationx,Vec),dot(Rotationy,Vec),dot(Rotationz,Vec));
typedef struct traverser_t {
  float4 index;//.xy is index into the aTree  .zw is index into bTree
  float3 Translation; 
  float3 Rotationx;
  float3 Rotationy;
}Traverser;

typedef struct transposedbbox_t{
  float3 transp_rotx;
  float3 transp_roty;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float4 Radius; // if it's a leaf Radius.w is 1 else Radius.w = 0

  // if leaf, the Children.xy is an index to the Triangle
  // if node, the Children.xy is an index to left child
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float2 Children;  
}TransposedBBox;


typedef struct bbox_t{
  float3 Rotationx;
  float3 Rotationy;
  // float3 mRotationz  // since Rotationx and Rotationy are orthogonal
  /// cross(Rotationx,Rotationy);
  float3 Translation;
  float4 Radius;// if it's a leaf Radius.w is 1 else Radius.w = 0

  // if leaf, the Children.xy is an index to the Triangle
  // if node, the Children.xy is an index to left child
  // assert right.xy is always left + {1,0} this may require gaps in the tree
  float2 Children;  
}BBox;


typedef struct tri_t {
  float3 A;
  float3 B;
  float3 C;
} Tri;

kernel float modTwo(float who) {
  float tmp = fmod(who,2.0);
  return (tmp>.5&&tmp<1.5)?1.0:0.0;
}
kernel void getMatrixTranspose(float3 rX<>, float3 rY<>, float3 rZ <>,
                               out float3 oX<>, out float3 oY<>, out float3 oZ<>) {
   oX=float3(rX.x,
             rY.x,
             rZ.x);
   oY=float3(rX.y,
             rY.y,
             rZ.y);
   oZ=float3(rX.z,
             rY.z,
             rZ.z);
}
kernel void matMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                    float3 bX<>, float3 bY<>, float3 bZ<>,
                    out float3 oX<>, out float3 oY<>) {
  float3 t_bX,t_bY,t_bZ;
  getMatrixTranspose(bX,bY,bZ,t_bX,t_bY,t_bZ);
  oX = float3(dot(aX,t_bX), dot(aX,t_bY), dot(aX,t_bZ));
  oY = float3(dot(aY,t_bX), dot(aY,t_bY), dot(aY,t_bZ));
}
kernel float3 matVecMult(float3 aX<>, float3 aY<>, float3 aZ<>,
                         float3 v<>) {
  float3 temp;
  return temp=float3(dot(v,aX),
                     dot(v,aY),
                     dot(v,aZ));
}

kernel void ISECT(float3 VV<>, float3 D, out float2 isect<>) {
  isect =float2(VV.x + (VV.y-VV.x)*D.x/(D.x-D.y),
                VV.y + (VV.z-VV.x)*D.x/(D.x-D.z));
}
kernel float COMPUTE_INTERVALS (float3 VV<>,
                                float3 D<>,
                                float DOD1<>, float DOD2<>,
                                out float2 isect<>) {
  float pred;
  float3 VVord = VV.zxy;
  float3 Dord = D.zxy;
  float ret = DOD1>0.0f?0:1.0f;
  pred = (float)(ret&&DOD2>0.0f);
  VVord = pred?VV.yxz:VVord; Dord = pred?D.yxz:Dord;
  ret=pred?0:ret;
  
  pred=(float) (ret&&(D.y * D.z > 0.0f || D.x != 0.0f));
  VVord = pred?VV:VVord; Dord=  pred?D:Dord;
  ret=pred?0:ret;
  
  pred= (float)(ret&&D.y!=0.0f);
  VVord = pred?VV.yxz:VVord; Dord = pred?D.yxz:Dord;
  ret=pred?0:ret;
  
  pred=  (float)(ret&&D.z!=0.0f);
  VVord = pred?VV.zxy:VVord; Dord = pred?D.zxy:Dord;
  ret=pred?0:ret;
  ISECT(VVord,Dord,isect);
  return ret;
}
kernel float2 sort2(float2 input) {
  return (input.x>input.y)?input.yx:input;
}
kernel float coplanar_tri_tri(float3 N<>,
                              float3 V0<>,float3 V1<>,float3 V2<>,
                              float3 U0<>,float3 U1<>,float3 U2<>) {
  return 0;
}
kernel float3 make_float3 (float a, float b, float c) {
  float3 temp={a,b,c};
  return temp;
}
kernel float tri_contact(float3 V0<>, float3 V1<>, float3 V2<>,
                         float3 U0<>, float3 U1<>, float3 U2<>) {

  float3 E1,E2;
  float3 N1,N2;
  float d1,d2;
  float3 du;
  float3 dv;
  float3 D;
  float2 isect1;
  float2 isect2;
  float du0du1;
  float du0du2;
  float dv0dv1;
  float dv0dv2;
  float3 vp;
  float3 up;
  float EPSILON=.000001;
  float b,c,max;
  float ret,coplanar;
  float b_biggest,c_biggest;
  E1 = V1-V0;
  E2 = V2-V0;
  N1 = cross(E1,E2);
  d1 = -dot(N1,V0);
  du = float3(dot(N1,U0)+d1,
              dot(N1,U1)+d1,
              dot(N1,U2)+d1);
  du=du*(float3)(abs(du)>=EPSILON);
  du0du1 = du.x *du.y;
  du0du2 = du.x *du.z;
  
  ret= (float) (du0du1<= 0.0f||du0du2<= 0.0f);
  E1 = U1-U0;
  E2 = U2-U0;
  N2 = cross(E1,E2);
  d2 = -dot(N2,U0);
  dv = float3(dot(N2,V0)+d2,
              dot(N2,V1)+d2,
              dot(N2,V2)+d2);
  dv *= (float3)(abs(dv)>=EPSILON);
  dv0dv1 = dv.x*dv.y;
  dv0dv2 = dv.x*dv.z;
  ret= (float)(ret&&(dv0dv1<= 0.0f || dv0dv2 <=0.0f));
      
  D = cross(N2,N1);
  // compute and index to the largest component of D 
  max = abs  (D .x);
  vp=float3(V0.x,V1.x,V2.x);
  up=float3(U0.x,U1.x,U2.x);
  b = abs  (D .y);
  c = abs  (D .z);
  b_biggest = (float)(b>max&&!(c>b));
  c_biggest = (float)(c>max);
  vp  = ((float3)b_biggest)? make_float3(V0.y,V1.y,V2.y)
                          : (((float3)c_biggest) ? make_float3(V0.z,V1.z,V2.z)
                                                 : vp);
  up  = ((float3)b_biggest)? make_float3(U0.y,U1.y,U2.y)
                          : (((float3)c_biggest) ? make_float3(U0.z,U1.z,U2.z)
                                                : up);

    
  max = b_biggest? b : (c_biggest?c:max);
 
  // this is the simplified projection onto L
  // compute interval for triangle 1 
  coplanar= (float)(COMPUTE_INTERVALS (vp,dv,dv0dv1,dv0dv2,isect1)
                    ||COMPUTE_INTERVALS (up,du,du0du1,du0du2,isect2));
  ret= (ret&&coplanar)?coplanar_tri_tri (N1, V0,V1,V2, U0,U1,U2):ret;
  // compute interval for triangle 2
  isect1 = sort2 (isect1);
  isect2 = sort2 (isect2);
    
  ret= (ret&&!coplanar)?(float) !(isect1 .y < isect2 .x || isect2 .y < isect1 .x):ret;    
  
  return ret;
}


kernel float TrianglesHaveContact (float3 mRx,
                                   float3 mRy,
                                   float3 mRz,
                                   float3 mT,
                                   Tri t1<>, 
                                   Tri t2<>) {
  float3 i1 = matVecMult(mRx,mRy,mRz,t1.A)+mT;
  float3 i2 = matVecMult(mRx,mRy,mRz,t1.B)+mT;
  float3 i3 = matVecMult(mRx,mRy,mRz,t1.C)+mT;
  return tri_contact(i1,i2,i3,t2.A,t2.B,t2.C);

}

kernel void SimpleCheckTriangleCollide(float3 mRx,
                                       float3 mRy,
                                       float3 mRz,
                                       float3 mT,
                                       float4 collisions<>,
                                       Tri t1List[][],
                                       Tri t2List[][],
                                       out float4 hits<>) {
  Tri t1 = t1List[collisions.xy];
  Tri t2 = t2List[collisions.zw];
  float4 neg1=-1;
  hits= TrianglesHaveContact(mRx,mRy,mRz,mT,
                             t1,t2)?collisions:neg1;
}
int main (int argc, char ** argv) {
  return 0;
}
