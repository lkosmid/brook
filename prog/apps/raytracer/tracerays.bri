#define POUND   #

POUND include <stdio.h>
POUND include <stdlib.h>

#include "streamTypes.h"


/*
 * krnFloat4Set --
 *
 *      memset() for streams.  Fills an entire float4 stream with the given
 *      constant.
 */

kernel void
krnFloat4Set(float4 c, out float4 dst<>)
{
   dst = c;
}


/*
 * krnGenEyeRays --
 *
 *      This kernel takes the camera parameters, grid dimensions, and an
 *      iterator that goes from 1 to -1 in width and height.  It then
 *      calculates the ray from each position on the 'film' (image) through
 *      the pinhole of the camera.
 *
 *      Note: filmPos goes from 1 to -1 because the image is flipped by
 *      passing through the pinhole and this way the multiplication by -1
 *      is done automagically by the iterator.
 *
 * Returns:
 *      A stream of rays with unit directions corresponding to each of the
 *      pixels in the result.
 */

kernel void
krnGenEyeRays(float3 lookFrom, float3 u, float3 v, float3 w,
              float2 txty, float3 grid_min, float3 grid_max,
              float2 filmPos<>, out Ray ray<>)
{
  float3 t1, t2, tmaxV, tminV;
  float tnear, tfar;
  float2 scale;

  ray.o = lookFrom;
  scale = txty * filmPos;
  ray.d = w + u*scale.x + v*scale.y;

  // XXX Normalize is busted?  Says who?  It seems to work for me. --Jeremy.
  ray.d = ray.d / sqrt(dot(ray.d, ray.d)); // normalize is busted

  ray.tmax = -1;

  t1 = (grid_min - ray.o) / ray.d;
  t2 = (grid_max - ray.o) / ray.d;
  tmaxV = max(t1,t2);
  tminV = min(t1, t2);

  tnear = max(max(tminV.x, tminV.y), max(tminV.x, tminV.z));
  tfar = min(min(tmaxV.x, tmaxV.y), min(tmaxV.x, tmaxV.z));

  // this puts tmax right on the first cell the ray hits in the grid
  // (or it might be in the middle of the first cell if that's where the
  // eye is)
  ray.tmax = (tnear > tfar) ? ray.tmax  :
             (tfar  < 0.0f) ? ray.tmax  :
             (tnear < 0.0f) ? 0.0f : tnear;
}


// This kernel sets up the static and dynamic state for generated
// eye-rays before the rays actually begin to be traced through the
// scene.
kernel void
krnSetupTraversal(Ray ray<>,
                  float3 grid_min, float3 grid_vsize, float3 grid_dim,
                  out TraversalDataDyn travdatdyn<>,
                  out TraversalDataStatic travdatstatic<>,
                  out RayState raystate<>)
{
  float3 temp, curpos;
  float3 minusone, one, zero;

  minusone = float3(-1, -1, -1);
  one = float3(1,1,1);
  zero = float3(0,0,0);

  // should be right where the ray enters the grid (or starts in the
  // grid if the origin is within the grid)
  curpos = ray.o + ray.d*ray.tmax;

  // determine starting voxel
  travdatdyn.voxNo = floor((curpos - grid_min) / grid_vsize);

  //these ? : should be made much smarter...
  travdatdyn.voxNo.x = (travdatdyn.voxNo.x) >= grid_dim.x ?
     travdatdyn.voxNo.x-1 : travdatdyn.voxNo.x;
  travdatdyn.voxNo.y = (travdatdyn.voxNo.y) >= grid_dim.y ?
     travdatdyn.voxNo.y-1 : travdatdyn.voxNo.y;
  travdatdyn.voxNo.z = (travdatdyn.voxNo.z) >= grid_dim.z ?
     travdatdyn.voxNo.z-1 : travdatdyn.voxNo.z;

  // temp is point ray leaves current voxel
  temp.x = (ray.d.x > 0.0f ? (travdatdyn.voxNo.x+1)*grid_vsize.x + grid_min.x :
	    travdatdyn.voxNo.x*grid_vsize.x + grid_min.x);
  temp.y = (ray.d.y > 0.0f ? (travdatdyn.voxNo.y+1)*grid_vsize.y + grid_min.y :
	    travdatdyn.voxNo.y*grid_vsize.y + grid_min.y);
  temp.z = (ray.d.z > 0.0f ? (travdatdyn.voxNo.z+1)*grid_vsize.z + grid_min.z :
	    travdatdyn.voxNo.z*grid_vsize.z + grid_min.z);

  // tmax corresponding end of current voxel
  travdatdyn.tMax = (temp - curpos) / ray.d + ray.tmax;
  travdatdyn.voxToUse = float3(0,0,0); //needed??


  // now set up state that is constant for each ray through the entire
  // ray trace.  static state is precomputed deltaT as we march
  // through the grid, grid step directions, etc.

  // deltaT when moving to next grid cell
  travdatstatic.tDelta = grid_vsize/ray.d;
  travdatstatic.tDelta = ray.d < zero ?
                         -travdatstatic.tDelta : travdatstatic.tDelta;

  // cell index delta to get to next cell (+1 or -1)
  travdatstatic.step = ray.d > zero ? one : minusone;

  // cell index when the ray leaves the grid
  travdatstatic.outNo = ray.d > zero ? grid_dim : minusone;

  // All rays start in the traversal state
  raystate.state = float4(1,0,0,0);
}


// steps a ray in traversal mode into the next grid voxel
kernel void
krnTraverseVoxel(Ray ray<>, TraversalDataStatic travdatstatic<>,
                 TraversalDataDyn travdatdynold<>, RayState oldraystate<>,
                 GridTrilistOffset listoffset[], float3 grid_dim,
                 out TraversalDataDyn travdatdyn<>, out RayState raystate<>)
{
  float3 compmask;
  float minval;
  float offsetaddr;
  float trilistpos;

  if (oldraystate.state.x > 0) {

    //minval = min( min(travdatdynold.tMax.x, travdatdynold.tMax.y),
    //		  min(travdatdynold.tMax.x, travdatdynold.tMax.z) );
    minval = min( min(travdatdynold.tMax.x, travdatdynold.tMax.y), travdatdynold.tMax.z );

    if (minval == travdatdynold.tMax.x)
      compmask = float3(1,0,0);
    else if (minval == travdatdynold.tMax.y)
      compmask = float3(0,1,0);
    else if (minval == travdatdynold.tMax.z)
      compmask = float3(0,0,1);

    if (travdatdynold.voxNo.x == travdatstatic.outNo.x ||
	travdatdynold.voxNo.y == travdatstatic.outNo.y ||
	travdatdynold.voxNo.z == travdatstatic.outNo.z ||
	dot(travdatdynold.tMax, compmask) > 999999) { //should be tmax, but busted now...

      // ray is out of grid, do nothing
      travdatdyn.voxNo = travdatdynold.voxNo;
      travdatdyn.tMax = travdatdynold.tMax;
      travdatdyn.voxToUse = travdatdynold.voxToUse;
      raystate.state = float4(0,0,0,0);
    } else {

      // use linear offset of current voxel to fetch offset into the
      // triangle list The list of triangles located in this voxel starts at
      // this offset in the global triangle list
      offsetaddr = grid_dim.z*(travdatdynold.voxNo.x*grid_dim.y +
                               travdatdynold.voxNo.y) + travdatdynold.voxNo.z;
      trilistpos = listoffset[offsetaddr].listOffset;
      travdatdyn.voxToUse = travdatdynold.voxNo;

      // update dynamic ray state to next voxel
      travdatdyn.voxNo = travdatdynold.voxNo + compmask*travdatstatic.step;
      travdatdyn.tMax = travdatdynold.tMax + compmask*travdatstatic.tDelta;

      if (trilistpos >= 0) {
	raystate.state = float4(0,1,0,trilistpos);   // go into isect state if triangles in this voxel
      } else {
	raystate.state = float4(1,0,0,0); // no triangles, continue stepping
      }
    }
  } else {
    // do nothing, ray not in traversal state
    travdatdyn.voxNo = travdatdynold.voxNo;
    travdatdyn.tMax = travdatdynold.tMax;
    travdatdyn.voxToUse = travdatdynold.voxToUse;
    raystate.state = oldraystate.state;
  }
}


// performs first part of ray-triangle intersection for rays in the
// intersect state (projects ray onto triangle, does not determine if
// projected point lies within triangle, this is done later in
// krnValidateIntersection)
kernel void
krnIntersectTriangle(Ray ray<>, Triangle tris[], RayState oldraystate<>,
                     GridTrilist trilist[], out Hit candidatehit<>)
{
  float idx, det, inv_det;
  float3 edge1, edge2, pvec, tvec, qvec;

  if (oldraystate.state.y > 0) {
    // starting index of triangle list to search is stored in oldraystate.state.w
    // first get a triangle number
    idx = trilist[oldraystate.state.w].triNum;

    edge1 = tris[idx].v1 - tris[idx].v0;
    edge2 = tris[idx].v2 - tris[idx].v0;
    pvec = cross(ray.d, edge2);
    det = dot(edge1, pvec);
    inv_det = 1.0f/det;
    tvec = ray.o - tris[idx].v0;
    candidatehit.data.y = dot( tvec, pvec ) * inv_det;
    qvec = cross( tvec, edge1 );
    candidatehit.data.z = dot( ray.d, qvec ) * inv_det;
    candidatehit.data.x = dot( edge2, qvec ) * inv_det;
    candidatehit.data.w = idx;
  } else {
    candidatehit.data = float4(0,0,0,-1);
  }

}


// determines if a triangle hit computed by krnIntersectTriangle is indeed
// a valid hit.  Valid hits are scheduled for shading
kernel void
krnValidateIntersection(Ray ray<>, Hit candidatehit<>,
                        float3 grid_min, float3 grid_vsize, float3 grid_dim,
                        Hit oldhit<>, TraversalDataDyn travdatdyn<>,
                        RayState oldraystate<>, GridTrilist trilist[],
                        out Hit hit<>, out RayState raystate<>)
{
  float triNum;
  float validhit;
  float3 hitp, myvox;
  float3 fudgeup, fudgedown;

  if (oldraystate.state.y > 0) {

    // checks for valid bary coords u,v and makes sure the hit it before all previously found hits
    validhit = (candidatehit.data.y >= 0.0f && candidatehit.data.z >= 0.0f &&
               (candidatehit.data.y + candidatehit.data.z) <= 1.0f &&
               candidatehit.data.x <= oldhit.data.x &&
               candidatehit.data.x >= 0.0f) ? 1 : 0;


    if (validhit) {
      // fudge .01 to elimate speckles...
      hitp = ray.o + ray.d*(candidatehit.data.x - 0.01f);
      myvox = floor( (hitp - grid_min)/grid_vsize );
      myvox.x = myvox.x >= grid_dim.x ? myvox.x-1 : myvox.x;
      myvox.y = myvox.y >= grid_dim.y ? myvox.y-1 : myvox.y;
      myvox.z = myvox.z >= grid_dim.z ? myvox.z-1 : myvox.z;

      // fudge more since equality is busted...
      fudgeup = travdatdyn.voxToUse + 0.1f;
      fudgedown = travdatdyn.voxToUse - 0.1f;

      // Ensure the intersection with the triangle occurs in the current
      // voxel.  If not, we'll end up finding the hit again later
      validhit = (myvox.x >= fudgedown.x && myvox.x <= fudgeup.x &&
		  myvox.y >= fudgedown.y && myvox.y <= fudgeup.y &&
		  myvox.z >= fudgedown.z && myvox.z <= fudgeup.z) ? validhit : 0;
    }


    if (validhit > 0) {
      hit.data = candidatehit.data;
    } else {
      hit.data = oldhit.data;
    }

    // move on to next triangle, see if we've hit the end of the triangle list
    triNum = trilist[oldraystate.state.w+1].triNum;

    if (triNum < 0) {
      // Have come to end of the triangle list for this voxel
      // If we found a hit, mark the ray for shading
      if (validhit > 0 || oldhit.data.w >= 0) {
	raystate.state = float4(0,0,1,0);
      } else {
	// no hits, return the grid traversal state
	raystate.state = float4(1,0,0,0);
      }
    } else {
      raystate.state = float4(0,1,0,oldraystate.state.w+1);
    }
  } else {
    // not in intersection mode, do nothing
    hit.data = oldhit.data;
    raystate.state = oldraystate.state;
  }

}


kernel void
krnBruteIntersectTriangle(Ray ray<>, Triangle tris[], float idx,
                          Hit oldhit<>,TraversalDataDyn travdatdyn<>,
                          RayState oldraystate<>,
                          out Hit hit<>, out RayState raystate<>)
{
  float det, inv_det;
  float3 edge1, edge2, pvec, tvec, qvec;
  float validhit;
  float4 newhit;  //tt,uu,vv,id

  if (oldraystate.state.y > 0) {
    edge1 = tris[idx].v1 - tris[idx].v0;
    edge2 = tris[idx].v2 - tris[idx].v0;
    pvec = cross(ray.d, edge2);
    det = dot(edge1, pvec);
    inv_det = 1.0f/det;
    tvec = ray.o - tris[idx].v0;
    newhit.y = dot( tvec, pvec ) * inv_det;
    qvec = cross( tvec, edge1 );
    newhit.z = dot( ray.d, qvec ) * inv_det;
    newhit.x = dot( edge2, qvec ) * inv_det;
    newhit.w = idx;

    validhit = (newhit.y >= 0.0f && newhit.z >= 0.0f &&
                (newhit.y + newhit.z) <= 1.0f &&
		newhit.x <= oldhit.data.x && newhit.x >= 0.0f) ? 1 : 0;

    // valid only if in voxel too...

    if (validhit) {
      hit.data = newhit;
    } else {
      hit.data = oldhit.data;
    }

    //only done at end of voxel
    raystate.state = float4(0, 0, 1, oldraystate.state.w+1);
  }
}


// simple unshadowed diffuse shading of surface
kernel void
krnShadeHits(Ray ray<>, Hit hit<>, Triangle tris[],
             ShadingInfo shadinf[], float3 pointlight,
             RayState oldraystate<>, out Pixel pixel<>)
{
  float3 hitpoint, lightdir, barycoord, N, C;
  float NdotL;
  float3 newcolor;

  if (oldraystate.state.z > 0) {
    // Might need to change ordering
    barycoord = float3(hit.data.y, hit.data.z, 1.0f - hit.data.y - hit.data.z);

    N = shadinf[hit.data.w].n0*barycoord.x +
      shadinf[hit.data.w].n1*barycoord.y +
      shadinf[hit.data.w].n2*barycoord.z;

    C = shadinf[hit.data.w].c0*barycoord.x +
      shadinf[hit.data.w].c1*barycoord.y +
      shadinf[hit.data.w].c2*barycoord.z;

    hitpoint = ray.o + ray.d*hit.data.x;

    lightdir = pointlight - hitpoint;
    lightdir = lightdir/sqrt(dot(lightdir, lightdir)); //normalize

    NdotL = max(0,dot(N, lightdir)); //one sided lighting

    newcolor = C*NdotL;

    if (hit.data.w >= 0) {
      pixel.data = float4(newcolor.x, newcolor.y, newcolor.z, 1);
    } else {
      pixel.data = float4(0,1,0,0);  // shade as red if bogus hit surfuce
    }
  } else {
    // no hit
    pixel.data = float4(0,0,0,0);
  }
}
