#define POUND   #

POUND include <stdio.h>
POUND include <stdlib.h>

#include "streamTypes.h"


/*
 * krnFloat4Set --
 *
 *      memset() for streams.  Fills an entire float4 stream with the given
 *      constant.
 */

kernel void
krnFloat4Set(float4 c, out float4 dst<>)
{
   dst = c;
}


/*
 * krnGenEyeRays --
 *
 *      This kernel takes the camera parameters, grid dimensions, and an
 *      iterator that goes from 1 to -1 in width and height.  It then
 *      calculates the ray from each position on the 'film' (image) through
 *      the pinhole of the camera.
 *
 *      Note: filmPos goes from 1 to -1 because the image is flipped by
 *      passing through the pinhole and this way the multiplication by -1
 *      is done automagically by the iterator.
 *
 * Returns:
 *      A stream of rays with unit directions corresponding to each of the
 *      pixels in the result.
 */

kernel void
krnGenEyeRays(float3 lookFrom, float3 u, float3 v, float3 w,
              float2 txty, float3 grid_min, float3 grid_max,
              float2 filmPos<>, out Ray ray<>)
{
  float3 t1, t2, tmaxV, tminV;
  float tnear, tfar;
  float2 scale;

  ray.o = lookFrom;
  scale = txty * filmPos;
  ray.d = w + u*scale.x + v*scale.y;

  // XXX Normalize is busted?  Says who?  It seems to work for me. --Jeremy.
  ray.d = ray.d / sqrt(dot(ray.d, ray.d)); // normalize is busted

  ray.tmax = -1;

  t1 = (grid_min - ray.o) / ray.d;
  t2 = (grid_max - ray.o) / ray.d;
  tmaxV = max(t1,t2);
  tminV = min(t1, t2);

  tnear = max(max(tminV.x, tminV.y), max(tminV.x, tminV.z));
  tfar = min(min(tmaxV.x, tmaxV.y), min(tmaxV.x, tmaxV.z));

  // this puts tmax right on the first cell the ray hits in the grid
  // (or it might be in the middle of the first cell if that's where the
  // eye is)
  ray.tmax = (tnear > tfar) ? ray.tmax  :
             (tfar  < 0.0f) ? ray.tmax  :
             (tnear < 0.0f) ? 0.0f : tnear;
}


// This kernel sets up the static and dynamic state for generated
// eye-rays before the rays actually begin to be traced through the
// scene.
kernel void
krnSetupTraversal(Ray ray<>,
                  float3 grid_min, float3 grid_vsize, float3 grid_dim,
                  out TraversalDataDyn travdatdyn<>,
                  out TraversalDataStatic travdatstatic<>,
                  out RayState raystate<>)
{
  float3 temp, curpos;
  float3 minusone, one, zero;

  minusone = float3(-1, -1, -1);
  one = float3(1,1,1);
  zero = float3(0,0,0);

  // should be right where the ray enters the grid (or starts in the
  // grid if the origin is within the grid)
  curpos = ray.o + ray.d*ray.tmax;

  // determine starting voxel
  travdatdyn.voxNo = floor((curpos - grid_min) / grid_vsize);

  //these ? : should be made much smarter...
  travdatdyn.voxNo.x = (travdatdyn.voxNo.x) >= grid_dim.x ?
     travdatdyn.voxNo.x-1 : travdatdyn.voxNo.x;
  travdatdyn.voxNo.y = (travdatdyn.voxNo.y) >= grid_dim.y ?
     travdatdyn.voxNo.y-1 : travdatdyn.voxNo.y;
  travdatdyn.voxNo.z = (travdatdyn.voxNo.z) >= grid_dim.z ?
     travdatdyn.voxNo.z-1 : travdatdyn.voxNo.z;

  // temp is point ray leaves current voxel
  temp.x = (ray.d.x > 0.0f ? (travdatdyn.voxNo.x+1)*grid_vsize.x + grid_min.x :
	    travdatdyn.voxNo.x*grid_vsize.x + grid_min.x);
  temp.y = (ray.d.y > 0.0f ? (travdatdyn.voxNo.y+1)*grid_vsize.y + grid_min.y :
	    travdatdyn.voxNo.y*grid_vsize.y + grid_min.y);
  temp.z = (ray.d.z > 0.0f ? (travdatdyn.voxNo.z+1)*grid_vsize.z + grid_min.z :
	    travdatdyn.voxNo.z*grid_vsize.z + grid_min.z);

  // tmax corresponding end of current voxel
  travdatdyn.tMax = (temp - curpos) / ray.d + ray.tmax;
  travdatdyn.voxToUse = float3(0,0,0); //needed??


  // now set up state that is constant for each ray through the entire
  // ray trace.  static state is precomputed deltaT as we march
  // through the grid, grid step directions, etc.

  // deltaT when moving to next grid cell
  travdatstatic.tDelta = grid_vsize/ray.d;
  travdatstatic.tDelta = ray.d < zero ?
                         -travdatstatic.tDelta : travdatstatic.tDelta;

  // cell index delta to get to next cell (+1 or -1)
  travdatstatic.step = ray.d > zero ? one : minusone;

  // cell index when the ray leaves the grid
  travdatstatic.outNo = ray.d > zero ? grid_dim : minusone;

  // All rays start in the traversal state
  raystate.state = float4(1,0,0,0);
}


// steps a ray in traversal mode into the next grid voxel
kernel void
krnTraverseVoxel(Ray ray<>, TraversalDataStatic travdatstatic<>,
                 TraversalDataDyn travdatdynold<>, RayState oldraystate<>,
                 GridTrilistOffset listoffset[], float3 grid_dim,
                 out TraversalDataDyn travdatdyn<>, out RayState raystate<>)
{
   float3 compmask;
   float minval;
   float offsetaddr;
   float trilistpos;

   if (oldraystate.state.x > 0) {
      minval = min(min(travdatdynold.tMax.x,
                       travdatdynold.tMax.y), travdatdynold.tMax.z);

      if (minval == travdatdynold.tMax.x) {
         compmask = float3(1,0,0);
      } else if (minval == travdatdynold.tMax.y) {
         compmask = float3(0,1,0);
      } else if (minval == travdatdynold.tMax.z) {
         compmask = float3(0,0,1);
      }

      if (travdatdynold.voxNo.x == travdatstatic.outNo.x ||
            travdatdynold.voxNo.y == travdatstatic.outNo.y ||
            travdatdynold.voxNo.z == travdatstatic.outNo.z ||
            dot(travdatdynold.tMax, compmask) > 999999) { //should be tmax, but busted now...

         // ray is out of grid, do nothing
         travdatdyn.voxNo = travdatdynold.voxNo;
         travdatdyn.tMax = travdatdynold.tMax;
         travdatdyn.voxToUse = travdatdynold.voxToUse;
         raystate.state = float4(0,0,0,0);
      } else {

         // use linear offset of current voxel to fetch offset into the
         // triangle list The list of triangles located in this voxel starts
         // at this offset in the global triangle list
         offsetaddr = grid_dim.z*(travdatdynold.voxNo.x*grid_dim.y +
                                  travdatdynold.voxNo.y) + travdatdynold.voxNo.z;
         trilistpos = listoffset[offsetaddr].listOffset;
         travdatdyn.voxToUse = travdatdynold.voxNo;

         // update dynamic ray state to next voxel
         travdatdyn.voxNo = travdatdynold.voxNo + compmask*travdatstatic.step;
         travdatdyn.tMax = travdatdynold.tMax + compmask*travdatstatic.tDelta;

         if (trilistpos >= 0) {
            // go into isect state if triangles in this voxel
            raystate.state = float4(0,1,0,trilistpos);
         } else {
            raystate.state = float4(1,0,0,0); // no triangles, continue stepping
         }
      }
   } else {
      // do nothing, ray not in traversal state
      travdatdyn.voxNo = travdatdynold.voxNo;
      travdatdyn.tMax = travdatdynold.tMax;
      travdatdyn.voxToUse = travdatdynold.voxToUse;
      raystate.state = oldraystate.state;
   }
}


/*
 * krnIntersectTriangle --
 *
 *      First stage of ray-triangle intersection.  Projects the ray into the
 *      plane of the current triangle and records the point of intersection
 *      for additional checks in krnValidateIntersection.
 *
 * Results:
 *      candidateHit reflects where the ray would hit the triangle (if it
 *      hits it at all).
 */

kernel void
krnIntersectTriangle(Ray ray<>, Triangle tris[], RayState rayState<>,
                     GridTrilist trilist[], out Hit candidateHit<>)
{
   float idx, det, inv_det;
   float3 edge1, edge2, pvec, tvec, qvec;

   if (rayState.state.y > 0) {
      // starting index of triangle list to search is stored in rayState.state.w
      // first get a triangle number
      idx = trilist[rayState.state.w].triNum;

      edge1 = tris[idx].v1 - tris[idx].v0;
      edge2 = tris[idx].v2 - tris[idx].v0;
      pvec = cross(ray.d, edge2);
      det = dot(edge1, pvec);
      inv_det = 1.0f/det;
      tvec = ray.o - tris[idx].v0;
      qvec = cross( tvec, edge1 );

      candidateHit.data.x = dot(edge2, qvec) * inv_det;   // ray tHit
      candidateHit.data.y = dot(tvec, pvec) * inv_det;    // uu
      candidateHit.data.z = dot(ray.d, qvec) * inv_det;   // vv
      candidateHit.data.w = idx;                          // triangleNum
   } else {
      candidateHit.data = float4(0,0,0,-1);
   }
}


/*
 * krnValidateIntersection --
 *
 *      Does the second phase of ray-triangle intersection.  The candidate
 *      hits that come have already been projected into the plane of the
 *      triangle they're testing.  This routine checks if the rays hit inside
 *      the triangle and that they're closer than any hits already found.
 *      Once it's done, it updates the rayState so that the next triangle is
 *      tested, the next voxel is entered, or the ray is marked done and
 *      ready for shading.
 *
 * Results:
 *      prevHit and oldRayState are both stale with hit and rayState
 *      containing the now current data.
 */

kernel void
krnValidateIntersection(Ray ray<>, Hit candidateHit<>,
                        float3 grid_min, float3 grid_vsize, float3 grid_dim,
                        Hit prevHit<>, TraversalDataDyn travdatdyn<>,
                        RayState oldRayState<>, GridTrilist trilist[],
                        out Hit hit<>, out RayState rayState<>)
{
   if (oldRayState.state.y > 0) {
      float triNum;
      float validHit;

      /*
       * In order for us to consider it 'valid' a hit must have:
       *
       *  - Non-negative u, v barycentric coordinates
       *  - u + v less than one (i.e. the third coordinate also positive)
       *  - A hit time less than the hit time of the curent best hit.
       *  - A non-negative hit time.
       */

      validHit = (candidateHit.data.y >= 0.0f && candidateHit.data.z >= 0.0f &&
                 (candidateHit.data.y + candidateHit.data.z) <= 1.0f &&
                 candidateHit.data.x <= prevHit.data.x &&
                 candidateHit.data.x >= 0.0f) ? 1 : 0;

      /*
       * We also make sure the candidate hit intersects the portion of the
       * triangle that lies in the current voxel.  Otherwise we'll record it
       * when we get to the relevant voxel (if it's still the best hit).
       */

      if (validHit) {
         float3 hitP, myVox;
         float3 fudgeUp, fudgeDown;

         // fudge .01 to elimate speckles...
         hitP = ray.o + ray.d*(candidateHit.data.x - 0.01f);
         myVox = floor((hitP - grid_min) / grid_vsize);
         myVox.x = myVox.x >= grid_dim.x ? myVox.x-1 : myVox.x;
         myVox.y = myVox.y >= grid_dim.y ? myVox.y-1 : myVox.y;
         myVox.z = myVox.z >= grid_dim.z ? myVox.z-1 : myVox.z;

         // fudge more since equality is busted...
         fudgeUp = travdatdyn.voxToUse + 0.1f;
         fudgeDown = travdatdyn.voxToUse - 0.1f;

         validHit = (myVox.x >= fudgeDown.x && myVox.x <= fudgeUp.x &&
                     myVox.y >= fudgeDown.y && myVox.y <= fudgeUp.y &&
                     myVox.z >= fudgeDown.z && myVox.z <= fudgeUp.z) ? 1 : 0;
       }

      // Either propagate any hit we've already found or replace it.
      hit.data = validHit > 0 ? candidateHit.data : prevHit.data;

      /*
       * We're done with this hit.  Adjust rayState either to check the next
       * triangle in the voxel, continue traversing if we've checked all of
       * this voxel's triangles without collision, or stop traversing and mark
       * for shading if we've checked all of this voxel's triangles and found
       * a hit.
       */

      triNum = trilist[oldRayState.state.w+1].triNum;
      if (triNum < 0) {
         if (hit.data.w >= 0) {
            rayState.state = float4(0,0,1,0);
         } else {
            rayState.state = float4(1,0,0,0);
         }
      } else {
         rayState.state = float4(0,1,0, oldRayState.state.w + 1);
      }
   } else {
      // Not in intersection mode, just propagate values.
      hit.data = prevHit.data;
      rayState.state = oldRayState.state;
   }
}


kernel void
krnBruteIntersectTriangle(Ray ray<>, Triangle tris[], float idx,
                          Hit oldhit<>,TraversalDataDyn travdatdyn<>,
                          RayState oldraystate<>,
                          out Hit hit<>, out RayState raystate<>)
{
  float det, inv_det;
  float3 edge1, edge2, pvec, tvec, qvec;
  float validhit;
  float4 newhit;  //tt,uu,vv,id

  if (oldraystate.state.y > 0) {
    edge1 = tris[idx].v1 - tris[idx].v0;
    edge2 = tris[idx].v2 - tris[idx].v0;
    pvec = cross(ray.d, edge2);
    det = dot(edge1, pvec);
    inv_det = 1.0f/det;
    tvec = ray.o - tris[idx].v0;
    newhit.y = dot( tvec, pvec ) * inv_det;
    qvec = cross( tvec, edge1 );
    newhit.z = dot( ray.d, qvec ) * inv_det;
    newhit.x = dot( edge2, qvec ) * inv_det;
    newhit.w = idx;

    validhit = (newhit.y >= 0.0f && newhit.z >= 0.0f &&
                (newhit.y + newhit.z) <= 1.0f &&
		newhit.x <= oldhit.data.x && newhit.x >= 0.0f) ? 1 : 0;

    // valid only if in voxel too...

    if (validhit) {
      hit.data = newhit;
    } else {
      hit.data = oldhit.data;
    }

    //only done at end of voxel
    raystate.state = float4(0, 0, 1, oldraystate.state.w+1);
  }
}


// simple unshadowed diffuse shading of surface
kernel void
krnShadeHits(Ray ray<>, Hit hit<>, Triangle tris[],
             ShadingInfo shadinf[], float3 pointlight,
             RayState oldraystate<>, out Pixel pixel<>)
{
  float3 hitpoint, lightdir, barycoord, N, C;
  float NdotL;
  float3 newcolor;

  if (oldraystate.state.z > 0) {
    // Might need to change ordering
    barycoord = float3(hit.data.y, hit.data.z, 1.0f - hit.data.y - hit.data.z);

    N = shadinf[hit.data.w].n0*barycoord.x +
      shadinf[hit.data.w].n1*barycoord.y +
      shadinf[hit.data.w].n2*barycoord.z;

    C = shadinf[hit.data.w].c0*barycoord.x +
      shadinf[hit.data.w].c1*barycoord.y +
      shadinf[hit.data.w].c2*barycoord.z;

    hitpoint = ray.o + ray.d*hit.data.x;

    lightdir = pointlight - hitpoint;
    lightdir = lightdir/sqrt(dot(lightdir, lightdir)); //normalize

    NdotL = max(0,dot(N, lightdir)); //one sided lighting

    newcolor = C*NdotL;

    if (hit.data.w >= 0) {
      pixel.data = float4(newcolor.x, newcolor.y, newcolor.z, 1);
    } else {
      pixel.data = float4(0,1,0,0);  // shade as red if bogus hit surfuce
    }
  } else {
    // no hit
    pixel.data = float4(0,0,0,0);
  }
}
