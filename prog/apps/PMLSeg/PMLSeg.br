// This is code based of the work on Sherbondy et al. that does a
// Perona Malik segmentation across an image.

#include <stdio.h>
#include <stdlib.h>
#include "main.h"
#include "PMLSeg.h"
// unpacked version (float2 in/out)
kernel void process_img( float2 img[][], float diff_strength,
         		 float inv_grad_cutoff, float loww, float highw,
                         iter float2 it0<>, iter float2 it1<>, iter float2 it2<>, 
		         iter float2 it3<>, iter float2 it4<>, out float2 o_img<> ) {
    float e = 2.7182817f;
    float2 R0;
    float2 R1;
    float2 R2;
    float2 R3;
    float2 R4;
    float4 R5;
    float4 R6;

    R0 = img[it0];

    R1 = img[it1]; //-1,0
    R2 = img[it2]; //+1,0
    R3 = img[it3]; //0,-1
    R4 = img[it4]; //0,+1

    //Image differentials
    R6.x = (R1.x - R0.x); //-ds
    R6.y = (R2.x - R0.x); //-dw
    R6.z = (R3.x - R0.x); //dn
    R6.w = (R4.x - R0.x); //de

    //Segmentation differentials	
    R5.x = (R1.y - R0.y)*diff_strength;	
    R5.y = (R2.y - R0.y)*diff_strength;	
    R5.z = (R3.y - R0.y)*diff_strength;	
    R5.w = (R4.y - R0.y)*diff_strength;

    R6 = R6*R6*inv_grad_cutoff;

    R6.x = pow(e, -R6.x);
    R6.y = pow(e, -R6.y);
    R6.z = pow(e, -R6.z);
    R6.w = pow(e, -R6.w);

    R6 = dot(R6, R5);
    R0.y = R0.y+R6.x;

    R4.y = R0.x - loww;
    R0.y = R4.y < 0 ? 0.0 : R0.y;

    R4.y = R0.x - highw;
    R0.y = R4.y < 0 ? R0.y : 0.0;

    o_img.x = R0.x;
    o_img.y = R0.y;
}

//packed version (float4 in/out)
kernel void process_img_pack( float4 img[][], float diff_strength,
                              float inv_grad_cutoff, float loww, float highw,
                              iter float2 it0<>, iter float2 it1<>, 
			      iter float2 it2<>, iter float2 it3<>, 
			      iter float2 it4<>, out float4 o_img<> ) {
    float e = 2.7182817f;
    float4 R0;
    float4 R1;
    float4 R2;
    float4 R3;
    float4 R4;
    float4 R5;
    float4 R6;
    float4 R7;
    float4 R8;

    R0 = img[it0];
    R1 = img[it1]; //-1,0
    R2 = img[it2]; //+1,0
    R3 = img[it3]; //0,-1
    R4 = img[it4]; //0,+1

    //Image differentials
    R6.x = (R1.z - R0.x); //-d1s
    R6.y = (R0.z - R0.x); //-d1w
    R6.z = (R3.x - R0.x); //d1n
    R6.w = (R4.x - R0.x); //d1e

    R7.x = (R0.x - R0.z); //-d2s
    R7.y = (R2.x - R0.z); //-d2w
    R7.z = (R3.z - R0.z); //d2n
    R7.w = (R4.z - R0.z); //d2e
	
    //Segmentation differentials
    R5.x = (R1.w - R0.y)*diff_strength;	
    R5.y = (R0.w - R0.y)*diff_strength;	
    R5.z = (R3.y - R0.y)*diff_strength;	
    R5.w = (R4.y - R0.y)*diff_strength;

    R8.x = (R0.y - R0.w)*diff_strength;	
    R8.y = (R2.y - R0.w)*diff_strength;	
    R8.z = (R3.w - R0.w)*diff_strength;	
    R8.w = (R4.w - R0.w)*diff_strength;

    R6 = R6*R6*inv_grad_cutoff;
    R7 = R7*R7*inv_grad_cutoff;

    R6.x = pow(e, -R6.x);
    R6.y = pow(e, -R6.y);
    R6.z = pow(e, -R6.z);
    R6.w = pow(e, -R6.w);

    R7.x = pow(e, -R7.x);
    R7.y = pow(e, -R7.y);
    R7.z = pow(e, -R7.z);
    R7.w = pow(e, -R7.w);

    R6 = dot(R6, R5);
    R7 = dot(R7, R8);
    R0.y = R0.y+R6.x;
    R0.w = R0.w+R7.x;

    R4.y = R0.x - loww;
    o_img.y = R4.y < 0 ? 0.0 : R0.y;

    R4.y = R0.x - highw;
    o_img.y = R4.y < 0 ? R0.y : 0.0;

    R4.y = R0.z - loww;
    o_img.w = R4.y < 0 ? 0.0 : R0.w;

    R4.y = R0.z - highw;
    o_img.w = R4.y < 0 ? R0.w : 0.0;

    o_img.x = R0.x;
    o_img.z = R0.z;
}

int PMLSeg_main(int argc, char* argv[]) {
    float* output = NULL;
    float* input = NULL;
    int i, j;
    float time_in_ms = 0.0f;
    int xsize, ysize, loop_count;
    float xsizef, ysizef;
    float diff_strength = 0.20f;
    float inv_grad_cutoff = 0.025f;
    float loww = 1200./65535.;
    float highw = 2000./65535.0f;

    if(argc < 4){
          char buf[255];
          fprintf(stderr, "Usage: %s <size x> <size y> <loop count>\n", argv[0]);
	  fprintf(stderr, "Size in X: ");
	  fgets(buf, 254, stdin);
	  xsize = atoi(buf);
	  fprintf(stderr, "Size in Y: ");
	  fgets(buf, 254, stdin);
	  ysize = atoi(buf);
          ysize = ysize/2 + ysize%2; //round up
	  fprintf(stderr, "# of loops: ");
	  fgets(buf, 254, stdin);
	  loop_count = atoi(buf);
          xsizef = (float)xsize;
          ysizef = (float)ysize;
    }
    else{
        xsize = atoi(argv[1]);
        ysize = atoi(argv[2]);
        ysize = ysize/2 + ysize%2; //round up
        xsizef = (float)xsize;
        ysizef = (float)ysize;
        loop_count = atoi(argv[3]);
    }
    
    // MCH: It makes me ill that I have to open a new scope to get this to work.
    {
        // Setup the iterators to do a north/south/east/west/local lookup into the image
        iter float2 it0<xsize,ysize> = iter( float2(0.0f,  0.0f), float2(xsizef,      ysizef) );
        iter float2 it1<xsize,ysize> = iter( float2(-1.0f, 0.0f), float2(xsizef-1.0f, ysizef) );
        iter float2 it2<xsize,ysize> = iter( float2(1.0f,  0.0f), float2(xsizef+1.0f, ysizef) );
        iter float2 it3<xsize,ysize> = iter( float2(0.0f, -1.0f), float2(xsizef,      ysizef-1.0f) );
        iter float2 it4<xsize,ysize> = iter( float2(0.0f,  1.0f), float2(xsizef,      ysizef+1.0f) );
        float4 img<xsize,ysize>;
        float4 o_img<xsize,ysize>;
    	
        input  = (float*)malloc(xsize*ysize*4*sizeof(float));
        output = (float*)malloc(xsize*ysize*4*sizeof(float));

	// Fill an image with random data and set up the seed point in the middle
        for(i=0; i<xsize*ysize*2; i+=2){
		input[i] = rand()/(float)INT_MAX;
	}   
	//Let's insert some seed data at 175x256
	for(i=xsize/2-2; i<xsize/2+2; i++){
		for(j=ysize/2-2; j<ysize/2+2; j++){
			input[2*(j*xsize+i)+1] = 1.0f;
		}
	}

        //Start timing
        start = GetTime();

        //Build the input stream out of the image and seed data
        streamRead(img, input);

        //Do the requested number of iterations
        for(i=0; i<loop_count; i++){
	    //We can't use the input and output buffers without hosing things
	    //so we'll need to "ping-pong" between them
            if(i%2==0)
                process_img_pack(img, diff_strength, inv_grad_cutoff, loww, highw, 
                                 it0, it1, it2, it3, it4, o_img );
            else
                process_img_pack(o_img, diff_strength, inv_grad_cutoff, loww, highw,
                                 it0, it1, it2, it3, it4, img );
	
        }
        if(i%2==0)
            streamWrite(img, output);
        else
	    streamWrite(o_img, output);

        //Stop time
        stop = GetTime();

        time_in_ms = (float)(stop-start)/1000.;
        fprintf(stderr, "That took %.2fms total\n", time_in_ms);
        fprintf(stderr, "That's %.2fms per loop\n", time_in_ms/loop_count);
        fprintf(stderr, "That's %.2fMFlops\n", (2*30*xsize*2*ysize)/(time_in_ms*1000./loop_count));
        fprintf(stderr, "Internal read bandwidth is %.2fMB/s\n", 
                (4*5*4*(xsize*2)*ysize/(1024.*1024.))/((time_in_ms/loop_count)/1000.));
        fprintf(stderr, "Internal write bandwidth is %.2fMB/s\n", 
                (4*4*(xsize*2)*ysize/(1024.*1024.))/((time_in_ms/loop_count)/1000.));
    }
    return 0;
}
